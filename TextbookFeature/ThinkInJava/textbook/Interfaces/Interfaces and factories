  An interface is intended to be a gateway to multiple implementations, and a typical way to produce objects that fit the interface is the Factory Method design pattern. Instead of calling a constructor directly, you call a creation method on a factory object which produces an implementation of the interface—this way, in theory, your code is completely isolated from the implementation of the interface, thus making it possible to transparently swap one implementation for another. Here’s a demonstration showing the structure of the Factory Method: 
  Without the Factory Method, your code would somewhere have to specify the exact type of Service being created, so that it could call the appropriate constructor. 
  Why would you want to add this extra level of indirection? One common reason is to create a framework. Suppose you are creating a system to play games; for example, to play both chess and checkers on the same board: 
  If the Games class represents a complex piece of code, this approach allows you to reuse that code with different types of games. You can imagine more elaborate games that can benefit from this pattern. In the next chapter, you’ll see a more elegant way to implement the factories using anonymous inner classes. 
  Exercise 18: (2) Create a Cycle interface, with implementations Unicycle, Bicycle and Tricycle. Create factories for each type of Cycle, and code that uses these factories. 
  Exercise 19: (3) Create a framework using Factory Methods that performs both coin tossing and dice tossing. 
