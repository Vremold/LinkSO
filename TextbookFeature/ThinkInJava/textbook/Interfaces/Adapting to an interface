  One of the most compelling reasons for interfaces is to allow multiple implementations for the same interface. In simple cases this is in the form of a method that accepts an interface, leaving it up to you to implement that interface and pass your object to the method. 
  Thus, a common use for interfaces is the aforementioned Strategy design pattern. You write a method that performs certain operations, and that method takes an interface that you also specify. You’re basically saying, "You can use my method with any object you like, as long as your object conforms to my interface." This makes your method more flexible, general and reusable. 
  For example, the constructor for the Java SE5 Scanner class (which you’ll learn more about in the Strings chapter) takes a Readable interface. You’ll find that Readable is not an argument for any other method in the Java standard library—it was created solely for Scanner, so that Scanner doesn’t have to constrain its argument to be a particular class. This way, Scanner can be made to work with more types. If you create a new class and you want it to be usable with Scanner, you make it Readable, like this: 
  The Readable interface only requires the implementation of a read( ) method. Inside read( ), you add to the CharBuffer argument (there are several ways to do this; see the CharBuffer documentation), or return -l when you have no more input. 
  Suppose you have a class that does not already implement Readable—how do you make it work with Scanner? Here’s an example of a class that produces random floating point numbers: 
  Because you can add an interface onto any existing class in this way, it means that a method that takes an interface provides a way for any class to be adapted to work with that method. This is the power of using interfaces instead of classes. 
  Exercise 16: (3) Create a class that produces a sequence of chars. Adapt this class so that it can be an input to a Scanner object. 
