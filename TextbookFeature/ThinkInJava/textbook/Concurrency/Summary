  The goal of this chapter was to give you the foundations of concurrent programming with Java threads, so that you understand that: 
  tool used to prevent these collisions. 
  It is vital to learn when to use concurrency and when to avoid it. The main reasons to use it are: 
  • To manage a number of tasks whose intermingling will use the computer more efficiently (including the ability to transparently distribute the tasks across multiple CPUs). 
  • To allow better code organization. 
  • To be more convenient for the user. 
  The classic example of resource balancing is to use the CPU during I/O waits. Better code organization is typically seen in simulations. The classic example of user convenience is to monitor a "stop" button during long downloads. 
  An additional advantage to threads is that they provide "light" execution context switches (on the order of 100 instructions) rather than "heavy" process context switches (thousands of instructions). Since all threads in a given process share the same memory space, a light context switch changes only program execution and local variables. A process change—the heavy context switch—must exchange the full memory space. 
  The main drawbacks to multithreading are: 
  (multiple threads working individual tasks that the ensemble can’t finish). 
  examples for this book, I discovered race conditions that quickly appeared on some computers but that wouldn’t appear on others. If you develop a program on the latter, you might get badly surprised when you distribute it. 
  One of the biggest difficulties with threads occurs because more than one task might be sharing a resource—such as the memory in an object—and you must make sure that multiple tasks don’t try to read and change that resource at the same time. This requires judicious use of the available locking mechanisms (for example, the synchronized keyword). These are essential tools, but they must be understood thoroughly because they can quietly introduce deadlock situations. 
  In addition, there’s an art to the application of threads. Java is designed to allow you to create as many objects as you need to solve your problem—at least in theory. (Creating millions of objects for an engineering finite-element analysis, for example, might not be practical in Java without the use of the Flyweight design pattern.) However, it seems that there is an upper bound to the number of threads you’ll want to create, because at some number, threads seem to become balky. This critical point can be hard to detect and will often depend on the OS and JVM; it can be less than a hundred or in the thousands. As you will often create only a handful of threads to solve a problem, this is typically not much of a limit, but in a more general design it becomes a constraint that might force you to add a cooperative concurrency scheme. 
  Regardless of how simple threading can seem using a particular language or library, consider it a black art. There’s always something that can bite you when you least expect it. The reason that the dining philosophers problem is interesting is that it can be adjusted so that deadlock rarely happens, giving you the impression that everything is copacetic. 
  In general, use threading carefully and sparingly. If your threading issues get large and complex, consider using a language like Erlang. This is one of several functional languages that are specialized for threading. It may be possible to use such a language for the portions of your program that demand threading, if you are doing lots of it, and if it’s complicated enough to justify this approach. 
  
Further reading
  Unfortunately, there is a lot of misleading information about concurrency— this emphasizes how confusing it can be, and how easy it is to think that you understand the issues (I know, because I’ve been under the impression that I’ve understood threading numerous times in the past, and I have no doubt that there will be more epiphanies for me in the future). There’s always a bit of sleuthing required when you pick up a new document about concurrency, to try to understand how much the writer does and doesn’t understand. Here are some books that I think I can safely say are reliable: 
  Java Concurrency in Practice, by Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea (Addison-Wesley, 2006). Basically, the "who’s who" in the Java threading world. 
  Concurrent Programming in Java, Second Edition, by Doug Lea (Addison-Wesley, new java.util.concurrent libraries, so this book is essential for a complete understanding of concurrency issues. It goes beyond Java concurrency and discusses current thinking across languages and technologies. Although it can be obtuse in places, it merits rereading several times (preferably with months in between in order to internalize the information). Doug is one of the few people in the world who actually understand concurrency, so this is a worthwhile endeavor. 
  The Java Language Specification, Third Edition (Chapter 17), by Gosling, Joy, Steele, and Bracha (Addison-Wesley, 2005). The technical specification, conveniently available as an electronic document: http://java.sun.com/docs/books/jls. 
  Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from www.MindView.net. 
