  As you’ve seen, when you use threads to run more than one task at a time, you can keep one task from interfering with another task’s resources by using a lock (mutex) to synchronize the behavior of the two tasks. That is, if two tasks are stepping on each other over a shared resource (usually memory), you use a mutex to allow only one task at a time to access that resource. 
  With that problem solved, the next step is to learn how to make tasks cooperate with each other, so that multiple tasks can work together to solve a problem. Now the issue is not about interfering with one another, but rather about working in unison, since portions of such problems must be solved before other portions can be solved. It’s much like project planning: The footings for the house must be dug first, but the steel can be laid and the concrete forms can be built in parallel, and both of those tasks must be finished before the concrete foundation can be poured. The plumbing must be in place before the concrete slab can be poured, the concrete slab must be in place before you start framing, and so on. Some of these tasks can be done in parallel, but certain steps require all tasks to be completed before you can move ahead. 
  The key issue when tasks are cooperating is handshaking between those tasks. To accomplish this handshaking, we use the same foundation: the mutex, which in this case guarantees that only one task can respond to a signal. This eliminates any possible race conditions. On top of the mutex, we add a way for a task to suspend itself until some external state changes (e.g., "The plumbing is now in place"), indicating that it’s time for that task to move forward. In this section, we’ll look at the issues of handshaking between tasks, which is safely implemented using the Object methods wait( ) and notifyAll( ). The Java SE5 concurrency library also provides Condition objects with await( ) and signal( ) methods. We’ll see the problems that can arise, and their solutions. 
wait() and notifyAll()
  wait( ) allows you to wait for a change in some condition that is outside the control of the forces in the current method. Often, this condition will be changed by another task. You don’t want to idly loop while testing the condition inside your task; this is called busy waiting, and it’s usually a bad use of CPU cycles. So wait( ) suspends the task while waiting for the world to change, and only when a notify( ) or notifyAll( ) occurs—suggesting that something of interest may have happened—does the task wake up and check for changes. Thus, wait( ) provides a way to synchronize activities between tasks. 
  It’s important to understand that sleep( ) does not release the object lock when it is called, and neither does yield( ). On the other hand, when a task enters a call to wait( ) inside a method, that thread’s execution is suspended, and the lock on that object is released. Because wait( ) releases the lock, it means that the lock can be acquired by another task, so other synchronized methods in the (now unlocked) object can be called during a wait( ). This is essential, because those other methods are typically what cause the change that makes it interesting for the suspended task to reawaken. Thus, when you call wait( ), you’re saying, "I’ve done all I can right now, so I’m going to wait right here, but I want to allow other synchronized operations to take place if they can." 
  There are two forms of wait( ). One version takes an argument in milliseconds that has the same meaning as in sleep( ): "Pause for this period of time." But unlike with sleep( ), with wait(pause): 
  letting the clock run out. 
  The second, more commonly used form of wait( ) takes no arguments. This wait( ) continues indefinitely until the thread receives a notify( ) or notifyAll( ). 
  One fairly unique aspect of wait( ), notify( ), and notifyAll( ) is that these methods are part of the base class Object and not part of Thread. Although this seems a bit strange at first—to have something that’s exclusively for threading as part of the universal base class— it’s essential because these methods manipulate the lock that’s also part of every object. As a result, you can put a wait( ) inside any synchronized method, regardless of whether that class extends Thread or implements Runnable. In fact, the only place you can call wait( ), notify( ), or notifyAll( ) is within a synchronized method or block (sleep( ) can be called within non-synchronized methods since it doesn’t manipulate the lock). If you call any of these within a method that’s not synchronized, the program will compile, but when you run it, you’ll get an IllegalMonitorStateException with the somewhat nonintuitive message "current thread not owner." This message means that the task calling wait( ), notify( ), or notifyAll( ) must "own" (acquire) the lock for the object before it can call any of those methods. 
  You can ask another object to perform an operation that manipulates its own lock. To do this, you must first capture that object’s lock. For example, if you want to send notifyAll( ) to an object x, you must do so inside a synchronized block that acquires the lock for x: 
  synchronized(x) { x.notifyAll(); } 
  Let’s look at a simple example. WaxOMatic.java has two processes: one to apply wax to a Car and one to polish it. The polishing task cannot do its job until the application task is finished, and the application task must wait until the polishing task is finished before it can put on another coat of wax. Both WaxOn and WaxOff use the Car object, which uses wait( ) and notifyAll( ) to suspend and restart tasks while they’re waiting for a condition to change: 
  Here, Car has a single boolean waxOn, which indicates the state of the waxing-polishing process. 
  In waitForWaxing( ), the waxOn flag is checked, and if it is false, the calling task is suspended by calling wait( ). It’s important that this occur in a synchronized method, where the task has acquired the lock. When you call wait( ), the thread is suspended and the lock is released. It is essential that the lock be released because, to safely change the state of the object (for example, to change waxOn to true, which must happen if the suspended task is to ever continue), that lock must be available to be acquired by some other task. In this example, when another task calls waxed( ) to indicate that it’s time to do something, the lock must be acquired in order to change waxOn to true. Afterward, waxed( ) calls notifyAll( ), which wakes up the task that was suspended in the call to wait( ). In order for the task to wake up from a wait( ), it must first reacquire the lock that it released when it 20 entered the wait( ). The task will not wake up until that lock becomes available. 
  WaxOn.run( ) represents the first step in the process of waxing the car, so it performs its operation: a call to sleep( ) to simulate the time necessary for waxing. It then tells the car that waxing is complete, and calls waitForBuffing( ), which suspends this task with a    essentially means that a thread may prematurely stop blocking (while waiting on a condition variable or semaphore) without being prompted by a notify( ) or notifyAll( ) (or their equivalents for the new Condition objects). The thread just wakes up, seemingly by itself. Spurious wake-ups exist because implementing POSIX threads, or the equivalent, isn’t always as straightforward as it should be on some platforms. Allowing spurious wake-ups makes the job of building a library like pthreads easier for those platforms. 
  wait( ) until the WaxOff task calls buffed( ) for the car, changing the state and calling notifyAll( ). WaxOff.run( ), on the other hand, immediately moves into waitForWaxing( ) and is thus suspended until the wax has been applied by WaxOn and waxed( ) is called. When you run this program, you can watch this two-step process repeat itself as control is handed back and forth between the two tasks. After five seconds, interrupt( ) halts both threads; when you call shutdownNow( ) for an ExecutorService, it calls interrupt( ) for all the tasks it is controlling. 
  The previous example emphasizes that you must surround a wait( ) with a while loop that checks the condition(s) of interest. This is important because: 
  • You may have multiple tasks waiting on the same lock for the same reason, and the first task that wakes up might change the situation (even if you don’t do this someone might inherit from your class and do it). If that is the case, this task should be suspended again until its condition of interest changes. 
  • By the time this task awakens from its wait( ), it’s possible that some other task will have changed things such that this task is unable to perform or is uninterested in performing its operation at this time. Again, it should be resuspended by calling wait( ) again. 
  • It’s also possible that tasks could be waiting on your object’s lock for different reasons (in which case you must use notifyAll( )). In this case, you need to check whether you’ve been woken up for the right reason, and if not, call wait( ) again. 
  Thus, it’s essential that you check for your particular condition of interest, and go back into wait( ) if that condition is not met. This is idiomatically written using a while. 
  Exercise 21: (2) Create two Runnables, one with a run( ) that starts and calls wait( ). The second class should capture the reference of the first Runnable object. Its run( ) should call notifyAll( ) for the first task after some number of seconds have passed so that the first task can display a message. Test your classes using an Executor. 
  Exercise 22: (4) Create an example of a busy wait. One task sleeps for a while and then sets a flag to true. The second task watches that flag inside a while loop (this is the busy wait) and when the flag becomes true, sets it back to false and reports the change to the console. Note how much wasted time the program spends inside the busy wait, and create a second version of the program that uses wait( ) instead of the busy wait. 
  Missed Signals  When two threads are coordinated using notify( )/wait( ) or notifyAll( )/wait( ), it’s possible to miss a signal. Suppose T1 is a thread that notifies T2, and that the two threads are implemented using the following (flawed) approach: 
  T1: synchronized(sharedMonitor) { <setup condition for T2> sharedMonitor.notify(); } 
  T2: while(someCondition) { // Point 1 synchronized(sharedMonitor) { sharedMonitor.wait(); } } 
  The <setup condition for T2> is an action to prevent T2 from calling wait( ), if it hasn’t already. 
  Assume that T2 evaluates someCondition and finds it true. At Point 1, the thread scheduler might switch to T1. T1 executes its setup, and then calls notify( ). When T2 continues executing, it is too late for T2 to realize that the condition has been changed in the meantime, and it will blindly enter wait( ). The notify( ) will be missed and T2 will wait indefinitely for the signal that was already sent, producing deadlock. 
  The solution is to prevent the race condition over the someCondition variable. Here is the correct approach for T2: 
  synchronized(sharedMonitor) { while(someCondition) sharedMonitor.wait(); } 
  Now, if T1 executes first, when control returns back to T2 it will figure out that the condition has changed, and will not enter wait( ). Conversely, if T2 executes first, it will enter wait( ) and later be awakened by T1. Thus, the signal cannot be missed. 
notify() vs. notifyAll()
  Because more than one task could technically be in a wait( ) on a single Car object, it is safer to call notifyAll( ) rather than just notify( ). However, the structure of the above program is such that only one task will actually be in a wait( ), so you could use notify( ) instead of notifyAll( ). 
  Using notify( ) instead of notifyAll( ) is an optimization. Only one task of the possible many that are waiting on a lock will be awoken with notify( ), so you must be certain that the right task will wake up if you try to use notify( ). In addition, all tasks must be waiting on the same condition in order for you to use notify( ), because if you have tasks that are waiting on different conditions, you don’t know if the right one will wake up. If you use notify( ), only one task must benefit when the condition changes. Finally, these constraints must always be true for all possible subclasses. If any of these rules cannot be met, you must use notifyAll( ) rather than notify( ). 
  One of the confusing statements often made in discussions of Java threading is that notifyAll( ) wakes up "all waiting tasks." Does this mean that any task that is in a wait( ), anywhere in the program, is awoken by any call to notifyAll( )? In the following example, the code associated with Task2 shows that this is not true—in fact, only the tasks that are waiting on a particular lock are awoken when notifyAll( ) is called/or that lock: 
  Task and Task2 each have their own Blocker object, so each Task object blocks on Task.blocker, and each Task2 object blocks on Task2.blocker. In main( ), a java.util.Timer object is set up to execute its run( ) method every 4/10 of a second, and that run( ) alternates between calling notify( ) and notifyAll( ) on Task.blocker via the "prod" methods. 
  From the output, you can see that even though a Task2 object exists and is blocked on Task2.blocker, none of the notify( ) or notifyAll( ) calls on Task.blocker causes the Task2 object to wake up. Similarly, at the end of main( ), cancel( ) is called for the timer, and even though the timer is canceled, the first five tasks are still running and still blocked in their calls to Task.blocker.waitingCall( ). The output from the call to Task2.blocker.prodAll( ) does nor include any of the tasks waiting on the lock in Task.blocker. 
  This also makes sense if you look at prod( ) and prodAll( ) in Blocker. These methods are synchronized, which means that they acquire their own lock, so when they call notify( ) or notifyAll( ), it’s logical that they are only calling it for that lock—and thus only wake up tasks that are waiting on that particular lock. 
  Blocker.waitingCall( ) is simple enough that you could just say for(;;) instead of while(!Thread.interrupted( )), and achieve the same effect in this case, because in this example there’s no difference between leaving the loop with an exception and leaving it by checking the interrupted( ) flag— the same code is executed in both cases. As a matter of form, however, this example checks interrupted( ), because there are two different ways of leaving the loop. If, sometime later, you decide to add more code to the loop, you risk introducing an error if you don’t cover both paths of exit from the loop. 
  Exercise 23: (7) Demonstrate that WaxOMatic.java works successfully when you use notify( ) instead of notifyAll( ). 
Producers and consumers
  Consider a restaurant that has one chef and one waitperson. The waitperson must wait for the chef to prepare a meal. When the chef has a meal ready, the chef notifies the waitperson, who then gets and delivers the meal and goes back to waiting. This is an example of task cooperation: The chef represents the producer, and the waitperson represents the consumer. Both tasks must handshake with each other as meals are produced and consumed, and the system must shut down in an orderly fashion. Here is the story modeled in code: 
  The Restaurant is the focal point for both the WaitPerson and the Chef. Both must know what Restaurant they are working for because they must place or fetch the meal from the restaurant’s "meal window," restaurant.meal. In run( ), the WaitPerson goes into wait( ) mode, stopping that task until it is woken up with a notifyAll( ) from the Chef. Since this is a very simple program, we know that only one task will be waiting on the WaitPerson’s lock: the WaitPerson task itself. For this reason, it’s theoretically possible to call notify( ) instead of notifyAll( ). However, in more complex situations, multiple tasks may be waiting on a particular object lock, so you don’t know which task should be awakened. Thus, it’s safer to call notifyAll( ), which wakes up all the tasks waiting on that lock. Each task must then decide whether the notification is relevant. 
  Once the Chef delivers a Meal and notifies the WaitPerson, the Chef waits until the WaitPerson collects the meal and notifies the Chef, who can then produce the next Meal. 
  Notice that the wait( ) is wrapped in a while( ) statement that is testing for the same thing that is being waited for. This seems a bit strange at first—if you’re waiting for an order, once you wake up, the order must be available, right? As noted earlier, the problem is that in a concurrent application, some other task might swoop in and grab the order while the WaitPerson is waking up. The only safe approach is to always use the following idiom for a wait( ) (within proper synchronization, of course, and programming against the possibility of missed signals): 
  while(conditionlsNotMet) wait(); 
  This guarantees that the condition will be met before you get out of the wait loop, and if you have been notified of something that doesn’t concern the condition (as can happen with notifyAll( )), or the condition changes before you get fully out of the wait loop, you are guaranteed to go back into waiting. 
  Observe that the call to notifyAll( ) must first capture the lock on waitPerson. The call to wait( ) in WaitPerson.run( ) automatically releases the lock, so this is possible. Because the lock must be owned in order for notifyAll( ) to be called, it’s guaranteed that two tasks trying to call notifyAll( ) on one object won’t step on each other’s toes. 
  Both run( ) methods are designed for orderly shutdown by enclosing the entire run( ) with a try block. The catch clause closes right before the closing brace of the run( ) method, so if the task receives an InterruptedException, it ends immediately after catching the exception. 
  In Chef, note that after calling shutdownNow( ) you could simply return from run( ), and normally that’s what you should do. However, it’s a little more interesting to do it this way. Remember that shutdownNow( ) sends an interrupt( ) to all the tasks that the ExecutorService started. But in the case of the Chef, the task doesn’t shut down immediately upon getting the interrupt( ), because the interrupt only throws InterruptedException as the task attempts to enter an (interruptible) blocking operation. Thus, you’ll see "Order up!" displayed first, and then the InterruptedException is thrown when the Chef attempts to call sleep( ). If you remove the call to sleep( ), the task will get to the top of the run( ) loop and exit because of the Thread.interrupted( ) test, without throwing an exception. 
  The preceding example has only a single spot for one task to store an object so that another task can later use that object. However, in a typical producerconsumer implementation, you use a first-in, first-out queue in order to store the objects being produced and consumed. You’ll learn more about such queues later in this chapter. 
  Exercise 24: (1) Solve a single-producer, single-consumer problem using wait( ) and notifyAll( ). The producer must not overflow the receiver’s buffer, which can happen if the producer is faster than the consumer. If the consumer is faster than the producer, then it must not read the same data more than once. Do not assume anything about the relative speeds of the producer or consumer. 
  Exercise 25: (1) In the Chef class in Restaurant.java, return from run( ) after calling shutdownNow( ) and observe the difference in behavior. 
  Exercise 26: (8) Add a BusBoy class to Restaurant.java. After the meal is delivered, the WaitPerson should notify the BusBoy to clean up. 
  Using explicit Lock and Condition objects  There are additional, explicit tools in the Java SE5 java.util.concurrent library that can be used to rewrite WaxOMatic.java. The basic class that uses a mutex and allows task suspension is the Condition, and you can suspend a task by calling await( ) on a Condition. When external state changes take place that might mean that a task should continue processing, you notify the task by calling signal( ), to wake up one task, or signalAll( ), to wake up all tasks that have suspended themselves on that Condition object (as with notifyAll( ), signalAll( ) is the safer approach). 
  Here’s WaxOMatic.java rewritten to contain a Condition that it uses to suspend a task inside waitForWaxing( ) or waitForBuffing( ): 
  In Car’s constructor, a single Lock produces a Condition object which is used to manage inter-task communication. However, the Condition object contains no information about the state of the process, so you need to manage additional information to indicate process state, which is the boolean waxOn. 
  Each call to lock( ) must immediately be followed by a try-finally clause to guarantee that unlocking happens in all cases. As with the built-in versions, a task must own the lock before it can call await( ), signal( ) or signalAll( ). 
  Notice that this solution is more complex than the previous one, and the complexity doesn’t gain you anything in this case. The Lock and Condition objects are only necessary for more difficult threading problems. 
  Exercise 27: (2) Modify Restaurant.java to use explicit Lock and Condition objects. 
Producer-consumers and queues
  The wait( ) and notifyAll( ) methods solve the problem of task cooperation in a rather low- level fashion, handshaking every interaction. In many cases, you can move up a level of abstraction and solve task cooperation problems using a synchronized queue, which only allows one task at a time to insert or remove an element. This is provided for you in the java.util.concurrent.BlockingQueue interface, which has a number of standard implementations. You’ll usually use the LinkedBlockingQueue, which is an unbounded queue; the ArrayBlockingQueue has a fixed size, so you can only put so many elements in it before it blocks. 
  These queues also suspend a consumer task if that task tries to get an object from the queue and the queue is empty, and resume when more elements become available. Blocking queues can solve a remarkable number of problems in a much simpler and more reliable fashion than wait( ) and notifyAll( ). 
  Here’s a simple test that serializes the execution of LiftOff objects. The consumer is LiftOffRunner, which pulls each LiftOff object off the BlockingQueue and runs it     directly. (That is, it uses its own thread by calling run( ) explicitly rather than starting up a new thread for each task.) 
  The tasks are placed on the BlockingQueue by main( ) and are taken off the BlockingQueue by the LiftOffRunner. Notice that LiftOffRunner can ignore synchronization issues because they are solved by the BlockingQueue. 
  Exercise 28: (3) Modify TestBlockingQueues.java by adding a new task that places LiftOff on the BlockingQueue, instead of doing it in main( ). 
  BlockingQueues of toast  As an example of the use of BlockingQueues, consider a machine that has three tasks: one to make toast, one to butter the toast, and one to put jam on the buttered toast. We can run the toast through BlockingQueues between processes: 
  Toast is an excellent example of the value of enums. Note that there is no explicit synchronization (using Lock objects or the synchronized keyword) because the synchronization is implicitly managed by the queues (which synchronize internally) and by the design of the system—each piece of Toast is only operated on by one task at a time. Because the queues block, processes suspend and resume automatically. You can see that the simplification produced by BlockingQueues can be quite dramatic. The coupling between the classes that would exist with explicit wait( ) and notifyAll( ) statements is eliminated because each class communicates only with its BlockingQueues. 
  Exercise 29: (8) Modify ToastOMatic.java to create peanut butter and jelly on toast sandwiches using two separate assembly lines (one for peanut butter, the second for jelly, then merging the two lines). Using pipes for I/O between tasks  It’s often useful for tasks to communicate with each other using I/O. Threading libraries may provide support for inter-task I/O in the form of pipes. These exist in the Java I/O library as the classes PipedWriter (which allows a task to write into a pipe) and PipedReader (which allows a different task to read from the same pipe). This can be thought of as a variation of the producer-consumer problem, where the pipe is the canned solution. The pipe is basically a blocking queue, which existed in versions of Java before BlockingQueue was introduced. 
  Here’s a simple example in which two tasks use a pipe to communicate: 
  Sender and Receiver represent tasks that need to communicate with each other. Sender creates a PipedWriter, which is a standalone object, but inside Receiver the creation of PipedReader must be associated with a PipedWriter in the constructor. The Sender puts data into the Writer and sleeps for a random amount of time. However, Receiver has    no sleep( ) or wait( ). But when it does a read( ), the pipe automatically blocks when there is no more data. 
  Notice that the sender and receiver are started in main( ), after the objects are completely constructed. If you don’t start completely constructed objects, the pipe can produce inconsistent behavior on different platforms. (Note that BlockingQueues are more robust and easier to use.)  An important difference between a PipedReader and normal I/O is seen when shutdownNow( ) is called—the PipedReader is interruptible, whereas if you changed, for example, the in.read( ) call to System.in.read( ), the interrupt( ) would fail to break out of the read( ) call. 
  Exercise 30: (1) Modify PipedIO.java to use a BlockingQueue instead of a pipe. 
