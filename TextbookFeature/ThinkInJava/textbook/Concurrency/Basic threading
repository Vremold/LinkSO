  Concurrent programming allows you to partition a program into separate, independently running tasks. Using multithreading, each of these independent tasks (also called subtasks) is driven by a thread of execution. A thread is a single sequential flow of control within a process. A single process can thus have multiple concurrently executing tasks, but you program as if each task has the CPU to itself. An underlying mechanism divides up the CPU time for you, but in general, you don’t need to think about it. 
  The threading model is a programming convenience to simplify juggling several operations at the same time within a single program: The CPU will pop around and give each task some of its time.4 Each task has the consciousness of constantly having the CPU to itself, but the CPU’s time is being sliced among all the tasks (except when the program is actually running on multiple CPUs). One of the great things about threading is that you are abstracted away from this layer, so your code does not need to know whether it is running on a single CPU or many. Thus, using threads is a way to create transparently scalable programs—if a program is running too slowly, you can easily speed it up by adding CPUs to your computer. Multitasking and multithreading tend to be the most reasonable ways to utilize multiprocessor systems. 
Defining tasks
  A thread drives a task, so you need a way to describe that task. This is provided by the Runnable interface. To define a task, simply implement Runnable and write a run( ) method to make the task do your bidding. 
  For example, the following LiftOff task displays the countdown before liftoff: 
  The identifier id distinguishes between multiple instances of the task. It is final because it is not expected to change once it is initialized. 
  A task’s run( ) method usually has some kind of loop that continues until the task is no longer necessary, so you must establish the condition on which to break out of this loop (one option is to simply return from run( )). Often, run( ) is cast in the form of an infinite loop, which means that, barring some factor that causes run( ) to terminate, it will continue forever (later in the chapter you’ll see how to safely terminate tasks). 
  The call to the static method Thread.yield( ) inside run( ) is a suggestion to the thread scheduler (the part of the Java threading mechanism that moves the CPU from one thread to the next) that says, "I’ve done the important parts of my cycle and this would be a good time to switch to another task for a while." It’s completely optional, but it is used here because it tends to produce more interesting output in these examples: You’re more likely to see evidence of tasks being swapped in and out. 
  In the following example, the task’s run( ) is not driven by a separate thread; it is simply called directly in main( ) (actually, this is using a thread: the one that is always allocated for main( )): 
  When a class is derived from Runnable, it must have a run( ) method, but that’s nothing special—it doesn’t produce any innate threading abilities. To achieve threading behavior, you must explicitly attach a task to a thread. 
The Thread class
  The traditional way to turn a Runnable object into a working task is to hand it to a Thread constructor. This example shows how to drive a Liftoff object using a Thread: 
  A Thread constructor only needs a Runnable object. Calling a Thread object’s start( ) will perform the necessary initialization for the thread and then call that Runnable’s run( ) method to start the task in the new thread. Even though start( ) appears to be making a call to a long-running method, you can see from the output—the "Waiting for LiftOff’ message appears before the countdown has completed—that start( ) quickly returns. In effect, you have made a method call to LiftOff.run( ), and that method has not yet finished, but because LiftOff.run( ) is being executed by a different thread, you can still perform other operations in the main( ) thread. (This ability is not restricted to the main( ) thread—any thread can start another thread.) Thus, the program is running two methods at once— main( ) and LiftOff.run( ). run( ) is the code that is executed "simultaneously" with the other threads in a program. 
  You can easily add more threads to drive more tasks. Here, you can see how all the tasks run in concert with one another:5  //: concurrency/MoreBasicThreads.java // Adding more threads. 
  public class MoreBasicThreads { public static void main(String[] args) { for(int i = 0; i < 5; i++) new Thread(new LiftOff()).start(); System.out.println("Waiting for LiftOff"); } } /* Output: (Sample) Waiting for LiftOff #0(9), #1(9), #2(9), #3(9), #4(9), #0(8), #1(8), #2(8), #3(8), #4(8), #0(7), #1(7), #2(7), #3(7), #4(7), #0(6), #1(6), #2(6), #3(6), #4(6), #0(5), #1(5), #2(5), #3(5), #4(5), #0(4), #1(4), #2(4), #3(4), #4(4), #0(3), #1(3), #2(3), #3(3), #4(3), #0(2), #1(2), #2(2), #3(2), #4(2), #0(1), #1(1), #2(1), #3(1), #4(1), #0(Liftoff!), #1(Liftoff!), #2(Liftoff!), #3(Liftoff!), #4(Liftoff!), *///:~ 
  The output shows that the execution of the different tasks is mixed together as the threads are swapped in and out. This swapping is automatically controlled by the thread scheduler. If     threads, however, it is possible for more than one LiftOff to have the same id. You’ll learn why later in this chapter. 
  you have multiple processors on your machine, the thread scheduler will quietly distribute 6 the threads among the processors. 
  The output for one run of this program will be different from that of another, because the thread-scheduling mechanism is not deterministic. In fact, you may see dramatic differences in the output of this simple program between one version of the JDK and the next. For example, an earlier JDK didn’t timeslice very often, so thread l might loop to extinction first, then thread 2 would go through all of its loops, etc. This was virtually the same as calling a routine that would do all the loops at once, except that starting up all those threads is more expensive. Later JDKs seem to produce better time-slicing behavior, so each thread seems to get more regular service. Generally, these kinds of JDK behavioral changes have not been mentioned by Sun, so you cannot plan on any consistent threading behavior. The best approach is to be as conservative as possible while writing threaded code. 
  When main( ) creates the Thread objects, it isn’t capturing the references for any of them. With an ordinary object, this would make it fair game for garbage collection, but not with a Thread. Each Thread "registers" itself so there is actually a reference to it someplace, and the garbage collector can’t clean it up until the task exits its run( ) and dies. You can see from the output that the tasks are indeed running to conclusion, so a thread creates a separate thread of execution that persists after the call to start( ) completes. 
  Exercise 1: (2) Implement a Runnable. Inside run( ), print a message, and then call yield( ). Repeat this three times, and then return from run( ). Put a startup message in the constructor and a shutdown message when the task terminates. Create a number of these tasks and drive them using threads. 
  Exercise 2: (2) Following the form of generics/Fibonacci.java, create a task that produces a sequence of n Fibonacci numbers, where n is provided to the constructor of the task. Create a number of these tasks and drive them using threads. 
Using Executors
  Java SE5 java.util.concurrent Executors simplify concurrent programming by managing Thread objects for you. Executors provide a layer of indirection between a client and the execution of a task; instead of a client executing a task directly, an intermediate object executes the task. Executors allow you to manage the execution of asynchronous tasks without having to explicitly manage the lifecycle of threads. Executors are the preferred method for starting tasks in Java SE5/6. 
  We can use an Executor instead of explicitly creating Thread objects in MoreBasicThreads.java. A LiftOff object knows how to run a specific task; like the Command design pattern, it exposes a single method to be executed. An ExecutorService (an Executor with a service lifecycle—e.g., shutdown) knows how to build the appropriate context to execute Runnable objects. In the following example, the CachedThreadPool creates one thread per task. Note that an ExecutorService object is created using a static Executors method which determines the kind of Executor it will be: 
  Very often, a single Executor can be used to create and manage all the tasks in your system. 
  The call to shutdown( ) prevents new tasks from being submitted to that Executor. The current thread (in this case, the one driving main( )) will continue to run all tasks submitted before shutdown( ) was called. The program will exit as soon as all the tasks in the Executor finish. 
  You can easily replace the CachedThreadPool in the previous example with a different type of Executor. A FixedThreadPool uses a limited set of threads to execute the submitted tasks: 
  With the FixedThreadPool, you do expensive thread allocation once, up front, and you thus limit the number of threads. This saves time because you aren’t constantly paying for thread creation overhead for every single task. Also, in an event-driven system, event handlers that require threads can be serviced as quickly as you want by simply fetching threads from the pool. You don’t overrun the available resources because the FixedThreadPool uses a bounded number of Thread objects. 
  Note that in any of the thread pools, existing threads are automatically reused when possible. 
  Although this book will use CachedThreadPools, consider using FixedThreadPools in production code. A CachedThreadPool will generally create as many threads as it needs during the execution of a program and then will stop creating new threads as it recycles the old ones, so it’s a reasonable first choice as an Executor. Only if this approach causes problems do you need to switch to a FixedThreadPool. 
  7 A SingleThreadExecutor is like a FixedThreadPool with a size of one thread. This is useful for anything you want to run in another thread continually (a long-lived task), such as a task that listens to incoming socket connections. It is also handy for short tasks that you want to run in a thread— for example, small tasks that update a local or remote log, or for an eventdispatching thread. 
  If more than one task is submitted to a SingleThreadExecutor, the tasks will be queued and each task will run to completion before the next task is begun, all using the same thread. In the following example, you’ll see each task completed, in the order in which it was submitted, before the next one is begun. Thus, a SingleThreadExecutor serializes the tasks that are submitted to it, and maintains its own (hidden) queue of pending tasks. 
  As another example, suppose you have a number of threads running tasks that use the file system. You can run these tasks with a SingleThreadExecutor to ensure that only one task at a time is running from any thread. This way, you don’t need to deal with synchronizing on the shared resource (and you won’t clobber the file system in the meantime). Sometimes a better solution is to synchronize on the resource (which you’ll learn about later in this chapter), but a SingleThreadExecutor lets you skip the trouble of getting coordinated properly just to prototype something. By serializing tasks, you can eliminate the need to serialize the objects. 
  Exercise 3: (1) Repeat Exercise 1 using the different types of executors shown in this section. 
  Exercise 4: (1) Repeat Exercise 2 using the different types of executors shown in this section. 
Producing return values from tasks
  A Runnable is a separate task that performs work, but it doesn’t return a value. If you want the task to produce a value when it’s done, you can implement the Callable interface rather than the Runnable interface. Callable, introduced in Java SE5, is a generic with a type parameter representing the return value from the method call( ) (instead of run( )), and must be invoked using an ExecutorService submit( ) method. Here’s a simple example: 
  changes the locking requirements for the tasks (you’ll learn about locking later in the chapter). 
  The submit( ) method produces a Future object, parameterized for the particular type of result returned by the Callable. You can query the Future with isDone( ) to see if it has completed. When the task is completed and has a result, you can call get( ) to fetch the result. You can simply call get( ) without checking isDone( ), in which case get( ) will block until the result is ready. You can also call get( ) with a timeout, or isDone( ) to see if the task has completed, before trying to call get( ) to fetch the result. 
  The overloaded Executors.callable( ) method takes a Runnable and produces a Callable. ExecutorService has some "invoke" methods that run collections of Callable objects. 
  Exercise 5: (2) Modify Exercise 2 so that the task is a Callable that sums the values of all the Fibonacci numbers. Create several tasks and display the results. 
  
Sleeping
  A simple way to affect the behavior of your tasks is by calling sleep( ) to cease (block) the execution of that task for a given time. In the LiftOff class, if you replace the call to yield( ) with a call to sleep( ), you get the following: 
  The call to sleep( ) can throw an InterruptedException, and you can see that this is caught in run( ). Because exceptions won’t propagate across threads back to main( ), you must locally handle any exceptions that arise within a task. 
  Java SE5 introduced the more explicit version of sleep( ) as part of the TimeUnit class, as shown in the above example. This provides better readability by allowing you to specify the units of the sleep( ) delay. TimeUnit can also be used to perform conversions, as you shall see later in the chapter. 
  Depending on your platform, you may notice that the tasks run in "perfectly distributed" order—zero through four, then back to zero again. This makes sense because, after each print statement, each task goes to sleep (it blocks), which allows the thread scheduler to switch to another thread, driving another task. However, the sequential behavior relies on the underlying threading mechanism, which is different from one operating system to another, so you cannot rely on it. If you must control the order of execution of tasks, your best bet is to use synchronization controls (described later) or, in some cases, not to use threads at all, but instead to write your own cooperative routines that hand control to each other in a specified order. 
  Exercise 6: (2) Create a task that sleeps for a random amount of time between 1 and 10 seconds, then displays its sleep time and exits. Create and run a quantity (given on the command line) of these tasks. 
Priority
  The priority of a thread conveys the importance of a thread to the scheduler. Although the order in which the CPU runs a set of threads is indeterminate, the scheduler will lean toward running the waiting thread with the highest priority first. However, this doesn’t mean that threads with lower priority aren’t run (so you can’t get deadlocked because of priorities). Lower-priority threads just tend to run less often. 
  The vast majority of the time, all threads should run at the default priority. Trying to manipulate thread priorities is usually a mistake. 
  Here’s an example that demonstrates priority levels. You can read the priority of an existing thread with getPriority( ) and change it at any time with setPriority( ). 
  toString( ) is overridden to use Thread.toString( ), which prints the thread name, the priority level, and the "thread group" that the thread belongs to. You can set the thread name yourself via the constructor; here it’s automatically generated as pool-1-thread-1, pool-1- thread-2, etc. The overridden toString( ) also shows the countdown value of the task. Notice that you can get a reference to the Thread object that is driving a task, inside that task, by calling Thread.currentThread( ). 
  You can see that the priority level of the last thread is at the highest level, and all the rest of the threads are at the lowest level. Note that the priority is set at the beginning of run( ); setting it in the constructor would do no good since the Executor has not begun the task at that point. 
  Inside run( ), 100,000 repetitions of a rather expensive floating point calculation are performed, involving double addition and division. The variable d is volatile to try to ensure that no compiler optimizations are performed. Without this calculation, you don’t see the effect of setting the priority levels. (Try it: Comment out the for loop containing the double calculations.) With the calculation, you see that the thread with MAX_PRIORITY is given a higher preference by the thread scheduler. (At least, this was the behavior on a Windows XP machine.) Even though printing to the console is also an expensive behavior, you won’t see the priority levels that way, because console printing doesn’t get interrupted (otherwise, the console display would get garbled during threading), whereas the math calculation can be interrupted. The calculation takes long enough that the scheduling mechanism jumps in, swaps tasks, and pays attention to the priorities so that high-priority threads get preference. However, to ensure that a context switch occurs, yield( ) statements are regularly called. 
  Although the JDK has 10 priority levels, this doesn’t map well to many operating systems. For example, Windows has 7 priority levels that are not fixed, so the mapping is indeterminate. Sun’s Solaris has 231 levels. The only portable approach is to stick to MAX_PRIORITY, NORM_PRIORITY, and MIN_PRIORITY when you’re adjusting priority levels. 
Yielding
  If you know that you’ve accomplished what you need to during one pass through a loop in your run( ) method, you can give a hint to the threadscheduling mechanism that you’ve done enough and that some other task might as well have the CPU. This hint (and it is a hint—there’s no guarantee your implementation will listen to it) takes the form of the yield( ) method. When you call yield( ), you are suggesting that other threads of the same priority might be run. 
  LiftOff.java uses yield( ) to produce well-distributed processing across the various LiftOff tasks. Try commenting out the call to Thread.yield( ) in LiftOff.run( ) to see the difference. In general, however, you can’t rely on yield( ) for any serious control or tuning of your application. Indeed, yield( ) is often used incorrectly. 
Daemon threads
  A "daemon" thread is intended to provide a general service in the background as long as the program is running, but is not part of the essence of the program. Thus, when all of the non- daemon threads complete, the program is terminated, killing all daemon threads in the process. Conversely, if there are any non-daemon threads still running, the program doesn’t terminate. There is, for instance, a non-daemon thread that runs main( ). 
  You must set the thread to be a daemon by calling setDaemon( ) before it is started. 
  There’s nothing to keep the program from terminating once main( ) finishes its job, since there are nothing but daemon threads running. So that you can see the results of starting all the daemon threads, the main( ) thread is briefly put to sleep. Without this, you see only some of the results from the creation of the daemon threads. (Try sleep( ) calls of various lengths to see this behavior.)  SimpleDaemons.java creates explicit Thread objects in order to set their daemon flag. It is possible to customize the attributes (daemon, priority, name) of threads created by Executors by writing a custom ThreadFactory: 
  The only difference from an ordinary ThreadFactory is that this one sets the daemon status to true. You can now pass a new DaemonThreadFactory as an argument to Executors.newCachedThreadPool( ): 
  Each of the static ExecutorService creation methods is overloaded to take a ThreadFactory object that it will use to create new threads. 
  We can take this one step further and create a DaemonThreadPoolExecutor utility: 
  To get the values for the constructor base-class call, I simply looked at the Executors.java source code. 
  You can find out if a thread is a daemon by calling isDaemon( ). If a thread is a daemon, then any threads it creates will automatically be daemons, as the following example demonstrates: 
  The Daemon thread is set to daemon mode. It then spawns a bunch of other threads—which are nor explicitly set to daemon mode—to show that they are daemons anyway. Then Daemon goes into an infinite loop that calls yield( ) to give up control to the other processes. 
  You should be aware that daemon threads will terminate their run( ) methods without executing finally clauses: 
  When you run this program, you’ll see that the finally clause is not executed, but if you comment out the call to setDaemon( ), you’ll see that the finally clause is executed. 
  This behavior is correct, even if you don’t expect it based on the previous promises given for finally. Daemons are terminated "abruptly" when the last of the non-daemons terminates. So as soon as main( ) exits, the JVM shuts down all the daemons immediately, without any of the formalities you might have come to expect. Because you cannot shut daemons down in a nice fashion, they are rarely a good idea. Non-daemon Executors are generally a better approach, since all the tasks controlled by an Executor can be shut down at once. As you shall see later in the chapter, shutdown in this case proceeds in an orderly fashion. 
  Exercise 7: (2) Experiment with different sleep times in Daemons.java to see what happens. 
  Exercise 8: (1) Modify MoreBasicThreads.java so that all the threads are daemon threads, and verify that the program ends as soon as main( ) is able to exit. 
  Exercise 9: (3) Modify SimplePriorities.java so that a custom ThreadFactory sets the priorities of the threads. 
Coding variations
  In the examples that you’ve seen so far, the task classes all implement Runnable. In very simple cases, you may want to use the alternative approach of inheriting directly from Thread, like this: 
  You give the Thread objects specific names by calling the appropriate Thread constructor. This name is retrieved in toString( ) using getName( ). 
  Another idiom that you may see is that of the self-managed Runnable: 
  This is not especially different from inheriting from Thread except that the syntax is slightly more awkward. However, implementing an interface does allow you to inherit from a different class, whereas inheriting from Thread does not. 
  Notice that start( ) is called within the constructor. This example is quite simple and therefore probably safe, but you should be aware that starting threads inside a constructor can be quite problematic, because another task might start executing before the constructor has completed, which means the task may be able to access the object in an unstable state. This is yet another reason to prefer the use of Executors to the explicit creation of Thread objects. 
  Sometimes it makes sense to hide your threading code inside your class by using an inner class, as shown here: 
  InnerThread1 creates a named inner class that extends Thread, and makes an instance of this inner class inside the constructor. This makes sense if the inner class has special capabilities (new methods) that you need to access in other methods. However, most of the time the reason for creating a thread is only to use the Thread capabilities, so it’s not necessary to create a named inner class. InnerThread2 shows the alternative: An anonymous inner subclass of Thread is created inside the constructor and is upcast to a Thread reference t. If other methods of the class need to access t, they can do so through the Thread interface, and they don’t need to know the exact type of the object. 
  The third and fourth classes in the example repeat the first two classes, but they use the Runnable interface rather than the Thread class. 
  The ThreadMethod class shows the creation of a thread inside a method. You call the method when you’re ready to run the thread, and the method returns after the thread begins. If the thread is only performing an auxiliary operation rather than being fundamental to the class, this is probably a more useful and appropriate approach than starting a thread inside the constructor of the class. 
  Exercise 10: (4) Modify Exercise 5 following the example of the ThreadMethod class, so that runTask( ) takes an argument of the number of Fibonacci numbers to sum, and each time you call runTask( ) it returns the Future produced by the call to submit( ). 
Terminology
  As the previous section shows, you have choices in how you implement concurrent programs in Java, and these choices can be confusing. Often the problem comes from the terminology that’s used in describing concurrent program technology, especially where threads are involved. 
  You should see by now that there’s a distinction between the task that’s being executed and the thread that drives it; this distinction is especially clear in the Java libraries because you don’t really have any control over the Thread class (and this separation is even clearer with executors, which take care of the creation and management of threads for you). You create tasks and somehow attach a thread to your task so that the thread will drive that task. 
  In Java, the Thread class by itself does nothing. It drives the task that it’s given. Yet threading literature invariably uses language like "the thread performs this or that action." The impression that you get is that the thread is the task, and when I first encountered Java threads, this impression was so strong that I saw a clear "is-a" relationship, which said to me that I should obviously inherit a task from a Thread. Add to this the poor choice of name for the Runnable interface, which I think would have been much better named "Task." If the interface is clearly nothing more than a generic encapsulation of its methods, then the "it- does-this-thing-able" naming approach is appropriate, but if it intends to express a higher concept, like Task, then the concept name is more helpful. 
  The problem is that the levels of abstraction are mixed together. Conceptually, we want to create a task that runs independently of other tasks, so we ought to be able to define a task, and then say "go," and not worry about details. But physically, threads can be expensive to create, so you must conserve and manage them. Thus it makes sense from an implementation standpoint to separate tasks from threads. In addition, Java threading is based on the low-level pthreads approach which comes from C, where you are immersed in, and must thoroughly understand, the nuts and bolts of everything that’s going on. Some of this low-level nature has trickled through into the Java implementation, so to stay at a higher level of abstraction, you must use discipline when writing code (I will try to demonstrate that discipline in this chapter). 
  To clarify these discussions, I shall attempt to use the term "task" when I am describing the work that is being done, and "thread" only when I am referring to the specific mechanism that’s driving the task. Thus, if you are discussing a system at a conceptual level, you could just use the term "task" without mentioning the driving mechanism at all. 
Joining a thread
  One thread may call join( ) on another thread to wait for the second thread to complete before proceeding. If a thread calls t.join( ) on another thread t, then the calling thread is suspended until the target thread t finishes (when t.isAlive( ) is false). 
  You may also call join( ) with a timeout argument (in either milliseconds or milliseconds and nanoseconds) so that if the target thread doesn’t finish in that period of time, the call to join( ) returns anyway. 
  The call to join( ) may be aborted by calling interrupt( ) on the calling thread, so a try- catch clause is required. 
  All of these operations are shown in the following example: 
  A Sleeper is a thread that goes to sleep for a time specified in its constructor. In run( ), the call to sleep( ) may terminate when the time expires, but it may also be interrupted. Inside the catch clause, the interruption is reported, along with the value of isInterrupted( ). 
  When another thread calls interrupt( ) on this thread, a flag is set to indicate that the thread has been interrupted. However, this flag is cleared when the exception is caught, so the result will always be false inside the catch clause. The flag is used for other situations where a thread may examine its interrupted state apart from the exception. 
  A Joiner is a task that waits for a Sleeper to wake up by calling join( ) on the Sleeper object. In main( ), each Sleeper has a Joiner, and you can see in the output that if the Sleeper either is interrupted or ends normally, the Joiner completes in conjunction with the Sleeper. 
  Note that the Java SE5 java.util.concurrent libraries contain tools such as CyclicBarrier (demonstrated later in this chapter) that may be more appropriate than join( ), which was part of the original threading library. 
Creating responsive user interfaces
  As stated earlier, one of the motivations for using threading is to create a responsive user interface. Although we won’t get to graphical interfaces until the Graphical User Interfaces chapter, the following example is a simple mock-up of a console-based user interface. The example has two versions: one that gets stuck in a calculation and thus can never read console input, and a second that puts the calculation inside a task and thus can be performing the calculation and listening for console input. 
  UnresponsiveUI performs a calculation inside an infinite while loop, so it can obviously never reach the console input line (the compiler is fooled into believing that the input line is reachable by the while conditional). If you uncomment the line that creates an UnresponsiveUI, you’ll have to kill the process to get out. 
  To make the program responsive, put the calculation inside a run( ) method to allow it to be preempted, and when you press the Enter key, you’ll see that the calculation has indeed been running in the background while waiting for your user input. 
Thread groups
  A thread group holds a collection of threads. The value of thread groups can be summed up 8 by a quote from Joshua Bloch, the software architect who, while he was at Sun, fixed and greatly improved the Java collections library in JDK 1.2 (among other contributions): 
  "Thread groups are best viewed as an unsuccessful experiment, and you may simply ignore their existence." 
  If you’ve spent time and energy trying to figure out the value of thread groups (as I have), you may wonder why there was not some more official announcement from Sun on the topic—the same question can be asked about any number of other changes that have happened to Java over the years. The Nobel laureate economist Joseph Stiglitz has a philosophy of life that 9 would seem to apply here. It’s called The Theory of Escalating Commitment: 
  "The cost of continuing mistakes is borne by others, while the cost of admitting mistakes is borne by yourself." 
  
Catching exceptions
  Because of the nature of threads, you can’t catch an exception that has escaped from a thread. Once an exception gets outside of a task’s run( ) method, it will propagate out to the console unless you take special steps to capture such errant exceptions. Before Java SE5, you used thread groups to catch these exceptions, but with Java SE5 you can solve the problem with Executors, and thus you no longer need to know anything about thread groups (except to understand legacy code; see Thinking in Java, 2ndEdition, downloadable from www.MindView.net, for details about thread groups). 
  Here’s a task that always throws an exception which propagates outside of its run( ) method, and a main( ) that shows what happens when you run it: 
  The output is (after trimming some qualifiers to fit): 
  java.lang.RuntimeException   few projects where this has applied. 
  at ExceptionThread.run(ExceptionThread.java:7) at ThreadPoolExecutor$Worker.runTask(Unknown Source) at ThreadPoolExecutor$Worker.run(Unknown Source) at Java.lang.Thread.run(Unknown Source)  Encompassing the body of main within a try-catch block is unsuccessful: 
  This produces the same result as the previous example: an uncaught exception. 
  To solve the problem, we change the way the Executor produces threads. Thread.UncaughtExceptionHandler is a new interface in Java SE5; it allows you to attach an exception handler to each Thread object. Thread.UncaughtExceptionHandler.uncaughtException( ) is automatically called when that thread is about to die from an uncaught exception. To use it, we create a new type of ThreadFactory which attaches a new Thread.UncaughtExceptionHandler to each new Thread object it creates. We pass that factory to the Executors method that creates a new ExecutorService: 
  Additional tracing has been added to verify that the threads created by the factory are given the new UncaughtExceptionHandler. You can see that the uncaught exceptions are now being captured by uncaughtException. 
  The above example allows you to set the handler on a case-by-case basis. If you know that you’re going to use the same exception handler everywhere, an even simpler approach is to set the default uncaught exception handler, which sets a static field inside the Thread class: 
  This handler is only called if there is no per-thread uncaught exception handler. The system checks for a per-thread version, and if it doesn’t find one it checks to see if the thread group specializes its uncaughtException( ) method; if not, it calls the defaultUncaughtExceptionHandler. 
