  In some of the previous examples, cancel( ) and isCanceled( ) methods are placed in a class that is seen by all tasks. The tasks check isCanceled( ) to determine when to terminate themselves. This is a reasonable approach to the problem. However, in some situations the task must be terminated more abruptly. In this section, you’ll learn about the issues and problems of such termination. 
  First, let’s look at an example that not only demonstrates the termination problem but also is an additional example of resource sharing. 
The ornamental garden
  In this simulation, the garden committee would like to know how many people enter the garden each day through its multiple gates. Each gate has a turnstile or some other kind of counter, and after the turnstile count is incremented, a shared count is incremented that represents the total number of people in the garden. 
  A single Count object keeps the master count of garden visitors, and is stored as a static field in the Entrance class. Count.increment( ) and Count.value( ) are synchronized to control access to the count field. The increment( ) method uses a Random object to cause a yield( ) roughly half the time, in between fetching count into temp and incrementing and storing temp back into count. If you comment out the synchronized keyword on increment( ), the program breaks because multiple tasks will be accessing and modifying count simultaneously (the yield( ) causes the problem to happen more quickly). 
  Each Entrance task keeps a local value number containing the number of visitors that have passed through that particular entrance. This provides a double check against the count object to make sure that the proper number of visitors is being recorded. Entrance.run( ) simply increments number and the count object and sleeps for 100 milliseconds. 
  Because Entrance.canceled is a volatile boolean flag which is only read and assigned (and is never read in combination with other fields), it’s possible to get away without synchronizing access to it. If you have any doubts about something like this, it’s always better to use synchronized. 
  This program goes to quite a bit of extra trouble to shut everything down in a stable fashion. Part of the reason for this is to show just how careful you must be when terminating a multithreaded program, and part of the reason is to demonstrate the value of interrupt( ), which you will learn about shortly. 
  After 3 seconds, main( ) sends the static cancel( ) message to Entrance, then calls shutdown( ) for the exec object, and then calls awaitTermination( ) on exec. ExecutorService.awaitTermination( ) waits for each task to complete, and if they all complete before the timeout value, it returns true, otherwise it returns false to indicate that not all tasks have completed. Although this causes each task to exit its run( ) method and therefore terminate as a task, the Entrance objects are still valid because, in the constructor, each Entrance object is stored in a static List<Entrance> called entrances. Thus, sumEntrances( ) is still working with valid Entrance objects. 
  As this program runs, you will see the total count and the count at each entrance displayed as people walk through a turnstile. If you remove the synchronized declaration on Count.increment( ), you’ll notice that the total number of people is not what you expect it to be. The number of people counted by each turnstile will be different from the value in count. As long as the mutex is there to synchronize access to the Count, things work correctly. Keep in mind that Count.increment( ) exaggerates the potential for failure by using temp and yield( ). In real threading problems, the possibility for failure may be statistically small, so you can easily fall into the trap of believing that things are working correctly. Just as in the example above, there are likely to be hidden problems that haven’t occurred to you, so be exceptionally diligent when reviewing concurrent code. 
  Exercise 17: (2) Create a radiation counter that can have any number of remote sensors. 
Terminating when blocked
  Entrance.run( ) in the previous example includes a call to sleep( ) in its loop. We know that sleep( ) will eventually wake up and the task will reach the top of the loop, where it has an opportunity to break out of that loop by checking the cancelled flag. However, sleep( ) is just one situation where a task is blocked from executing, and sometimes you must terminate a task that’s blocked. 
  Thread states  A thread can be in any one of four states: 
  any necessary system resources and performs initialization. At this point it becomes eligible to receive CPU time. The scheduler will then transition this thread to the runnable or blocked state. 
  CPU cycles available for the thread. Thus, the thread might or might not be running at any moment, but there’s nothing to prevent it from being run if the scheduler can arrange it. That is, it’s not dead or blocked. 
  blocked state, the scheduler will simply skip it and not give it any CPU time. Until a thread reenters the runnable state, it won’t perform any operations. 
  receive any CPU time. Its task is completed, and it is no longer runnable. One way for a task to die is by returning from its run( ) method, but a task’s thread can also be interrupted, as you’ll see shortly. 
  Becoming blocked  A task can become blocked for the following reasons: 
  • You’ve put the task to sleep by calling sleep(milliseconds), in which case it will not be run for the specified time. 
  • You’ve suspended the execution of the thread with wait( ). It will not become runnable again until the thread gets the notify( ) or notifyAll( ) message (or the equivalent signal( ) or signalAll( ) for the Java SE5 java.util.concurrent library tools). We’ll examine these in a later section. 
  • The task is waiting for some I/O to complete. 
  • The task is trying to call a synchronized method on another object, and that object’s lock is not available because it has already been acquired by another task. 
  In old code, you may also see suspend( ) and resume( ) used to block and unblock threads, but these are deprecated in modern Java (because they are deadlock-prone), and so will not be examined in this book. The stop( ) method is also deprecated, because it doesn’t release the locks that the thread has acquired, and if the objects are in an inconsistent state ("damaged"), other tasks can view and modify them in that state. The resulting problems can be subtle and difficult to detect. 
  The problem we need to look at now is this: Sometimes you want to terminate a task that is in a blocked state. If you can’t wait for it to get to a point in the code where it can check a state value and decide to terminate on its own, you have to force the task out of its blocked state. 
  
Interruption
  As you might imagine, it’s much messier to break out of the middle of a Runnable.run( ) method than it is to wait for that method to get to a test of a "cancel" flag, or to some other place where the programmer is ready to leave the method. When you break out of a blocked task, you might need to clean up resources. Because of this, breaking out of the middle of a task’s run( ) is more like throwing an exception than anything else, so in Java threads, 16 exceptions are used for this kind of abort. (This walks the fine edge of being an inappropriate use of exceptions, because it means you are often using them for control flow.) To return to a known good state when terminating a task this way, you must carefully consider the execution paths of your code and write your catch clause to properly clean everything up. 
  So that you can terminate a blocked task, the Thread class contains the interrupt( ) method. This sets the interrupted status for that thread. A thread with its interrupted status set will throw an InterruptedException if it is already blocked or if it attempts a blocking operation. The interrupted status will be reset when the exception is thrown or if the task calls Thread.interrupted( ). As you’ll see, Thread.interrupted( ) provides a second way to leave your run( ) loop, without throwing an exception. 
  To call interrupt( ), you must hold a Thread object. You may have noticed that the new concurrent library seems to avoid the direct manipulation of Thread objects and instead tries to do everything through Executors. If you call shutdownNow( ) on an Executor, it will send an interrupt( ) call to each of the threads it has started. This makes sense because you’ll usually want to shut down all the tasks for a particular Executor at once, when you’ve finished part of a project or a whole program. However, there are times when you may want to only interrupt a single task. If you’re using Executors, you can hold on to the context of a task when you start it by calling submit( ) instead of execute( ). submit( ) returns a generic Future<?>, with an unspecified parameter because you won’t ever call get( ) on it— the point of holding this kind of Future is that you can call cancel( ) on it and thus use it to interrupt a particular task. If you pass true to cancel( ), it has permission to call interrupt( ) on that thread in order to stop it; thus cancel( ) is a way to interrupt individual threads started with an Executor. 
  Here’s an example that shows the basics of interrupt( ) using Executors: 
  Each task represents a different kind of blocking. SleepBlock is an example of interruptible blocking, whereas IOBlocked and SynchronizedBlocked are uninterruptible blocking.17 The program proves that I/O and waiting on a synchronized lock are not interruptible, but you can also anticipate this by looking at the code—no InterruptedException handler is required for either I/O or attempting to call a synchronized method. 
  The first two classes are straightforward: The run( ) method calls sleep( ) in the first class and read( ) in the second. To demonstrate SynchronizedBlocked, however, we must first acquire the lock. This is accomplished in the constructor by creating an instance of an anonymous Thread class that acquires the object lock by calling f( ) (the thread must be different from the one driving run( ) for SynchronizedBlock because one thread can acquire an object lock multiple times). Since f( ) never returns, that lock is never released. SynchronizedBlock.run( ) attempts to call f( ) and is blocked waiting for the lock to be released. 
  You’ll see from the output that you can interrupt a call to sleep( ) (or any call that requires you to catch InterruptedException). However, you cannot interrupt a task that is trying to acquire a synchronized lock or one that is trying to perform I/O. This is a little disconcerting, especially if you’re creating a task that performs I/O, because it means that I/O has the potential of locking your multithreaded program. Especially for Web-based programs, this is a concern. 
  A heavy-handed but sometimes effective solution to this problem is to close the underlying resource on which the task is blocked: 
  After shutdownNow( ) is called, the delays before calling close( ) on the two input streams emphasize that the tasks unblock once the underlying resource is closed. It’s interesting to note that the interrupt( ) appears when you are closing the Socket but not when closing System.in. 
  Fortunately, the nio classes introduced in the I/O chapter provide for more civilized interruption of I/O. Blocked nio channels automatically respond to interrupts: 
  As shown, you can also close the underlying channel to release the block, although this should rarely be necessary. Note that using execute( ) to start both tasks and calling e.shutdownNow( ) will easily terminate everything; capturing the Future in the example 18 above was only necessary to send the interrupt to one thread and not the other. 
  Exercise 18: (2) Create a non-task class with a method that calls sleep( ) for a long interval. Create a task that calls the method in the non-task class. In main( ), start the task, then call interrupt( ) to terminate it. Make sure that the task shuts down safely. 
  Exercise 19: (4) Modify OrnamentalGarden.java so that it uses interrupt( ). 
  Exercise 20: (1) Modify CachedThreadPool.java so that all tasks receive an interrupt( ) before they are completed. 
  Blocked by a mutex  As you saw in Interrupting.java, if you try to call a synchronized method on an object whose lock has already been acquired, the calling task will be suspended (blocked) until the lock becomes available. The following example shows how the same mutex can be multiply acquired by the same task: 
  In main( ), a Thread is created to call f1( ), then f1( ) and f2( ) call each other until the count becomes zero. Since the task has already acquired the multiLock object lock inside the first call to f1( ), that same task is reacquiring it in the call to f2( ), and so on. This makes sense because one task should be able to call other synchronized methods within the same object; that task already holds the lock. 
  As observed previously with uninterruptible I/O, anytime that a task can be blocked in such a way that it cannot be interrupted, you have the potential to lock up a program. One of the features added in the Java SE5 concurrency libraries is the ability for tasks blocked on ReentrantLocks to be interrupted, unlike tasks blocked on synchronized methods or critical sections: 
  The class BlockedMutex has a constructor that acquires the object’s own Lock and never releases it. For that reason, if you try to call f( ) from a second task (different from the one that created the BlockedMutex), you will always be blocked because the Mutex cannot be acquired. In Blocked2, the run( ) method will be stopped at the call to blocked.f( ). When you run the program, you’ll see that, unlike an I/O call, interrupt( ) can break out of a call that’s blocked by a mutex.19 
Checking for an interrupt
  Note that when you call interrupt( ) on a thread, the only time that the interrupt occurs is when the task enters, or is already inside, a blocking operation (except, as you’ve seen, in the case of uninterruptible I/O or blocked synchronized methods, in which case there’s nothing you can do). But what if you’ve written code that may or may not make such a blocking call, depending on the conditions in which it is run? If you can only exit by throwing an exception on a blocking call, you won’t always be able to leave the run( ) loop. Thus, if you call interrupt( ) to stop a task, your task needs a second way to exit in the event that your run( ) loop doesn’t happen to be making any blocking calls. 
  This opportunity is presented by the interrupted status, which is set by the call to interrupt( ). You check for the interrupted status by calling interrupted( ). This not only tells you whether interrupt( ) has been called, it also clears the interrupted status. Clearing the interrupted status ensures that the framework will not notify you twice about a task being interrupted. You will be notified via either a single InterruptedException or a single successful Thread.interrupted( ) test. If you want to check again to see whether you were interrupted, you can store the result when you call Thread.interrupted( ). 
  The following example shows the typical idiom that you should use in your run( ) method to handle both blocked and non-blocked possibilities when the interrupted status is set: 
  The NeedsCleanup class emphasizes the necessity of proper resource cleanup if you leave the loop via an exception. Note that all NeedsCleanup resources created in Blocked3.run( ) must be immediately followed by try-finally clauses to guarantee that the cleanup( ) method is always called. 
  You must give the program a command-line argument which is the delay time in milliseconds before it calls interrupt( ). By using different delays, you can exit Blocked3.run( ) at different points in the loop: in the blocking sleep( ) call, and in the non-blocking mathematical calculation. You’ll see that if interrupt( ) is called after the comment "point2" (during the non-blocking operation), first the loop is completed, then all the local objects are destroyed, and finally the loop is exited at the top via the while statement. However, if interrupt( ) is called between "pointi" and "point2" (after the while statement but before or during the blocking operation sleep( )), the task exits via the InterruptedException, the first time a blocking operation is attempted. In that case, only the NeedsCleanup objects that have been created up to the point where the exception is thrown are cleaned up, and you have the opportunity to perform any other cleanup in the catch clause. 
  A class designed to respond to an interrupt( ) must establish a policy to ensure that it will remain in a consistent state. This generally means that the creation of all objects that require cleanup must be followed by try-finally clauses so that cleanup will occur regardless of how the run( ) loop exits. Code like this can work well, but alas, due to the lack of automatic destructor calls in Java, it relies on the client programmer to write the proper try-finally clauses. 
