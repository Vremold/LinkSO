  In any container, you must have a way to insert elements and fetch them out again. After all, that’s the primary job of a container—to hold things. In a List, add( ) is one way to insert elements, and get( ) is one way to fetch elements. 
  If you want to start thinking at a higher level, there’s a drawback: You need to program to the exact type of the container in order to use it. This might not seem bad at first, but what if you write code for a List, and later on you discover that it would be convenient to apply that same code to a Set? Or suppose you’d like to write, from the beginning, a piece of general- purpose code that doesn’t know or care what type of container it’s working with, so that it can be used on different types of containers without rewriting that code? 
  The concept of an Iterator (another design pattern) can be used to achieve this abstraction. An iterator is an object whose job is to move through a sequence and select each object in that sequence without the client programmer knowing or caring about the underlying structure of that sequence. In addition, an iterator is usually what’s called a lightweight object: one that’s cheap to create. For that reason, you’ll often find seemingly strange constraints for iterators; for example, the Java Iterator can move in only one direction. There’s not much you can do with an Iterator except: 
  1. Ask a Collection to hand you an Iterator using a method called iterator( ). That Iterator will be ready to return the first element in the sequence. 
  2. Get the next object in the sequence with next( ). 
  3. See if there are any more objects in the sequence with hasNext( ). 
  4. Remove the last element returned by the iterator with remove( ). 
  To see how it works, we can again use the Pets tools from the Type Information chapter: 
  With an Iterator, you don’t need to worry about the number of elements in the container. That’s taken care of for you by hasNext( ) and next( ). 
  If you’re simply moving forward through the List and not trying to modify the List object itself, you can see that the foreach syntax is more succinct. 
  An Iterator will also remove the last element produced by next( ), which means you must call next( ) before you call remove( ).4  This idea of taking a container of objects and passing through it to perform an operation on each one is powerful and will be seen throughout this book. 
  Now consider the creation of a display( ) method that is container-agnostic: 
  Note that display( ) contains no information about the type of sequence that it is traversing, and this shows the true power of the Iterator: the ability to separate the operation of traversing a sequence from the underlying structure of that sequence. For this reason, we sometimes say that iterators unify access to containers. 
  Exercise 8: (1) Modify Exercise l so it uses an Iterator to move through the List while calling hop( ). 
  Exercise 9: (4) Modify innerclasses/Sequence.java so that Sequence works with an Iterator instead of a Selector. 
  Exercise 10: (2) Change Exercise 9 in the Polymorphism chapter to use an ArrayList to hold the Rodents and an Iterator to move through the sequence of Rodents. 
  Exercise 11: (2) Write a method that uses an Iterator to step through a Collection and print the toString( ) of each object in the container. Fill all the different types of Collections with objects and apply your method to each container. 
ListIterator
  The ListIterator is a more powerful subtype of Iterator that is produced only by List classes. While Iterator can only move forward, ListIterator is bidirectional. It can also produce the indexes of the next and previous elements relative to where the iterator is pointing in the list, and it can replace the last element that it visited using the set( ) method. You can produce a ListIterator that points to the beginning of the List by calling listIterator( ), and you can also create a ListIterator that starts out pointing to an index n in the list by calling listIterator(n). Here’s an example that demonstrates all these abilities: 
  The Pets.randomPet( ) method is used to replace all the Pet objects in the List from location 3 onward. 
  Exercise 12: (3) Create and populate a List<Integer>. Create a second List<Integer> of the same size as the first, and use ListIterators to read elements from the first List and insert them into the second in reverse order. (You may want to explore a number of different ways to solve this problem.) 
