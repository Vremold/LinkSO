  One of the problems of using pre-Java SE5 containers was that the compiler allowed you to insert an incorrect type into a container. For example, consider a container of Apple objects, using the basic workhorse container, ArrayList. For now, you can think of ArrayList as "an array that automatically expands itself." Using an ArrayList is straightforward: Create one, insert objects using add( ), and access them with get( ), using an index—just as you do with an array, but without the square brackets.2 ArrayList also has a method size( ) to let you know how many elements have been added, so that you don’t inadvertently index off the end and cause an error (by throwing a runtime exception; exceptions will be introduced in the chapter Error Handling with Exceptions). 
  In this example, Apples and Oranges are placed into the container, then pulled out. Normally, the Java compiler will give you a warning because the example does not use generics. Here, a special Java SE5 annotation is used to suppress the warning. Annotations start with an ‘@’ sign, and can take an argument; this one is @SuppressWarnings and the argument indicates that "unchecked" warnings only should be suppressed: 
  You’ll learn more about Java SE5 annotations in the Annotations chapter. 
  The classes Apple and Orange are distinct; they have nothing in common except that they are both Objects. (Remember that if you don’t explicitly say what class you’re inheriting from, you automatically inherit from Object.) Since ArrayList holds Objects, you can not only add Apple objects into this container using the ArrayList method add( ), but you can also add Orange objects without complaint at either compile time or run time. When you go to fetch out what you think are Apple objects using the ArrayList method get( ), you get back a reference to an Object that you must cast to an Apple. Then you need to surround the entire expression with parentheses to force the evaluation of the cast before calling the    using operator overloading. id( ) method for Apple; otherwise, you’ll get a syntax error. At run time, when you try to cast the Orange object to an Apple, you’ll get an error in the form of the aforementioned exception. In the Generics chapter, you’ll learn that creating classes using Java generics can be complex. However, applying predefined generic classes is usually straightforward. For example, to define an ArrayList intended to hold Apple objects, you say ArrayList<Apple> instead of just ArrayList. The angle brackets surround the type parameters (there may be more than one), which specify the type(s) that can be held by that instance of the container. With generics, you’re prevented, at compile time, from putting the wrong type of object into a container.3 Here’s the example again, using generics: 
  Now the compiler will prevent you from putting an Orange into apples, so it becomes a compile-time error rather than a runtime error. Also notice that the cast is no longer necessary when fetching items back out from the List. Since the List knows what type it holds, it does the cast for you when you call get( ). Thus, with generics you not only know that the compiler will check the type of object that you put into a container, but you also get cleaner syntax when using the objects in the container. The example also shows that, if you do not need to use the index of each element, you can use the foreach syntax to select each element in the List. You are not limited to putting the exact type of object into a container when you specify that type as a generic parameter. Upcasting works the same with generics as it does with other types: 
  Thus, you can add a subtype of Apple to a container that is specified to hold Apple objects. 
  The output is produced from the default toString( ) method of Object, which prints the class name followed by the unsigned hexadecimal representation of the hash code of the object (generated by the hashCode( ) method). You’ll learn about hash codes in detail in Containers in Depth. 
  Exercise 1: (2) Create a new class called Gerbil with an int gerbilNumber that’s initialized in the constructor. Give it a method called hop( ) that displays which gerbil number this is, and that it’s hopping. Create an ArrayList and add Gerbil objects to the List. Now use the get( ) method to move through the List and call hop( ) for each Gerbil. 
