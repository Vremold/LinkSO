  You must use Arrays.toString( ) to produce a printable representation of an array, but the containers print nicely without any help. Here’s an example that also introduces you to the basic Java containers: 
  This shows the two primary categories in the Java container library. The distinction is based on the number of items that are held in each "slot" in the container. The Collection category only holds one item in each slot. It includes the List, which holds a group of items in a specified sequence, the Set, which only allows the addition of one identical item, and the Queue, which only allows you to insert objects at one "end" of the container and remove objects from the other "end" (for the purposes of this example, this is just another way of looking at a sequence and so it is not shown). A Map holds two objects, a key and an associated value, in each slot. 
  In the output, you can see that the default printing behavior (provided via each container’s toString( ) method) produces reasonably readable results. A Collection is printed surrounded by square brackets, with each element separated by a comma. A Map is surrounded by curly braces, with each key and value associated with an equal sign (keys on the left, values on the right). 
  The first fill( ) method works with all types of Collection, each of which implements the add( ) method to include new elements. 
  ArrayList and LinkedList are both types of List, and you can see from the output that they both hold elements in the same order in which they are inserted. The difference between the two is not only performance for certain types of operations, but also that a LinkedList contains more operations than an ArrayList. These will be explored more fully later in this chapter. 
  HashSet, TreeSet and LinkedHashSet are types of Set. The output shows that a Set will only hold one of each identical item, but it also shows that the different Set implementations store the elements differently. The HashSet stores elements using a rather complex approach that will be explored in the Containers in Depth chapter—all you need to know at this point is that this technique is the fastest way to retrieve elements, and as a result the storage order can seem nonsensical (often, you only care whether something is a member of the Set, not the order in which it appears). If storage order is important, you can use a TreeSet, which keeps the objects in ascending comparison order, or a LinkedHashSet, which keeps the objects in the order in which they were added. 
  A Map (also called an associative array) allows you to look up an object using a key, like a simple database. The associated object is called a value. If you have a Map that associates states with their capitals and you want to know the capital of Ohio, you look it up using "Ohio" as the key—almost as if you were indexing into an array. Because of this behavior, a Map only accepts one of each key. 
  Map.put(key, value) adds a value (the thing you want) and associates it with a key (the thing you look it up with). Map.get(key) produces the value associated with that key. The above example only adds key-value pairs, and does not perform lookups. That will be shown later. 
  Notice that you don’t have to specify (or think about) the size of the Map because it resizes itself automatically. Also, Maps know how to print themselves, showing the association with keys and values. The order that the keys and values are held inside the Map is not the insertion order because the HashMap implementation uses a very fast algorithm that controls the order. 
  The example uses the three basic flavors of Map: HashMap, TreeMap and LinkedHashMap. Like HashSet, HashMap provides the fastest lookup technique, and also doesn’t hold its elements in any apparent order. A TreeMap keeps the keys sorted by ascending comparison order, and a LinkedHashMap keeps the keys in insertion order while retaining the lookup speed of the HashMap. 
  Exercise 4: (3) Create a generator class that produces character names (as String objects) from your favorite movie (you can use Snow White or Star Wars as a fallback) each time you call next( ), and loops around to the beginning of the character list when it runs out of names. Use this generator to fill an array, an ArrayList, a LinkedList, a HashSet, a LinkedHashSet, and a TreeSet, then print each container. 
