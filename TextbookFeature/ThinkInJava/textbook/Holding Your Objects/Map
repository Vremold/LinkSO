  The ability to map objects to other objects can be an immensely powerful way to solve programming problems. For example, consider a program to examine the randomness of Java’s Random class. Ideally, Random would produce a perfect distribution of numbers, but to test this you need to generate many random numbers and count the ones that fall in the various ranges. A Map easily solves the problem; in this case, the key is the number produced by Random, and the value is the number of times that number appears: 
  In main( ), autoboxing converts the randomly generated int into an Integer reference that can be used with the HashMap (you can’t use primitives with containers). The get( ) method returns null if the key is not already in the container (which means that this is the first time the number has been found). Otherwise, the get( ) method produces the associated Integer value for the key, which is incremented (again, autoboxing simplifies the expression but there are actually conversions to and from Integer taking place). 
  Here’s an example that allows you to use a String description to look up Pet objects. It also shows how you can test a Map to see if it contains a key or a value with containsKey( ) and containsValue( ): 
  Maps, like arrays and Collections, can easily be expanded to multiple dimensions; you simply make a Map whose values are Maps (and the values of those Maps can be other containers, even other Maps). Thus, it’s quite easy to combine containers to quickly produce powerful data structures. For example, suppose you are keeping track of people who have multiple pets—all you need is a Map<Person, List<Pet>>: 
  A Map can return a Set of its keys, a Collection of its values, or a Set of its pairs. The keySet( ) method produces a Set of all the keys in petPeople, which is used in the foreach statement to iterate through the Map. 
  Exercise 17: (2) Take the Gerbil class in Exercise 1 and put it into a Map instead, associating each Gerbil’s name (e.g. "Fuzzy" or "Spot") as a String (the key) for each Gerbil (the value) you put in the table. Get an Iterator for the keySet( ) and use it to move through the Map, looking up the Gerbil for each key and printing out the key and telling the Gerbil to hop( ). 
  Exercise 18: (3) Fill a HashMap with key-value pairs. Print the results to show ordering by hash code. Extract the pairs, sort by key, and place the result into a LinkedHashMap. Show that the insertion order is maintained. 
  Exercise 19: (2) Repeat the previous exercise with a HashSet and LinkedHashSet. 
  Exercise 20: (3) Modify Exercise 16 so that you keep a count of the occurrence of each vowel. 
  Exercise 21: (3) Using a Map<String,Integer>, follow the form of UniqueWords.java to create a program that counts the occurrence of words in a file. Sort the results using Collections.sort( ) with a second argument of String.CASE_INSENSITIVE_ORDER (to produce an alphabetic sort), and display the result. 
  Exercise 22: (5) Modify the previous exercise so that it uses a class containing a String and a count field to store each different word, and a Set of these objects to maintain the list of words. 
  Exercise 23: (4) Starting with Statistics.java, create a program that runs the test repeatedly and looks to see if any one number tends to appear more than the others in the results. 
  Exercise 24: (2) Fill a LinkedHashMap with String keys and objects of your choice. Now extract the pairs, sort them based on the keys, and reinsert them into the Map. 
  Exercise 25: (3) Create a Map<String,ArrayList<Integer>>. Use net.mindview.TextFile to open a text file and read it in a word at a time (use "\\W+" as the second argument to the TextFile constructor). Count the words as you read them in, and for each word in the file, record in the ArrayList<Integer> the word count associated with that word—this is, in effect, the location in the file where that word was found. 
  Exercise 26: (4) Take the resulting Map from the previous exercise and re-create the order of the words as they appeared in the original file. 
