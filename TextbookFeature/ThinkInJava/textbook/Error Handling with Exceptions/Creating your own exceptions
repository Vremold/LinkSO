  You’re not stuck using the existing Java exceptions. The Java exception hierarchy can’t foresee all the errors you might want to report, so you can create your own to denote a special problem that your library might encounter. 
  To create your own exception class, you must inherit from an existing exception class, preferably one that is close in meaning to your new exception (although this is often not possible). The most trivial way to create a new type of exception is just to let the compiler create the default constructor for you, so it requires almost no code at all: 
  The compiler creates a default constructor, which automatically (and invisibly) calls the base- class default constructor. Of course, in this case you don’t get a SimpleException(String) constructor, but in practice that isn’t used much. As you’ll see, the most important thing about an exception is the class name, so most of the time an exception like the one shown here is satisfactory. 
  Here, the result is printed to the console, where it is automatically captured and tested with this book’s output-display system. However, you may want to send error output to the standard error stream by writing to System.err. This is usually a better place to send error information than System.out, which may be redirected. If you send output to System.err, it will not be redirected along with System.out so the user is more likely to notice it. You can also create an exception class that has a constructor with a String argument: 
  The added code is small: two constructors that define the way MyException is created. In the second constructor, the base-class constructor with a String argument is explicitly invoked by using the super keyword. 
  In the handlers, one of the Throwable (from which Exception is inherited) methods is called: printStackTrace( ). As you can see from the output, this produces information    about the sequence of methods that were called to get to the point where the exception happened. Here, the information is sent to System.out, and automatically captured and displayed in the output. However, if you call the default version: 
  e.printStackTrace(); 
  the information goes to the standard error stream. 
  Exercise 1: (2) Create a class with a main( ) that throws an object of class Exception inside a try block. Give the constructor for Exception a String argument. Catch the exception inside a catch clause and print the String argument. Add a finally clause and print a message to prove you were there. 
  Exercise 2: (1) Define an object reference and initialize it to null. Try to call a method through this reference. Now wrap the code in a try-catch clause to catch the exception. 
  Exercise 3: (1) Write code to generate and catch an ArraylndexOutOfBoundsException. 
  Exercise 4: (2) Create your own exception class using the extends keyword. Write a constructor for this class that takes a String argument and stores it inside the object with a String reference. Write a method that displays the stored String. Create a try-catch clause to exercise your new exception. 
  Exercise 5: (3) Create your own resumption-like behavior using a while loop that repeats until an exception is no longer thrown. 
Exceptions and logging
  You may also want to log the output using the java.util.logging facility. Although full details of logging are introduced in the supplement at http://MindView.net/Books/BetterJava, basic logging is straightforward enough to be used here. 
  The static Logger.getLogger( ) method creates a Logger object associated with the String argument (usually the name of the package and class that the errors are about) which sends its output to System.err. The easiest way to write to a Logger is just to call the method associated with the level of logging message; here, severe( ) is used. To produce the String for the logging message, we’d like to have the stack trace where the exception is thrown, but printStackTrace( ) doesn’t produce a String by default. To get a String, we need to use the overloaded printStackTrace( ) that takes a java.io.PrintWriter object as an argument (all of this will be fully explained in the I/O chapter). If we hand the Print Writer constructor a java.io.StringWriter object, the output can be extracted as a String by calling toString( ). 
  Although the approach used by LoggingException is very convenient because it builds all the logging infrastructure into the exception itself, and thus it works automatically without client programmer intervention, it’s more common that you will be catching and logging someone else’s exception, so you must generate the log message in the exception handler: 
  The process of creating your own exceptions can be taken further. You can add extra constructors and members: 
  A field x has been added, along with a method that reads that value and an additional constructor that sets it. In addition, Throwable.getMessage( ) has been overridden to produce a more interesting detail message. getMessage( ) is something like toString( ) for exception classes. 
  Since an exception is just another kind of object, you can continue this process of embellishing the power of your exception classes. Keep in mind, however, that all this dressing-up might be lost on the client programmers using your packages, since they might simply look for the exception to be thrown and nothing more. (That’s the way most of the Java library exceptions are used.)  Exercise 6: (1) Create two exception classes, each of which performs its own logging automatically. Demonstrate that these work. 
  Exercise 7: (1) Modify Exercise 3 so that the catch clause logs the results. 
