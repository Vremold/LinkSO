  It’s important that you always ask, "If an exception occurs, will everything be properly cleaned up?" Most of the time you’re fairly safe, but with constructors there’s a problem. The constructor puts the object into a safe starting state, but it might perform some operation— such as opening a filethat doesn’t get cleaned up until the user is finished with the object and calls a special cleanup method. If you throw an exception from inside a constructor, these cleanup behaviors might not occur properly. This means that you must be especially diligent while you write your constructor. 
  You might think that finally is the solution. But it’s not quite that simple, because finally performs the cleanup code every time. If a constructor fails partway through its execution, it might not have successfully created some part of the object that will be cleaned up in the finally clause. 
  In the following example, a class called InputFile is created that opens a file and allows you to read it one line at a time. It uses the classes FileReader and BufferedReader from the Java standard I/O library that will be discussed in the I/O chapter. These classes are simple enough that you probably won’t have any trouble understanding their basic use: 
  The constructor for InputFile takes a String argument, which is the name of the file you want to open. Inside a try block, it creates a FileReader using the file name. A FileReader isn’t particularly useful until you use it to create a BufferedReader. One of the benefits of InputFile is that it combines these two actions. 
  If the FileReader constructor is unsuccessful, it throws a FileNotFoundException. This is the one case in which you don’t want to close the file, because it wasn’t successfully opened. Any other catch clauses must close the file because it was opened by the time those catch clauses are entered. (Of course, this gets trickier if more than one method can throw a FileNotFoundException. In that case, you’ll usually have to break things into several try blocks.) The close( ) method might throw an exception so it is tried and caught even though it’s within the block of another catch clause—it’s just another pair of curly braces to the Java compiler. After performing local operations, the exception is rethrown, which is appropriate because this constructor failed, and you don’t want the calling method to assume that the object has been properly created and is valid. 
  In this example, the finally clause is definitely not the place to close( ) the file, since that would close it every time the constructor completed. We want the file to be open for the useful lifetime of the InputFile object. 
  The getLine( ) method returns a String containing the next line in the file. It calls readLine( ), which can throw an exception, but that exception is caught so that getLine( ) doesn’t throw any exceptions. One of the design issues with exceptions is whether to handle an exception completely at this level, to handle it partially and pass the same exception (or a different one) on, or whether to simply pass it on. Passing it on, when appropriate, can certainly simplify coding. In this situation, the getLine( ) method converts the exception to a RuntimeException to indicate a programming error. 
  The dispose( ) method must be called by the user when the InputFile object is no longer needed. This will release the system resources (such as file handles) that are used by the BufferedReader and/or FileReader objects. You don’t want to do this until you’re finished with the InputFile object. You might think of putting such functionality into a finalize( ) method, but as mentioned in the Initialization & Cleanup chapter, you can’t always be sure that finalize( ) will be called (even if you can be sure that it will be called, you don’t know when). This is one of the downsides to Java: All cleanupother than memory cleanup—doesn’t happen automatically, so you must inform the client programmers that they are responsible. 
  The safest way to use a class which might throw an exception during construction and which requires cleanup is to use nested try blocks: 
  Look carefully at the logic here: The construction of the InputFile object is effectively in its own try block. If that construction fails, the outer catch clause is entered and dispose( ) is not called. However, if construction succeeds then you want to make sure the object is cleaned up, so immediately after construction you create a new try block. The finally that performs cleanup is associated with the inner try block; this way, the finally clause is not executed if construction fails, and it is always executed if construction succeeds. 
  This general cleanup idiom should still be used if the constructor throws no exceptions. The basic rule is: Right after you create an object that requires cleanup, begin a try-finally: 
  In main( ), section 1 is fairly straightforward: You follow a disposable object with a try- finally. If the object construction cannot fail, no catch is necessary. In section 2, you can see that objects with constructors that cannot fail can be grouped together for both construction and cleanup. 
  Section 3 shows how to deal with objects whose constructors can fail and which need cleanup. To properly handle this situation, things get messy, because you must surround each construction with its own try-catch, and each object construction must be followed by a try-finally to guarantee cleanup. 
  The messiness of exception handling in this case is a strong argument for creating constructors that cannot fail, although this is not always possible. 
  Note that if dispose( ) can throw an exception you might need additional try blocks. Basically, you must think carefully about all the possibilities and guard for each one. 
  Exercise 21: (2) Demonstrate that a derived-class constructor cannot catch exceptions thrown by its base-class constructor. 
  Exercise 22: (2) Create a class called FailingConstructor with a constructor that might fail partway through the construction process and throw an exception. In main( ), write code that properly guards against this failure. 
  Exercise 23: (4) Add a class with a dispose( ) method to the previous exercise. Modify FailingConstructor so that the constructor creates one of these disposable objects as a member object, after which the constructor might throw an exception, after which it creates a second disposable member object. Write code to properly guard against failure, and in main( ) verify that all possible failure situations are covered. 
  Exercise 24: (3) Add a dispose( ) method to the FailingConstructor class and write code to properly use this class. 
