  When an exception is thrown, the exception-handling system looks through the "nearest" handlers in the order they are written. When it finds a match, the exception is considered handled, and no further searching occurs. 
  Matching an exception doesn’t require a perfect match between the exception and its handler. A derived-class object will match a handler for the base class, as shown in this example: 
  The Sneeze exception will be caught by the first catch clause that it matches, which is the first one, of course. However, if you remove the first catch clause, leaving only the catch clause for Annoyance, the code still works because it’s catching the base class of Sneeze. Put another way, catch(Annoyance a) will catch an Annoyance or any class derived from it. This is useful because if you decide to add more derived exceptions to a method, then the client programmer’s code will not need changing as long as the client catches the base- class exceptions. 
  If you try to "mask" the derived-class exceptions by putting the base-class catch clause first, like this: 
  try { throw new Sneeze(); } catch(Annoyance a) { // ... } catch(Sneeze s) { // ... } 
  the compiler will give you an error message, since it sees that the Sneeze catch clause can never be reached. 
  Exercise 25: (2) Create a three-level hierarchy of exceptions. Now create a base-class A with a method that throws an exception at the base of your hierarchy. Inherit B from A and override the method so it throws an exception at level two of your hierarchy. Repeat by inheriting class C from B. In main( ), create a C and upcast it to A, then call the method. 
