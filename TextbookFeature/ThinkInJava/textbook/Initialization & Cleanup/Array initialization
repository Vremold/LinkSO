  An array is simply a sequence of either objects or primitives that are all the same type and are packaged together under one identifier name. Arrays are defined and used with the square- brackets indexing operator [ ]. To define an array reference, you simply follow your type name with empty square brackets: 
  int[] a1; 
  You can also put the square brackets after the identifier to produce exactly the same meaning: 
  int a1[]; 
  This conforms to expectations from C and C++ programmers. The former style, however, is probably a more sensible syntax, since it says that the type is “an int array.” That style will be used in this book. 
  The compiler doesn’t allow you to tell it how big the array is. This brings us back to that issue of “references.” All that you have at this point is a reference to an array (you’ve allocated enough storage for that reference), and there’s been no space allocated for the array object itself. To create storage for the array, you must write an initialization expression. For arrays, initialization can appear anywhere in your code, but you can also use a special kind of initialization expression that must occur at the point where the array is created. This special initialization is a set of values surrounded by curly braces. The storage allocation (the equivalent of using new) is taken care of by the compiler in this case. For example: 
  int[] a1 = { 1, 2, 3, 4, 5 }; 
  So why would you ever define an array reference without an array? 
  int[] a2; 
  Well, it’s possible to assign one array to another in Java, so you can say: 
  a2 = a1; 
  What you’re really doing is copying a reference, as demonstrated here: 
  You can see that a1 is given an initialization value but a2 is not; a2 is assigned later—in this case, to another array. Since a2 and a1 are then aliased to the same array, the changes made via a2 are seen in a1. 
  All arrays have an intrinsic member (whether they’re arrays of objects or arrays of primitives) that you can query—but not change—to tell you how many elements there are in the array. This member is length. Since arrays in Java, like C and C++, start counting from element zero, the largest element you can index is length - 1. If you go out of bounds, C and C++ quietly accept this and allow you to stomp all over your memory, which is the source of many infamous bugs. However, Java protects you against such problems by causing a runtime error (an exception) if you step out of bounds.5  What if you don’t know how many elements you’re going to need in your array while you’re writing the program? You simply use new to create the elements in the array. Here, new works even though it’s creating an array of primitives (new won’t create a non-array primitive): 
  The size of the array is chosen at random by using the Random.nextInt( ) method, which produces a value between zero and that of its argument. Because of the randomness, it’s clear   accesses might be a source of inefficiency in your program if they occur at a critical juncture. For Internet security and programmer productivity, the Java designers saw that this was a worthwhile trade-off. Although you may be tempted to write code that you think might make array accesses more efficient, this is a waste of time because automatic compile-time and runtime optimizations will speed array accesses. that array creation is actually happening at run time. In addition, the output of this program shows that array elements of primitive types are automatically initialized to “empty” values. (For numerics and char, this is zero, and for boolean, it’s false.) 
  The Arrays.toString( ) method, which is part of the standard java.util library, produces a printable version of a one-dimensional array. 
  Of course, in this case the array could also have been defined and initialized in the same statement: 
  int[] a = new int[rand.nextInt(20)]; 
  This is the preferred way to do it, if you can. 
  If you create a non-primitive array, you create an array of references. Consider the wrapper type Integer, which is a class and not a primitive: 
  Here, even after new is called to create the array: 
  Integer[] a = new Integer[rand.nextInt(20)]; 
  it’s only an array of references, and the initialization is not complete until the reference itself is initialized by creating a new Integer object (via autoboxing, in this case): 
  a[i] = rand.nextInt(500); 
  If you forget to create the object, however, you’ll get an exception at run time when you try to use the empty array location. 
  It’s also possible to initialize arrays of objects by using the curly brace-enclosed list. There are two forms: 
  In both cases, the final comma in the list of initializers is optional. (This feature makes for easier maintenance of long lists.)  Although the first form is useful, it’s more limited because it can only be used at the point where the array is defined. You can use the second and third forms anywhere, even inside a method call. For example, you could create an array of String objects to pass to the main( ) of another method, to provide alternate command-line arguments to that main( ): 
  The array created for the argument of Other.main( ) is created at the point of the method call, so you can even provide alternate arguments at the time of the call. 
  Exercise 16: (1) Create an array of String objects and assign a String to each element. Print the array by using a for loop. 
  Exercise 17: (2) Create a class with a constructor that takes a String argument. During construction, print the argument. Create an array of object references to this class, but don’t actually create objects to assign into the array. When you run the program, notice whether the initialization messages from the constructor calls are printed. 
  Exercise 18: (1) Complete the previous exercise by creating objects to attach to the array of references. 
  
Variable argument lists
  The second form provides a convenient syntax to create and call methods that can produce an effect similar to C’s variable argument lists (known as “varargs” in C). These can include unknown quantities of arguments as well as unknown types. Since all classes are ultimately inherited from the common root class Object (a subject you will learn more about as this book progresses), you can create a method that takes an array of Object and call it like this: 
  You can see that print( ) takes an array of Object, then steps through the array using the foreach syntax and prints each one. The standard Java library classes produce sensible output, but the objects of the classes created here print the class name, followed by an ‘@’ sign and hexadecimal digits. Thus, the default behavior (if you don’t define a toString( ) method for your class, which will be described later in the book) is to print the class name and the address of the object. 
  You may see pre-Java SE5 code written like the above in order to produce variable argument lists. In Java SE5, however, this long-requested feature was finally added, so you can now use ellipses to define a variable argument list, as you can see in printArray( ): 
  With varargs, you no longer have to explicitly write out the array syntax—the compiler will actually fill it in for you when you specify varargs. You’re still getting an array, which is why print( ) is able to use foreach to iterate through the array. However, it’s more than just an automatic conversion from a list of elements to an array. Notice the second-t0-last line in the program, where an array of Integer (created using autoboxing) is cast to an Object array (to remove a compiler warning) and passed to printArray( ). Clearly, the compiler sees that this is already an array and performs no conversion on it. So if you have a group of items you can pass them in as a list, and if you already have an array it will accept that as the variable argument list. 
  The last line of the program shows that it’s possible to pass zero arguments to a vararg list. This is helpful when you have optional trailing arguments: 
  This also shows how you can use varargs with a specified type other than Object. Here, all the varargs must be String objects. It’s possible to use any type of argument in varargs, including a primitive type. The following example also shows that the vararg list becomes an array, and if there’s nothing in the list it’s an array of size zero: 
  The getClass( ) method is part of Object, and will be explored fully in the Type Information chapter. It produces the class of an object, and when you print this class, you see an encoded string representing the class type. The leading ‘[‘ indicates that this is an array of the type that follows. The ‘I’ is for a primitive int; to double-check, I created an array of int in the last line and printed its type. This verifies that using varargs does not depend on autoboxing, but that it actually uses the primitive types. 
  Varargs do work in harmony with autoboxing, however. For example: 
  Notice that you can mix the types together in a single argument list, and autoboxing selectively promotes the int arguments to Integer. 
  Varargs complicate the process of overloading, although it seems safe enough at first: 
  In each case, the compiler is using autoboxing to match the overloaded method, and it calls the most specifically matching method. 
  But when you call f( ) without arguments, it has no way of knowing which one to call. Although this error is understandable, it will probably surprise the client programmer. 
  You might try solving the problem by adding a non-vararg argument to one of the methods: 
  The {CompileTimeError} comment tag excludes the file from this book’s Ant build. If you compile it by hand you’ll see the error message: 
  reference to f is ambiguous, both method f(float,java.lang.Character...) in OverloadingVarargs2 and method f(java.lang.Character...) in OverloadingVarargs2 match  If you give both methods a non-vararg argument, it works: 
  You should generally only use a variable argument list on one version of an overloaded method. Or consider not doing it at all. 
  Exercise 19: (2) Write a method that takes a vararg String array. Verify that you can pass either a comma-separated list of Strings or a String[] into this method. 
  Exercise 20: (1) Create a main( ) that uses varargs instead of the ordinary main( ) syntax. Print all the elements in the resulting args array. Test it with various numbers of command-line arguments. 
