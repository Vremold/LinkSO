  In Java, the access specifiers can also be used to determine which classes within a library will be available to the users of that library. If you want a class to be available to a client programmer, you use the public keyword on the entire class definition. This controls whether the client programmer can even create an object of the class. 
  To control the access of a class, the specifier must appear before the keyword class. Thus you can say: 
  public class Widget {  Now if the name of your library is access, any client programmer can access Widget by saying 
  import access.Widget; 
  or  import access.*; 
  However, there’s an extra set of constraints: 
  1. There can be only one public class per compilation unit (file). The idea is that each compilation unit has a single public interface represented by that public class. It can have as many supporting package-access classes as you want. If you have more than one public class inside a compilation unit, the compiler will give you an error message. 
  2. The name of the public class must exactly match the name of the file containing the compilation unit, including capitalization. So for Widget, the name of the file must be Widget.java, not widget.java or WIDGET.java. Again, you’ll get a compile-time error if they don’t agree. 
  3. It is possible, though not typical, to have a compilation unit with no public class at all. In this case, you can name the file whatever you like (although naming it arbitrarily will be confusing to people reading and maintaining the code). 
  What if you’ve got a class inside access that you’re only using to accomplish the tasks performed by Widget or some other public class in access? You don’t want to go to the bother of creating documentation for the client programmer, and you think that sometime later you might want to completely change things and rip out your class altogether, substituting a different one. To give you this flexibility, you need to ensure that no client programmers become dependent on your particular implementation details hidden inside access. To accomplish this, you just leave the public keyword off the class, in which case it has package access. (That class can be used only within that package.)  Exercise 7: (1) Create the library according to the code fragments describing access and Widget. Create a Widget in a class that is not part of the access package. 
  When you create a package-access class, it still makes sense to make the fields of the class private—you should always make fields as private as possible—but it’s generally reasonable to give the methods the same access as the class (package access). Since a package-access  class is usually used only within the package, you only need to make the methods of such a class public if you’re forced to, and in those cases, the compiler will tell you. 
  Note that a class cannot be private (that would make it inaccessible to anyone but the class) or protected.6 So you have only two choices for class access: package access or public. If you don’t want anyone else to have access to that class, you can make all the constructors private, thereby preventing anyone but you, inside a static member of the class, from creating an object of that class. Here’s an example: 
  Up to now, most of the methods have been returning either void or a primitive type, so the definition: 
  public static Soup1 makeSoup() { return new Soup1(); } 
  might look a little confusing at first. The word Soup1 before the method name (makeSoup) tells what the method returns. So far in this book, this has usually been void, which means it returns nothing. But you can also return a reference to an object, which is what happens here. This method returns a reference to an object of class Soup1. 
  Classes chapter. The classes Soup1 and Soup2 show how to prevent direct creation of a class by making all the constructors private. Remember that if you don’t explicitly create at least one constructor, the default constructor (a constructor with no arguments) will be created for you. By writing the default constructor, it won’t be created automatically. By making it private, no one can create an object of that class. But now how does anyone use this class? The preceding example shows two options. In Soup1, a static method is created that creates a new Soup1 and returns a reference to it. This can be useful if you want to do some extra operations on the Soup1 before returning it, or if you want to keep count of how many Soup1 objects to create (perhaps to restrict their population). 
  Soup2 uses what’s called a design pattern, which is covered in Thinking in Patterns (with Java) at www.MindView.net. This particular pattern is called a Singleton, because it allows only a single object to ever be created. The object of class Soup2 is created as a static private member of Soup2, so there’s one and only one, and you can’t get at it except through the public method access( ). 
  As previously mentioned, if you don’t put an access specifier for class access, it defaults to package access. This means that an object of that class can be created by any other class in the package, but not outside the package. (Remember, all the files within the same directory that don’t have explicit package declarations are implicitly part of the default package for that directory.) However, if a static member of that class is public, the client programmer can still access that static member even though they cannot create an object of that class. 
  Exercise 8: (4) Following the form of the example Lunch.java, create a class called ConnectionManager that manages a fixed array of Connection objects. The client programmer must not be able to explicitly create Connection objects, but can only get them via a static method in ConnectionManager. When the ConnectionManager runs out of objects, it returns a null reference. Test the classes in main( ). 
  Exercise 9: (2) Create the following file in the access/local directory (presumably in your CLASSPATH): 
  // access/local/PackagedClass.java package access.local; 
  class PackagedClass { public PackagedClass() { System.out.println("Creating a packaged class"); } } 
  Then create the following file in a directory other than access/local: 
  // access/foreign/Foreign.java package access.foreign; import access.local.*; 
  public class Foreign { public static void main(String[] args) { PackagedClass pc = new PackagedClass(); } } 
  Explain why the compiler generates an error. Would making the Foreign class part of the access.local package change anything? 
