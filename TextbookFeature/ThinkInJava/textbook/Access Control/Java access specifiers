  The Java access specifiers public, protected, and private are placed in front of each definition for each member in your class, whether it’s a field or a method. Each access specifier only controls the access for that particular definition. 
  If you don’t provide an access specifier, it means “package access.” So one way or another, everything has some kind of access control. In the following sections, you’ll learn about the various types of access. 
Package access
  All the examples before this chapter used no access specifiers. The default access has no keyword, but it is commonly referred to as package access (and sometimes “friendly”). It means that all the other classes in the current package have access to that member, but to all the classes outside of this package, the member appears to be private. Since a compilation unit—a file—can belong only to a single package, all the classes within a single compilation unit are automatically available to each other via package access. 
  Package access allows you to group related classes together in a package so that they can easily interact with each other. When you put classes together in a package, thus granting mutual access to their package-access members, you “own” the code in that package. It makes sense that only code that you own should have package access to other code that you own. You could say that package access gives a meaning or a reason for grouping classes together in a package. In many languages the way you organize your definitions in files can be arbitrary, but in Java you’re compelled to organize them in a sensible fashion. In addition, you’ll probably want to exclude classes that shouldn’t have access to the classes being defined in the current package. 
  The class controls the code that has access to its members. Code from another package can’t just come around and say, “Hi, I’m a friend of Bob’s!” and expect to be shown the protected, package-access, and private members of Bob. The only way to grant access to a member is to: 
  1. Make the member public. Then everybody, everywhere, can access it. 
  2. Give the member package access by leaving off any access specifier, and put the other classes in the same package. Then the other classes in that package can access the member. 
  3. As you’ll see in the Reusing Classes chapter, when inheritance is introduced, an inherited class can access a protected member as well as a public member (but not private members). It can access package-access members only if the two classes are in the same package. But don’t worry about inheritance and protected right now. 
  4. Provide “accessor/mutator” methods (also known as “get/set” methods) that read and change the value. This is the most civilized approach in terms of OOP, and it is fundamental to JavaBeans, as you’ll see in the Graphical User Interfaces chapter. 
public: interface access
  When you use the public keyword, it means that the member declaration that immediately follows public is available to everyone, in particular to the client programmer who uses the library. Suppose you define a package dessert containing the following compilation unit: 
  Remember, the class file produced by Cookie.java must reside in a subdirectory called dessert, in a directory under access (indicating the Access Control chapter of this book) that must be under one of the CLASSPATH directories. Don’t make the mistake of thinking that Java will always look at the current directory as one of the starting points for searching. If you don’t have a ‘.’ as one of the paths in your CLASSPATH, Java won’t look there. 
  Now if you create a program that uses Cookie: 
  you can create a Cookie object, since its constructor is public and the class is public. (We’ll look more at the concept of a public class later.) However, the bite( ) member is inaccessible inside Dinner.java since bite( ) provides access only within package dessert, so the compiler prevents you from using it. 
  The default package  You might be surprised to discover that the following code compiles, even though it would appear that it breaks the rules: 
  In a second file in the same directory: 
  You might initially view these as completely foreign files, and yet Cake is able to create a Pie object and call its f( ) method. (Note that you must have ‘.’ in your CLASSPATH in order for the files to compile.) You’d typically think that Pie and f( ) have package access and are therefore not available to Cake. They do have package access—that part is correct. The reason that they are available in Cake.java is because they are in the same directory and have no explicit package name. Java treats files like this as implicitly part of the “default package” for that directory, and thus they provide package access to all the other files in that directory. 
private: you can’t touch that!
  The private keyword means that no one can access that member except the class that contains that member, inside methods of that class. Other classes in the same package cannot access private members, so it’s as if you’re even insulating the class against yourself. On the other hand, it’s not unlikely that a package might be created by several people collaborating together, so private allows you to freely change that member without concern that it will affect another class in the same package. 
  The default package access often provides an adequate amount of hiding; remember, a packageaccess member is inaccessible to the client programmer using the class. This is nice, since the default access is the one that you normally use (and the one that you’ll get if you forget to add any access control). Thus, you’ll typically think about access for the members that you explicitly want to make public for the client programmer, and as a result, you might initially think that you won’t use the private keyword very often, since it’s tolerable to get away without it. However, it turns out that the consistent use of private is very important, especially where multithreading is concerned. (As you’ll see in the Concurrency chapter.)  Here’s an example of the use of private: 
  This shows an example in which private comes in handy: You might want to control how an object is created and prevent someone from directly accessing a particular constructor (or all of them). In the preceding example, you cannot create a Sundae object via its constructor; instead, you must call the makeASundae( ) method to do it for you.4  Any method that you’re certain is only a “helper” method for that class can be made private, to ensure that you don’t accidentally use it elsewhere in the package and thus prohibit yourself from changing or removing the method. Making a method private guarantees that you retain this option. 
  The same is true for a private field inside a class. Unless you must expose the underlying implementation (which is less likely than you might think), you should make all fields private. However, just because a reference to an object is private inside a class doesn’t mean that some other object can’t have a public reference to the same object. (See the online supplements for this book to learn about aliasing issues.) 
protected: inheritance access
  Understanding the protected access specifier requires a jump ahead. First, you should be aware that you don’t need to understand this section to continue through this book up through inheritance (the Reusing Classes chapter). But for completeness, here is a brief description and example using protected. 
  The protected keyword deals with a concept called inheritance, which takes an existing class— which we refer to as the base class—and adds new members to that class without touching the existing class. You can also change the behavior of existing members of the class. To inherit from a class, you say that your new class extends an existing class, like this: 
  class Foo extends Bar {  The rest of the class definition looks the same. 
  If you create a new package and inherit from a class in another package, the only members you have access to are the public members of the original package. (Of course, if you perform the inheritance in the same package, you can manipulate all the members that have package access.) Sometimes the creator of the base class would like to take a particular member and grant access to derived classes but not the world in general. That’s what protected does. protected also gives package access—that is, other classes in the same package may access protected elements. 
  inheritance of this class. (A subject that will be introduced later.) If you refer back to the file Cookie.java, the following class cannot call the package-access member bite( ): 
  One of the interesting things about inheritance is that if a method bite( ) exists in class Cookie, then it also exists in any class inherited from Cookie. But since bite( ) has package access and is in a foreign package, it’s unavailable to us in this one. Of course, you could make it public, but then everyone would have access, and maybe that’s not what you want. If you change the class Cookie as follows: 
  now bite( ) becomes accessible to anyone inheriting from Cookie: 
  Note that, although bite( ) also has package access, it is not public. 
  Exercise 4: (2) Show that protected methods have package access but are not public. 
  Exercise 5: (2) Create a class with public, private, protected, and package-access fields and method members. Create an object of this class and see what kind of compiler messages you get when you try to access all the class members. Be aware that classes in the same directory are part of the “default” package. 
  Exercise 6: (1) Create a class with protected data. Create a second class in the same file with a method that manipulates the protected data in the first class. 
