  A package contains a group of classes, organized together under a single namespace. 
  For example, there’s a utility library that’s part of the standard Java distribution, organized under the namespace java.util. One of the classes in java.util is called ArrayList. One way to use an ArrayList is to specify the full name java.util.ArrayList. 
  This rapidly becomes tedious, so you’ll probably want to use the import keyword instead. If you want to import a single class, you can name that class in the import statement: 
  Now you can use ArrayList with no qualification. However, none of the other classes in java.util are available. To import everything, you simply use the ‘*’ as you’ve been seeing in the rest of the examples in this book: 
  import java.util.*; 
  The reason for all this importing is to provide a mechanism to manage namespaces. The names of all your class members are insulated from each other. A method f( ) inside a class A will not clash with an f( ) that has the same signature in class B. But what about the class names? Suppose you create a Stack class that is installed on a machine that already has a Stack class that’s written by someone else? This potential clashing of names is why it’s important to have complete control over the namespaces in Java, and to create a unique identifier combination for each class. 
  Most of the examples thus far in this book have existed in a single file and have been designed for local use, so they haven’t bothered with package names. These examples have actually been in packages: the “unnamed” or default package. This is certainly an option, and for simplicity’s sake this approach will be used whenever possible throughout the rest of this book. However, if you’re planning to create libraries or programs that are friendly to other Java programs on the same machine, you must think about preventing class name clashes. 
  When you create a source-code file for Java, it’s commonly called a compilation unit (sometimes a translation unit). Each compilation unit must have a name ending in .java, and inside the compilation unit there can be a public class that must have the same name as the file (including capitalization, but excluding the .java file name extension). There can be only one public class in each compilation unit; otherwise, the compiler will complain. If there are additional classes in that compilation unit, they are hidden from the world outside that package because they’re not public, and they comprise “support” classes for the main public class. 
  
Code organization
  When you compile a .java file, you get an output file for each class in the .java file. Each output file has the name of a class in the .java file, but with an extension of .class. Thus you can end up with quite a few .class files from a small number of .java files. If you’ve programmed with a compiled language, you might be used to the compiler spitting out an intermediate form (usually an “obj” file) that is then packaged together with others of its kind using a linker (to create an executable file) or a librarian (to create a library). That’s not how Java works. A working program is a bunch of .class files, which can be packaged and compressed into a Java ARchive (JAR) file (using Java’s jar archiver). The Java interpreter is responsible for finding, loading, and interpreting2 these files. 
  A library is a group of these class files. Each source file usually has a public class and any number of non-public classes, so there’s one public component for each source file. If you want to say that all these components (each in its own separate .java and .class files) belong together, that’s where the package keyword comes in. 
  If you use a package statement, it must appear as the first non-comment in the file. When you say: 
  package access; 
  you’re stating that this compilation unit is part of a library named access. Put another way, you’re saying that the public class name within this compilation unit is under the umbrella of the name access, and anyone who wants to use that name must either fully specify the name or use the import keyword in combination with access, using the choices given previously. (Note that the convention for Java package names is to use all lowercase letters, even for intermediate words.)  For example, suppose the name of the file is MyClass.java. This means there can be one and only one public class in that file, and the name of that class must be MyClass (including the capitalization): 
  Now, if someone wants to use MyClass or, for that matter, any of the other public classes in access, they must use the import keyword to make the name or names in access available. The alternative is to give the fully qualified name: 
  single executable file. The import keyword can make this much cleaner: 
  It’s worth keeping in mind that what the package and import keywords allow you to do, as a library designer, is to divide up the single global namespace so you won’t have clashing names, no matter how many people get on the Internet and start writing classes in Java. 
Creating unique package names
  You might observe that, since a package never really gets “packaged” into a single file, a package can be made up of many .class files, and things could get a bit cluttered. To prevent this, a logical thing to do is to place all the .class files for a particular package into a single directory; that is, use the hierarchical file structure of the operating system to your advantage. This is one way that Java references the problem of clutter; you’ll see the other way later when the jar utility is introduced. 
  Collecting the package files into a single subdirectory solves two other problems: creating unique package names, and finding those classes that might be buried in a directory structure someplace. This is accomplished by encoding the path of the location of the .class file into the name of the package. By convention, the first part of the package name is the reversed Internet domain name of the creator of the class. Since Internet domain names are guaranteed to be unique, if you follow this convention, your package name will be unique and you’ll never have a name clash. (That is, until you lose the domain name to someone else who starts writing Java code with the same path names as you did.) Of course, if you don’t have your own domain name, then you must fabricate an unlikely combination (such as your first and last name) to create unique package names. If you’ve decided to start publishing Java code, it’s worth the relatively small effort to get a domain name. 
  The second part of this trick is resolving the package name into a directory on your machine, so that when the Java program runs and it needs to load the .class file, it can locate the directory where the .class file resides. 
  The Java interpreter proceeds as follows. First, it finds the environment variable CLASSPATH3 (set via the operating system, and sometimes by the installation program that installs Java or a Java-based tool on your machine). CLASSPATH contains one or more directories that are used as roots in a search for .class files. Starting at that root, the interpreter will take the package name and replace each dot with a slash to generate a path name off of the CLASSPATH root (so package foo.bar.baz becomes foo\bar\baz or foo/bar/baz or possibly something else, depending on your operating system). This is then concatenated to the various entries in the CLASSPATH. That’s where it looks for the .class file with the name corresponding to the class you’re trying to create. (It also searches some standard directories relative to where the Java interpreter resides.)  To understand this, consider my domain name, which is MindView.net. By reversing this and making it all lowercase, net.mindview establishes my unique global name for my classes. (The com, edu, org, etc., extensions were formerly capitalized in Java packages, but this was changed in Java 2 so the entire package name is lowercase.) I can further subdivide 
  this by deciding that I want to create a library named simple, so I’ll end up with a package name: 
  package net.mindview.simple; 
  Now this package name can be used as an umbrella namespace for the following two files: 
  As mentioned before, the package statement must be the first non-comment code in the file. The second file looks much the same: 
  Both of these files are placed in the subdirectory on my system: 
  C:\DOC\JavaT\net\mindview\simple  (Notice that the first comment line in every file in this book establishes the directory location of that file in the source-code tree—this is used by the automatic code-extraction tool for this book.) 
  If you walk back through this path, you can see the package name net.mindview.simple, but what about the first portion of the path? That’s taken care of by the CLASSPATH environment variable, which is, on my machine: 
  CLASSPATH=.;D:\JAVA\LIB;C:\DOC\JavaT  You can see that the CLASSPATH can contain a number of alternative search paths. 
  There’s a variation when using JAR files, however. You must put the actual name of the JAR file in the classpath, not just the path where it’s located. So for a JAR named grape.jar your classpath would include: 
  CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar  Once the classpath is set up properly, the following file can be placed in any directory: 
  When the compiler encounters the import statement for the simple library, it begins searching at the directories specified by CLASSPATH, looking for subdirectory net/mindview/simple, then seeking the compiled files of the appropriate names (Vector.class for Vector, and List.class for List). Note that both the classes and the desired methods in Vector and List must be public. 
  Setting the CLASSPATH has been such a trial for beginning Java users (it was for me, when I started) that Sun made the JDK in later versions of Java a bit smarter. You’ll find that when you install it, even if you don’t set the CLASSPATH, you’ll be able to compile and run basic Java programs. To compile and run the source-code package for this book (available at www.MindView.net), however, you will need to add the base directory of the book’s code tree to your CLASSPATH. 
  Exercise 1: (1) Create a class in a package. Create an instance of your class outside of that package. 
  Collisions  What happens if two libraries are imported via ‘*’ and they include the same names? For example, suppose a program does this: 
  import net.mindview.simple.*; import java.util.*; 
  Since java.util.* also contains a Vector class, this causes a potential collision. However, as long as you don’t write the code that actually causes the collision, everything is OK—this is good, because otherwise you might end up doing a lot of typing to prevent collisions that would never happen. 
  The collision does occur if you now try to make a Vector: 
  Vector v = new Vector(); 
  Which Vector class does this refer to? The compiler can’t know, and the reader can’t know either. So the compiler complains and forces you to be explicit. If I want the standard Java Vector, for example, I must say: 
  java.util.Vector v = new java.util.Vector(); 
  Since this (along with the CLASSPATH) completely specifies the location of that Vector, there’s no need for the import java.util.* statement unless I’m using something else from java.util. 
  Alternatively, you can use the single-class import form to prevent clashes—as long as you don’t use both colliding names in the same program (in which case you must fall back to fully specifying the names). 
  Exercise 2: (1) Take the code fragments in this section and turn them into a program, and verify that collisions do in fact occur. 
A custom tool library
  With this knowledge, you can now create your own libraries of tools to reduce or eliminate duplicate code. Consider, for example, the alias we’ve been using for System.out.println( ), to reduce typing. This can be part of a class called Print so that you end up with a readable static import: 
  You can use the printing shorthand to print anything, either with a newline (print( )) or without a newline (printnb( )). 
  You can guess that the location of this file must be in a directory that starts at one of the CLASSPATH locations, then continues into net/mindview. After compiling, the static print( ) and printnb( ) methods can be used anywhere on your system with an import static statement: 
  A second component of this library can be the range( ) methods, introduced in the Controlling Execution chapter, that allow the use of the foreach syntax for simple integer sequences: 
  From now on, whenever you come up with a useful new utility, you can add it to your own library. You’ll see more components added to the net.mindview.util library throughout the book. 
Using imports to change behavior
  A feature that is missing from Java is C’s conditional compilation, which allows you to change a switch and get different behavior without changing any other code. The reason such a feature was left out of Java is probably because it is most often used in C to solve cross- platform issues: Different portions of the code are compiled depending on the target platform. Since Java is intended to be automatically cross-platform, such a feature should not be necessary. 
  However, there are other valuable uses for conditional compilation. A very common use is for debugging code. The debugging features are enabled during development and disabled in the shipping product. You can accomplish this by changing the package that’s imported in order to change the code used in your program from the debug version to the production version. This technique can be used for any kind of conditional code. 
  Exercise 3: (2) Create two packages: debug and debugoff, containing an identical class with a debug( ) method. The first version displays its String argument to the console, the  second does nothing. Use a static import line to import the class into a test program, and demonstrate the conditional compilation effect. 
Package caveat
  It’s worth remembering that anytime you create a package, you implicitly specify a directory structure when you give the package a name. The package must live in the directory indicated by its name, which must be a directory that is searchable starting from the CLASSPATH. Experimenting with the package keyword can be a bit frustrating at first, because unless you adhere to the package-name to directory-path rule, you’ll get a lot of mysterious runtime messages about not being able to find a particular class, even if that class is sitting there in the same directory. If you get a message like this, try commenting out the package statement, and if it runs, you’ll know where the problem lies. 
  Note that compiled code is often placed in a different directory than source code, but the path to the compiled code must still be found by the JVM using the CLASSPATH. 
