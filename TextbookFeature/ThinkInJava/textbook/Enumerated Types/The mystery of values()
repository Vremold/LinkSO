  As noted earlier, all enum classes are created for you by the compiler and extend the Enum class. However, if you look at Enum, you’ll see that there is no values( ) method, even though we’ve been using it. Are there any other "hidden" methods? We can write a small reflection program to find out: 
  So the answer is that values( ) is a static method that is added by the compiler. You can see that valueOf( ) is also added to Explore in the process of creating the enum. This is slightly confusing, because there’s also a valueOf( ) that is part of the Enum class, but that method has two arguments and the added method only has one. However, the use of the Set method here is only looking at method names, and not signatures, so after calling Explore.removeAll(Enum), the only thing that remains is [values]. 
  In the output, you can see that Explore has been made final by the compiler, so you cannot inherit from an enum. There’s also a static initialization clause, which as you’ll see later can be redefined. 
  Because of erasure (described in the Generics chapter), the decompiler does not have full information about Enum, so it shows the base class of Explore as a raw Enum rather than the actual Enum<Explore>. 
  Because values( ) is a static method inserted into the enum definition by the compiler, if you upcast an enum type to Enum, the values( ) method will not be available. Notice, however, that there is a getEnumConstants( ) method in Class, so even if values( ) is not part of the interface of Enum, you can still get the enum instances via the Class object: 
  Because getEnumConstants( ) is a method of Class, you can call it for a class that has no enumerations: 
  However, the method returns null, so you get an exception if you try to use the result. 
