  When you are dealing with multiple interacting types, a program can get particularly messy. For example, consider a system that parses and executes mathematical expressions. You want to say Number.plus(Number), Number.multiply(Number), etc., where Number is the base class for a family of numerical objects. But when you say a.plus(b), and you don’t know the exact type of either a or b, how can you get them to interact properly? 
  The answer starts with something you probably don’t think about: Java only performs single dispatching. That is, if you are performing an operation on more than one object whose type is unknown, Java can invoke the dynamic binding mechanism on only one of those types. This doesn’t solve the problem described here, so you end up detecting some types manually and effectively producing your own dynamic binding behavior. 
  The solution is called multiple dispatching. (In this case, there will be only two dispatches, which is referred to as double dispatching.) Polymorphism can only occur via method calls, so if you want double dispatching, there must be two method calls: the first to determine the first unknown type, and the second to determine the second unknown type. With multiple dispatching, you must have a virtual call for each of the types—if you are working with two different type hierarchies that are interacting, you’ll need a virtual call in each hierarchy. Generally, you’ll set up a configuration such that a single method call produces more than one virtual method call and thus services more than one type in the process. To get this effect, you need to work with more than one method: You’ll need a method call for each dispatch. The methods in the following example (which implements the "paper, scissors, rock" game, traditionally called RoShamBo) are called compete( ) and eval( ) and are both members of the same type. They produce one of three possible outcomes:4  //: enumerated/Outcome.java package enumerated; public enum Outcome { WIN, LOSE, DRAW } ///:~ 
  Item is the interface for the types that will be multiply dispatched. RoShamBo1.match( ) takes two Item objects and begins the doubledispatching process by calling the Item.compete( ) function. The virtual mechanism determines the type of a, so it wakes up inside the compete( ) function of a’s concrete type. The compete( ) function performs the second dispatch by calling eval( ) on the remaining type. Passing itself (this) as an argument to eval( ) produces a call to the overloaded eval( ) function, thus preserving the type information of the first dispatch. When the second dispatch is completed, you know the exact types of both Item objects. 
  It requires a lot of ceremony to set up multiple dispatching, but keep in mind that the benefit is the syntactic elegance achieved when making the callinstead of writing awkward code to determine the type of one or more objects during a call, you simply say, "You two! I don’t care what types you are, interact properly with each other!" Make sure this kind of elegance is important to you before embarking on multiple dispatching, however. 
Dispatching with enums
  Performing a straight translation of RoShamBo1.java into an enum-based solution is problematic because enum instances are not types, so the overloaded eval( ) methods won’t work—you can’t use enum instances as argument types. However, there are a number of different approaches to implementing multiple dispatching which benefit from enums. 
  One approach uses a constructor to initialize each e n um instance with a "row" of outcomes; taken together this produces a kind of lookup table: 
  Once both types have been determined in compete( ), the only action is the return of the resulting Outcome. However, you could also call another method, even (for example) via a Command object that was assigned in the constructor. 
  RoShamBo2.java is much smaller and more straightforward than the original example, and thus easier to keep track of. Notice that you’re still using two dispatches to determine the type of both objects. In RoShamBo1.java, both dispatches were performed using virtual method calls, but here, only the first dispatch uses a virtual method call. The second dispatch uses a switch, but is safe because the enum limits the choices in the switch statement. 
  The code that drives the enum has been separated out so that it can be used in the other examples. First, the Competitor interface defines a type that competes with another Competitor: 
  Then we define two static methods (static to avoid having to specify the parameter type explicitly). First, match( ) calls compete( ) for one Competitor vs. another, and you can see that in this case the type parameter only needs to be a Competitor<T>. But in play( ), the type parameter must be both an Enum<T> because it is used in Enums.random( ), and a Competitor<T> because it is passed to match( ): 
  The play( ) method does not have a return value that involves the type parameter T, so it seems like you might use wildcards inside the Class<T> type instead of using the leading parameter description. However, wildcards cannot extend more than one base type, so we must use the above expression. 
Using constant-specific methods
  Because constant-specific methods allow you to provide different method implementations for each enum instance, they might seem like a perfect solution for setting up multiple dispatching. But even though they can be given different behavior in this way, enum instances are not types, so you cannot use them as argument types in method signatures. The best you can do for this example is to set up a switch statement: 
  Although this is functional and not unreasonable, the solution of RoShamBo2.java seems to require less code when adding a new type, and thus seems more straightforward. 
  However, RoShamBo3.java can be simplified and compressed: 
  Here, the second dispatch is performed by the two-argument version of compete( ), which performs a sequence of comparisons and is thus similar to the action of a switch. It’s smaller, but a bit confusing. For a large system this confusion can become debilitating. 
Dispatching with EnumMaps
  It’s possible to perform a "true" double dispatch using the EnumMap class, which is specifically designed to work very efficiently with enums. Since the goal is to switch on two unknown types, an EnumMap of EnumMaps can be used to produce the double dispatch: 
  The EnumMap is initialized using a static clause; you can see the table-like structure of the calls to initRow( ). Notice the compete( ) method, where you can see both dispatches happening in a single statement. 
Using a 2-D array
  We can simplify the solution even more by noting that each enum instance has a fixed value (based on its declaration order) and that ordinal( ) produces this value. A two-dimensional array mapping the competitors onto the outcomes produces the smallest and most straightforward solution (and possibly the fastest, although remember that EnumMap uses an internal array): 
  The table has exactly the same order as the calls to initRow( ) in the previous example. 
  The small size of this code holds great appeal over the previous examples, partly because it seems much easier to understand and modify but also because it just seems more straightforward. However, it’s not quite as "safe" as the previous examples because it uses an array. With a larger array, you might get the size wrong, and if your tests do not cover all possibilities something could slip through the cracks. 
  All of these solutions are different types of tables, but it’s worth exploring the expression of the tables to find the one that fits best. Note that even though the above solution is the most compact, it is also fairly rigid because it can only produce a constant output given constant inputs. However, there’s nothing that prevents you from having table produce a function object. For certain types of problems, the concept of "table-driven code" can be very powerful. 
