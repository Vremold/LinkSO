  Java enums have a very interesting feature that allows you to give each enum instance different behavior by creating methods for each one. To do this, you define one or more abstract methods as part of the enum, then define the methods for each enum instance. For example: 
  You can look up and call methods via their associated enum instance. This is often called table-driven code (and note the similarity to the aforementioned Command pattern). 
  In object-oriented programming, different behavior is associated with different classes. Because each instance of an enum can have its own behavior via constant-specific methods, this suggests that each instance is a distinct type. In the above example, each enum instance is being treated as the "base type" ConstantSpecificMethod but you get polymorphic behavior with the method call getInfo( ). 
  However, you can only take the similarity so far. You cannot treat enum instances as class types: 
  In f1( ), you can see that the compiler doesn’t allow you to use an enum instance as a class type, which makes sense if you consider the code generated by the compiler—each enum element is a static final instance of LikeClasses. 
  Also, because they are static, enum instances of inner enums do not behave like ordinary inner classes; you cannot access non-static fields or methods in the outer class. 
  As a more interesting example, consider a car wash. Each customer is given a menu of choices for their wash, and each option performs a different action. A constant-specific method can be associated with each option, and an EnumSet can be used to hold the customer’s selections: 
  The syntax for defining a constant-specific method is effectively that of an anonymous inner class, but more succinct. 
  This example also shows more characteristics of EnumSets. Since it’s a set, it will only hold one of each item, so duplicate calls to add( ) with the same argument are ignored (this makes sense, since you can only flip a bit "on" once). Also, the order that you add enum instances is unimportant—the output order is determined by the declaration order of the enum. 
  Is it possible to override constant-specific methods, instead of implementing an abstract method? Yes, as you can see here: 
  Although enums do prevent certain types of code, in general you should experiment with them as if they were classes. 
Chain of Responsibility with enums
  In the Chain of Responsibility design pattern, you create a number of different ways to solve a problem and chain them together. When a request occurs, it is passed along the chain until one of the solutions can handle the request. 
  You can easily implement a simple Chain of Responsibility with constantspecific methods. Consider a model of a post office, which tries to deal with each piece of mail in the most general way possible, but has to keep trying until it ends up treating the mail as a dead letter. Each attempt can be thought of as a Strategy (another design pattern), and the entire list together is a Chain of Responsibility. 
  We start by describing a piece of mail. All the different characteristics of interest can be expressed using enums. Because the Mail objects will be randomly generated, the easiest way to reduce the probability of (for example) a piece of mail being given a YES for GeneralDelivery is to create more non-YES instances, so the enum definitions look a little funny at first. 
  Within Mail, you’ll see randomMail( ), which creates random pieces of test mail. The generator( ) method produces an Iterable object that uses randomMail( ) to produce a number of mail objects, one each time you call next( ) via the iterator. This construct allows the simple creation of a foreach loop by calling Mail.generator( ): 
  The Chain of Responsibility is expressed in enum MailHandler, and the order of the enum definitions determines the order in which the strategies are attempted on each piece of mail. Each strategy is tried in turn until one succeeds or they all fail, in which case you have a dead letter. 
  Exercise 8: (6) Modify PostOffice.java so it has the ability to forward mail. 
  Exercise 9: (5) Modify class PostOffice so that it uses an EnumMap. Project:2 Specialized languages like Prolog use backward chaining in order to solve problems like this. Using PostOffice.java for inspiration, research such languages and develop a program that allows new "rules" to be easily added to the system. 
State machines with enums
  Enumerated types can be ideal for creating state machines. A state machine can be in a finite number of specific states. The machine normally moves from one state to the next based on an input, but there are also transient states; the machine moves out of these as soon as their task is performed. 
  guide. 
  There are certain allowable inputs for each state, and different inputs change the state of the machine to different new states. Because enums restrict the set of possible cases, they are quite useful for enumerating the different states and inputs. 
  Each state also typically has some kind of associated output. 
  A vending machine is a good example of a state machine. First, we define the various inputs in an enum: 
  Note that two of the Inputs have an associated amount, so amount( ) is defined in the interface. However, it is inappropriate to call amount( ) for the other two Input types, so they throw an exception if you call amount( ). Although this is a bit of an odd setup (define a method in an interface, then throw an exception if you call it for certain implementations), it is imposed upon us because of the constraints of enums. 
  The VendingMachine will react to these inputs by first categorizing them via the Category enum, so that it can switch on the categories. This example shows how enums make code clearer and easier to manage: 
  Because selecting among enum instances is most often accomplished with a switch statement (notice the extra effort that the language goes to in order to make a switch on enums easy), one of the most common questions to ask when you are organizing multiple enums is "What do I want to switch on?" Here, it’s easiest to work back from the VendingMachine by noting that in each State, you need to switch on the basic categories of input action: money being inserted, an item being selected, the transaction being aborted, and the machine being turned off. However, within those categories, you have different types of money that can be inserted and different items that can be selected. The Category enum groups the different types of Input so that the categorize( ) method can produce the appropriate Category inside a switch. This method uses an EnumMap to efficiently and safely perform the lookup. 
  If you study class VendingMachine, you can see how each state is different, and responds differently to input. Also note the two transient states; in run( ) the machine waits for an Input and doesn’t stop moving through states until it is no longer in a transient state. 
  The VendingMachine can be tested in two ways, by using two different Generator objects. The RandomInputGenerator just keeps producing inputs, everything except SHUT_DOWN. By running this for a long time you get a kind of sanity check to help ensure that the machine will not wander into a bad state. The FilelnputGenerator takes a file describing inputs in text form, turns them into enum instances, and creates Input objects. Here’s the text file used to produce the output shown above: 
  QUARTER; QUARTER; QUARTER; CHIPS; DOLLAR; DOLLAR; TOOTHPASTE; QUARTER; DIME; ABORT_TRANSACTION; QUARTER; DIME; SODA; QUARTER; DIME; NICKEL; SODA; ABORT_TRANSACTION; STOP; ///:~ 
  One limitation to this design is that the fields in VendingMachine that are accessed by enum State instances must be static, which means you can only have a single VendingMachine instance. This may not be that big of an issue if you think about an actual (embedded Java) implementation, since you are likely to have only one application per machine. 
  Exercise 10: (7) Modify class VendingMachine (only) using EnumMap so that one program can have multiple instances of VendingMachine. 
  Exercise 11: (7) In a real vending machine you will want to easily add and change the type of vended items, so the limits imposed by an enum on Input are impractical (remember that enums are for a restricted set of types). Modify VendingMachine.java so that the vended items are represented by a class instead of being part of Input, and initialize an Array List of these objects from a text file (using net.mindview.util.TextFile). 
  Project3 Design the vending machine using internationalization, so that one machine can easily be adapted to all countries. 
