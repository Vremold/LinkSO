  Except for the fact that you can’t inherit from it, an enum can be treated much like a regular class. This means that you can add methods to an enum. It’s even possible for an enum to have a main( ). 
  You may want to produce different descriptions for an enumeration than the default toString( ), which simply produces the name of that enum instance, as you’ve seen. To do this, you can provide a constructor to capture extra information, and additional methods to provide an extended description, like this: 
  Notice that if you are going to define methods you must end the sequence of enum instances with a semicolon. Also, Java forces you to define the instances as the first thing in the enum. You’ll get a compile-time error if you try to define them after any of the methods or fields. 
  The constructor and methods have the same form as a regular class, because with a few restrictions this is a regular class. So you can do pretty much anything you want with enums (although you’ll usually keep them pretty ordinary). 
  Although the constructor has been made private here as an example, it doesn’t make much difference what access you use—the constructor can only be used to create the enum instances that you declare inside the enum definition; the compiler won’t let you use it to create any new instances once the enum definition is complete. 
Overriding enum methods
  Here’s another approach to producing different string values for enumerations. In this case, the instance names are OK but we want to reformat them for display. Overriding the toString( ) method for an enum is the same as overriding it for a regular class: 
  The toString( ) method gets the Spaceship name by calling name( ), and modifies the result so that only the first letter is capitalized. 
