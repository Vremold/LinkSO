  As shown in Initialization & Cleanup, you can step through the list of enum constants by calling values( ) on the enum. The values( ) method produces an array of the enum constants in the order in which they were declared, so you can use the resulting array in (for example) a foreach loop. 
  When you create an enum, an associated class is produced for you by the compiler. This class is automatically inherited from java.lang.Enum, which provides certain capabilities that you can see in this example: 
  The ordinal( ) method produces an int indicating the declaration order of each enum instance, starting from zero. You can always safely compare enum instances using ==, and equals( ) and hashCode( ) are automatically created for you. The Enum class is Comparable, so there’s a compareTo( ) method, and it is also Serializable. 
  If you call getDeclaringClass( ) on an enum instance, you’ll find out the enclosing enum class. 
  The name( ) method produces the name exactly as it is declared, and this is what you get with toString( ), as well. valueOf( ) is a static member of Enum, and produces the enum instance that corresponds to the String name you pass to it, or throws an exception if there’s no match. 
Using static imports with enums
  Consider a variation of Burrito.java from the Initialization & Cleanup chapter: 
  The static import brings all the enum instance identifiers into the local namespace, so they don’t need to be qualified. Is this a good idea, or is it better to be explicit and qualify all enum instances? It probably depends on the complexity of your code. The compiler certainly won’t let you use the wrong type, so your only concern is whether the code will be confusing to the reader. In many situations it will probably be fine but you should evaluate it on an individual basis. 
  Note that it is not possible to use this technique if the enum is defined in the same file or the default package (apparently there were some arguments within Sun about whether to allow this). 
