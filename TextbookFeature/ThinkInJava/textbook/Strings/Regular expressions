  Regular expressions have long been integral to standard Unix utilities like sed and awk, and languages like Python and Perl (some would argue that they are the predominant reason for Perl’s success). String manipulation tools were previously delegated to the String, StringBuffer, and StringTokenizer classes in Java, which had relatively simple facilities compared to regular expressions. 
  Regular expressions are powerful and flexible text-processing tools. They allow you to specify, programmatically, complex patterns of text that can be discovered in an input string. Once you discover these patterns, you can then react to them any way you want. Although the syntax of regular expressions can be intimidating at first, they provide a compact and dynamic language that can be employed to solve all sorts of string processing, matching and selection, editing, and verification problems in a completely general way. 
Basics
  A regular expression is a way to describe strings in general terms, so that you can say, "If a string has these things in it, then it matches what I’m looking for." For example, to say that a number might or might not be preceded by a minus sign, you put in the minus sign followed by a question mark, like this: 
  -? 
  To describe an integer, you say that it’s one or more digits. In regular expressions, a digit is described by saying ‘\d’. If you have any experience with regular expressions in other languages, you’ll immediately notice a difference in the way backslashes are handled. In other languages, ‘\\’ means "I want to insert a plain old (literal) backslash in the regular expression. Don’t give it any special meaning." In Java, ‘ \ \ ‘ means "I’m inserting a regular expression backslash, so that the following character has special meaning." For example, if you want to indicate a digit, your regular expression string will be ‘\\d’. If you want to insert a literal backslash, you say ‘\\\\’- However, things like newlines and tabs just use a single backslash: ‘\n\t’. 
  To indicate "one or more of the preceding expression," you use a ‘+’. So to say, "possibly a minus sign, followed by one or more digits," you write: 
  -?\\d+  The simplest way to use regular expressions is to use the functionality built into the String class. For example, we can see whether a String matches the regular expression above: 
  The first two expressions match, but the third one starts with a ‘+’, which is a legitimate sign but means the number doesn’t match the regular expression. So we need a way to say, "may start with a + or a -." In regular expressions, parentheses have the effect of grouping an expression, and the vertical bar ‘|’ means OR. So  (-I\\+)? 
  means that this part of the string may be either a ‘-’ or a ‘+’ or nothing (because of the ‘?’). Because the ‘+’ character has special meaning in regular expressions, it must be escaped with a ‘\\’ in order to appear as an ordinary character in the expression. 
  A useful regular expression tool that’s built into String is split( ), which means, "Split this string around matches of the given regular expression." 
  First, note that you may use ordinary characters as regular expressions—a regular expression doesn’t have to contain special characters, as you can see in the first call to split( ), which just splits on whitespace. 
  The second and third calls to split( ) use ‘\W’, which means a non-word character (the lowercase version, ‘\w’, means a word character)—you can see that the punctuation has been removed in the second case. The third call to split( ) says, "the letter n followed by one or more non-word characters." You can see that the split patterns do not appear in the result. 
  An overloaded version of String. split( ) allows you to limit the number of splits that occur. 
  The final regular expression tool built into String is replacement. You can either replace the first occurrence, or all of them: 
  The first expression matches the letter f followed by one or more word characters (note that the w is lowercase this time). It only replaces the first match that it finds, so the word "found" is replaced by the word "located." 
  The second expression matches any of the three words separated by the OR vertical bars, and it replaces all matches that it finds. 
  You’ll see that the non-String regular expressions have more powerful replacement tools— for example, you can call methods to perform replacements. Non-String regular expressions are also significantly more efficient if you need to use the regular expression more than once. 
  Exercise 7: (5) Using the documentation for java.util.regex.Pattern as a resource, write and test a regular expression that checks a sentence to see that it begins with a capital letter and ends with a period. 
  Exercise 8: (2) Split the string Splitting.knights on the words "the" or “you." 
  Exercise 9: (4) Using the documentation for java.util.regex.Pattern as a resource, replace all the vowels in Splitting.knights with underscores. 
Creating regular expressions
  You can begin learning regular expressions with a subset of the possible constructs. A complete list of constructs for building regular expressions can be found in the JDK documentation for the Pattern class for package java.util.regex. 
  Characters B The specific character B \xhh Character with hex value oxhh \uhhhh The Unicode character with hex representation 0xhhhh \t Tab \n Newline \r Carriage return \f Form feed \e Escape         The power of regular expressions begins to appear when you are defining character classes. Here are some typical ways to create character classes, and some predefined classes: 
  Character Classes . Any character [abc] Any of the characters a, b, or c (same as a|b|c) [^abc] Any character except a, b, and c (negation) [a-zA-Z] Any character a through z or A through Z (range) [abc[hij]] Any of a,b,c,h,I,j (same as a|b|c|h|i|j) (union) [a-z&&[hij]] Either h, i, or j (intersection) \s A whitespace character (space, tab, newline, form feed, carriage return) \S A non-whitespace character ([^\s]) \d A numeric digit [0-9] \D A non-digit [^o-9] \w A word character [a-zA-Z_0-9] \W A non-word character [^\w]  What’s shown here is only a sample; you’ll want to bookmark the JDK documentation page for java.util.regex.Pattern so you can easily access all the possible regular expression patterns. 
  Logical Operators XY X followed by Y X|Y X or Y (X) A capturing group. You can refer to the ith captured group later in the expression with \i. 
  Boundary Matchers ^ Beginning of a line $ End of a line \b Word boundary \B Non-word boundary \G End of the previous match  As an example, each of the following successfully matches the character sequence "Rudolph": 
  Of course, your goal should not be to create the most obfuscated regular expression, but rather the simplest one necessary to do the job. You’ll find that, once you start writing regular expressions, you’ll often use your code as a reference when writing new regular expressions. 
Quantifiers
  A quantifier describes the way that a pattern absorbs input text: 
  • Greedy: Quantifiers are greedy unless otherwise altered. A greedy expression finds as many possible matches for the pattern as possible. A typical cause of problems is to assume that your pattern will only match the first possible group of characters, when it’s actually greedy and will keep going until it’s matched the largest possible string. 
  • Reluctant: Specified with a question mark, this quantifier matches the minimum number of characters necessary to satisfy the pattern. Also called lazy, minimal matching, non-greedy, or ungreedy. 
  • Possessive: Currently this is only available in Java (not in other languages) and is more advanced, so you probably won’t use it right away. As a regular expression is applied to a string, it generates many states so that it can backtrack if the match fails. Possessive quantifiers do not keep those intermediate states, and thus prevent backtracking. They can be used to prevent a regular expression from running away and also to make it execute more efficiently. 
  Greedy Reluctant Possessive Matches  X? X?? X?+ X, one or none 
  X* X*? x*+ X, zero or more  x+ x+? X++ X, one or more 
  X{n} X{n}? X{n}+ X, exactly n times  X{n,} X{n,}? X{n,}+ X, at least n times 
  X{n,m} X{n,m}? X{n,m}+ X, at least n but not more than m times  Keep in mind that the expression ‘X’ will often need to be surrounded in parentheses for it to work the way you desire. For example: 
  abc+  might seem like it would match the sequence ‘abc’ one or more times, and if you apply it to the input string ‘abcabcabc’, you will in fact get three matches. However, the expression actually says, "Match ‘ab’ followed by one or more occurrences of ‘c’." To match the entire string ‘abc’ one or more times, you must say: 
  (abc)+  You can easily be fooled when using regular expressions; it’s an orthogonal language, on top of Java. 
  CharSequence  The interface called CharSequence establishes a generalized definition of a character sequence abstracted from the CharBuffer, String, StringBuffer, or StringBuilder classes: 
  interface CharSequence { charAt(int i); length(); subSequence(int start,| int end); toString(); } 
  The aforementioned classes implement this interface. Many regular expression operations take CharSequence arguments. 
Pattern and Matcher
  In general, you’ll compile regular expression objects rather than using the fairly limited String utilities. To do this, you import java.util.regex, then compile a regular expression by using the static Pattern.compile( ) method. This produces a Pattern object based on its String argument. You use the Pattern by calling the matcher( ) method, passing the string that you want to search. The matcher( ) method produces a Matcher object, which has a set of operations to choose from (you can see all of these in the JDK documentation for java.util.regex.Matcher). For example, the replaceAll( ) method replaces all the matches with its argument. 
  As a first example, the following class can be used to test regular expressions against an input string. The first command-line argument is the input string to match against, followed by one or more regular expressions to be applied to the input. Under Unix/Linux, the regular expressions must be quoted on the command line. This program can be useful in testing regular expressions as you construct them to see that they produce your intended matching behavior. 
  A Pattern object represents the compiled version of a regular expression. As seen in the preceding example, you can use the matcher( ) method and the input string to produce a Matcher object from the compiled Pattern object. Pattern also has a static method: 
  static boolean matches(String regex, CharSequence input)  to check whether regex matches the entire input CharSequence, and a split( ) method that produces an array of String that has been broken around matches of the regex. 
  A Matcher object is generated by calling Pattern.matcher( ) with the input string as an argument. The Matcher object is then used to access the results, using methods to evaluate the success or failure of different types of matches: 
  boolean matches() boolean lookingAt() boolean find() boolean find(int start)  The matches ( ) method is successful if the pattern matches the entire input string, while lookingAt( ) is successful if the input string, starting at the beginning, is a match to the pattern. 
  Exercise 10: (2) For the phrase "Java now has regular expressions" evaluate whether the following expressions will find a match: 
  ^Java \Breg.* n.w\s+h(a|i)s s? s* s+ s{4} S{1}. s{0,3} 
  Exercise 11: (2) Apply the regular expression  (?i)((^[aeiou])|(\s+[aeiou]))\w+?[aeiou]\b 
  to  "Arline ate eight apples and one orange while Anita hadn’t any" 
  find()  Matcher.find( ) can be used to discover multiple pattern matches in the CharSequence to which it is applied. For example: 
  The pattern ‘\\w+’ splits the input into words. find( ) is like an iterator, moving forward through the input string. However, the second version of find( ) can be given an integer argument that tells it the character position for the beginning of the search—this version resets the search position to the value of the argument, as you can see from the output. 
  Groups  Groups are regular expressions set off by parentheses that can be called up later with their group number. Group o indicates the whole expression match, group l is the first parenthesized group, etc. Thus in 
  A(B(C))D  there are three groups: Group 0 is ABCD, group 1 is BC, and group 2 is C. 
  The Matcher object has methods to give you information about groups: 
  public int groupCount( ) returns the number of groups in this matcher’s pattern. Group o is not included in this count. 
  public String group( ) returns group 0 (the entire match) from the previous match operation (find( ), for example). 
  public String group(int i) returns the given group number during the previous match operation. If the match was successful, but the group specified failed to match any part of the input string, then null is returned. 
  public int start(int group) returns the start index of the group found in the previous match operation. 
  public int end(int group) returns the index of the last character, plus one, of the group found in the previous match operation. 
  Here’s an example: 
  The poem is the first part of Lewis Carroll’s "Jabberwocky," from Through the Looking Glass. You can see that the regular expression pattern has a number of parenthesized groups, consisting of any number of non-whitespace characters (‘\S+’) followed by any number of whitespace characters (‘\s+’). The goal is to capture the last three words on each line; the end of a line is delimited by ‘$’. However, the normal behavior is to match ‘$’ with the end of the entire input sequence, so you must explicitly tell the regular expression to pay attention to newlines within the input. This is accomplished with the ‘(?m)’ pattern flag at the beginning of the sequence (pattern flags will be shown shortly). 
  Exercise 12: (5) Modify Groups.java to count all of the unique words that do not start with a capital letter. 
  start() and end()  Following a successful matching operation, start( ) returns the start index of the previous match, and end( ) returns the index of the last character matched, plus one. Invoking either start( ) or end( ) following an unsuccessful matching operation (or before attempting a matching operation) produces an IllegalStateException. The following program also demonstrates matches( ) and lookingAt( ):3 
  Notice that find( ) will locate the regular expression anywhere in the input, but lookingAt( ) and matches( ) only succeed if the regular expression starts matching at the very beginning of the input. While matches( ) only succeeds if the entire input matches the regular expression, lookingAt( )4 succeeds if only the first part of the input matches. 
  Exercise 13: (2) Modify StartEnd.java so that it uses Groups.POEM as input, but still produces positive outputs for find( ), lookingAt( ) and matches( ). 
  Pattern flags  An alternative compile( ) method accepts flags that affect matching behavior: 
  Pattern Pattern.compile(String regex, int flag)  where flag is drawn from among the following Pattern class constants: 
  that whoever comes up with nonintuitive method names is still employed at Sun. And that their apparent policy of not reviewing code designs is still in place. Sorry for the sarcasm, but this kind of thing gets tiresome after a few years. 
  Compile Flag Effect  Pattern.CANON_EQ Two characters will be considered to match if, and only if, their full canonical decompositions match. The expression ‘\u003F’, for example, will match the string ‘?’ when this flag is specified. By default, matching does not take canonical equivalence into account. 
  Pattern.CASE INSENSITIVE By default, case-insensitive matching (?i) assumes that only characters in the US- ASCII character set are being matched. This flag allows your pattern to match without regard to case (upper or lower). Unicode-aware case-insensitive matching can be enabled by specifying the UNICODE_CASE flag in conjunction with this flag. 
  Pattern.COMMENTS In this mode, whitespace is ignored, and (?x) embedded comments starting with # are ignored until the end of a line. Unix lines mode can also be enabled via the embedded flag expression. 
  Pattern.DOTALL In dotall mode, the expression’.’ matches (?s) any character, including a line terminator. By default, the ‘.’ expression does not match line terminators. 
  Pattern.MULTILINE In multiline mode, the expressions ‘^’ and (?m) ‘$’ match the beginning and ending of a line, respectively.’^’ also matches the beginning of the input string, and ‘$’ also matches the end of the input string. By default, these expressions only match at the beginning and the end of the entire input string. 
  Pattern.UNICODE CASE Case-insensitive matching, when enabled (?u) by the CASE_INSENSITIVE flag, is done in a manner consistent with the Unicode Standard. By default, case- insensitive matching assumes that only characters in the US-ASCII character set are being matched. 
  Pattern.UNIX LINES In this mode, only the ‘\n’ line terminator (?d) is recognized in the behavior of ‘.’, ‘^’, and ‘$’. 
  Particularly useful among these flags are Pattern.CASE_INSENSITIVE, Pattern.MULTILINE, and Pattern.COMMENTS (which is helpful for clarity and/or documentation). Note that the behavior of most of the flags can also be obtained by inserting the parenthesized characters, shown beneath the flags in the table, into your regular expression preceding the place where you want the mode to take effect. 
  You can combine the effect of these and other flags through an "OR" (‘|’) operation: 
  This creates a pattern that will match lines starting with "Java," "Java," "JAVA," etc., and attempt a match for each line within a multiline set (matches starting at the beginning of the character sequence and following each line terminator within the character sequence). Note that the group( ) method only produces the matched portion. 
split()
  split( ) divides an input string into an array of String objects, delimited by the regular expression. 
  String[] split(CharSequence input) String[] split(CharSequence input, int limit)  This is a handy way to break input text on a common boundary: 
  The second form of split( ) limits the number of splits that occur. 
  Exercise 14: (1) Rewrite SplitDemo using String.split( ). 
Replace operations
  Regular expressions are especially useful to replace text. Here are the available methods: 
  replaceFirst(String replacement) replaces the first matching part of the input string with replacement. 
  replaceAll(String replacement) replaces every matching part of the input string with replacement. 
  appendReplacement(StringBuffer sbuf, String replacement) performs step-by-step replacements into sbuf, rather than replacing only the first one or all of them, as in replaceFirst( ) and replaceAll( ), respectively. This is a very important method, because it allows you to call methods and perform other processing in order to produce replacement (replaceFirst( ) and replaceAll( ) are only able to put in fixed strings). With this method, you can programmatically pick apart the groups and create powerful replacements. 
  appendTail(StringBuffer sbuf, String replacement) is invoked after one or more invocations of the appendReplacement( ) method in order to copy the remainder of the input string. 
  Here’s an example that shows the use of all the replace operations. The block of commented text at the beginning is extracted and processed with regular expressions for use as input in the rest of the example: 
  The file is opened and read using the TextFile class in the net.mindview.util library (the code for this will be shown in the I/O chapter). The static read( ) method reads the entire file and returns it as a String. mInput is created to match all the text (notice the grouping parentheses) between ‘/*!’ and ‘!*/’. Then, more than two spaces are reduced to a single space, and any space at the beginning of each line is removed (in order to do this on all lines and not just the beginning of the input, multiline mode must be enabled). These two replacements are performed with the equivalent (but more convenient, in this case) replaceAll( ) that’s part of String. Note that since each replacement is only used once in the program, there’s no extra cost to doing it this way rather than precompiling it as a Pattern. 
  replaceFirst( ) only performs the first replacement that it finds. In addition, the replacement strings in replaceFirst( ) and replaceAll( ) are just literals, so if you want to perform some processing on each replacement, they don’t help. In that case, you need to use appendReplacement( ), which allows you to write any amount of code in the process of performing the replacement. In the preceding example, a group( ) is selected and processed—in this situation, setting the vowel found by the regular expression to uppercase— as the resulting sbuf is being built. Normally, you step through and perform all the replacements and then call appendTail( ), but if you want to simulate replaceFirst( ) (or "replace n"), you just do the replacement one time and then call appendTail( ) to put the rest into sbuf. 
  appendReplacement( ) also allows you to refer to captured groups directly in the replacement string by saying "$g", where ‘g’ is the group number. However, this is for simpler processing and wouldn’t give you the desired results in the preceding program. 
reset()
  An existing Matcher object can be applied to a new character sequence using the reset( ) methods: 
  reset( ) without any arguments sets the Matcher to the beginning of the current sequence. Regular expressions and Java I/O  Most of the examples so far have shown regular expressions applied to static strings. The following example shows one way to apply regular expressions to search for matches in a file. Inspired by Unix’s grep, JGrep.java takes two arguments: a file name and the regular expression that you want to match. The output shows each line where a match occurs and the match position(s) within the line. 
  The file is opened as a net.mindview.util.TextFile object (which will be shown in the I/O chapter), which reads the lines of the file into an ArrayList. This means that the foreach syntax can iterate through the lines in the TextFile object. 
  Although it’s possible to create a new Matcher object within the for loop, it is slightly more optimal to create an empty Matcher object outside the loop and use the reset( ) method to assign each line of the input to the Matcher. The result is scanned with find( ). 
  The test arguments open the JGrep.java file to read as input, and search for words starting with [Ssct]. 
  You can learn much more about regular expressions in Mastering Regular Expressions, 2nd Edition, by Jeffrey E. F. Friedl (O’Reilly, 2002). There are also numerous introductions to regular expressions on the Internet, and you can often find helpful information in the documentation for languages like Perl and Python. 
  Exercise 15: (5) Modify JGrep.java to accept flags as arguments (e.g., Pattern.CASE_INSENSITIVE, Pattern.MULTILINE). 
  Exercise 16: (5) Modify JGrep.java to accept a directory name or a file name as argument (if a directory is provided, search should include all files in the directory). Hint: You can generate a list of file names with: 
  File[] files = new File(".").listFiles(); 
  Exercise 17: (8) Write a program that reads a Java source-code file (you provide the file name on the command line) and displays all the comments. 
  Exercise 18: (8) Write a program that reads a Java source-code file (you provide the file name on the command line) and displays all the string literals in the code. 
  Exercise 19: (8) Building on the previous two exercises, write a program that examines Java source code and produces all the class names used in a particular program. 
