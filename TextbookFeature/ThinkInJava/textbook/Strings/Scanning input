  Until now it has been relatively painful to read data from a human-readable file or from standard input. The usual solution is to read in a line of text, tokenize it, and then use the various parse methods of Integer, Double, etc., to parse the data: 
  The input field uses classes from java.io, which will not officially be introduced until the I/O chapter. A StringReader turns a String into a readable stream, and this object is used to create a BufferedReader because BufferedReader has a readLine( ) method. The result is that the input object can be read a line at a time, just as if it were standard input from the console. 
  readLine( ) is used to get the String for each line of input. It’s fairly straightforward when you want to get one input for each line of data, but if two input values are on a single line, things get messy—the line must be split so we can parse each input separately. Here, the splitting takes place when creating numArray, but note that the split( ) method was introduced in J2SE1.4, so before that you had to do something else. 
  The Scanner class, added in Java SE5, relieves much of the burden of scanning input: 
  The Scanner constructor can take just about any kind of input object, including a File object (which will also be covered in the I/O chapter), an InputStream, a String, or in this case a Readable, which is an interface introduced in Java SE5 to describe "something that has a read( ) method." The BufferedReader from the previous example falls into this category. 
  With Scanner, the input, tokenizing, and parsing are all ensconced in various different kinds of "next" methods. A plain next( ) returns the next String token, and there are "next" methods for all the primitive types (except char) as well as for BigDecimal and Biglnteger. All of the "next" methods block, meaning they will return only after a complete data token is available for input. There are also corresponding "hasNext" methods that return true if the next input token is of the correct type. 
  An interesting difference between the two previous examples above is the lack of a try block for IOExceptions in BetterRead.java. One of the assumptions made by the Scanner is that an IOException signals the end of input, and so these are swallowed by the Scanner. However, the most recent exception is available through the ioException( ) method, so you are able to examine it if necessary. 
  Exercise 20: (2) Create a class that contains int, long, float and double and String fields. Create a constructor for this class that takes a single String argument, and scans that string into the various fields. Add a toString( ) method and demonstrate that your class works correctly. 
Scanner delimiters
  By default, a Scanner splits input tokens along whitespace, but you can also specify your own delimiter pattern in the form of a regular expression: 
  This example uses commas (surrounded by arbitrary amounts of whitespace) as the delimiter when reading from the given String. This same technique can be used to read from comma- delimited files. In addition to useDelimiter( ) for setting the delimiter pattern, there is also delimiter( ), which returns the current Pattern being used as a delimiter. 
Scanning with regular expressions
  In addition to scanning for predefined primitive types, you can also scan for your own user- defined patterns, which is helpful when scanning more complex data. This example scans threat data from a log like your firewall might produce: 
  When you use next( ) with a specific pattern, that pattern is matched against the next input token. The result is made available by the match( ) method, and as you can see above, it works just like the regular expression matching you saw earlier. 
  There’s one caveat when scanning with regular expressions. The pattern is matched against the next input token only, so if your pattern contains a delimiter it will never be matched. 
