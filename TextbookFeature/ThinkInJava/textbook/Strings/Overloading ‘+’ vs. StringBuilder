  Since String objects are immutable, you can alias to a particular String as many times as you want. Because a String is read-only, there’s no possibility that one reference will change something that will affect the other references. 
  Immutability can have efficiency issues. A case in point is the operator ‘+’ that has been overloaded for String objects. Overloading means that an operation has been given an extra meaning when used with a particular class. (The ‘+’ and ‘+=‘ for String are the only operators that are overloaded in Java, and Java does not allow the programmer to overload any others.)1 The’+’ operator allows you to concatenate Strings: 
  You could imagine how this might work. The String "abc" could have a method append( ) that creates a new String object containing "abc" concatenated with the contents of mango. The new String object would then create another new String that added "def," and so on. 
  This would certainly work, but it requires the creation of a lot of String objects just to put together this new String, and then you have a bunch of intermediate String objects that need to be garbage collected. I suspect that the Java designers tried this approach first (which is a lesson in software design—you don’t really know anything about a system until you try it out in code and get something working). I also suspect that they discovered it delivered unacceptable performance. 
  To see what really happens, you can decompile the above code using the javap tool that comes as part of the JDK. Here’s the command line: 
  javap -c Concatenation  The -c flag will produce the JVM bytecodes. After we strip out the parts we’re not interested in and do a bit of editing, here are the relevant bytecodes: 
  public static void main(java.lang.String[]); Code: Stack=2, Locals=3, Args_size=1 0: ldc #2; //String mango   included in Java. It wasn’t so bad that they didn’t end up doing it themselves, and ironically enough, operator overloading would be much easier to use in Java than in C++. This can be seen in Python (see www.Python.org) and C#, which have garbage collection and straightforward operator overloading. 
  2: astore_1 3: new #3; //class StringBuilder 6: dup 7: invokespecial #4; //StringBuilder."<init>":() 10: ldc #5; // String abc 12 invokevirtual #6; //StringBuilder.append:(String) 15 aload_1 16 invokevirtual #6; //StringBuilder.append:(String) 19 ldc #7; //String def 21 invokevirtual #6; //StringBuilder.append:(String) 24 bipush 47 26 invokevirtual #8; //StringBuilder.append:(I) 29 invokevirtual #9; //StringBuilder.toString:() 32 astore_2 33 getstatic #10; //Field System.out:PrintStream; 36 aload_2 37 invokevirtual #11; // PrintStream.println:(String) 40 return  If you’ve had experience with assembly language, this may look familiar to you—statements like dup and invokevirtual are the Java Virtual Machine (JVM) equivalent of assembly language. If you’ve never seen assembly language, don’t worry about it—the important part to notice is the introduction by the compiler of the java.lang.StringBuilder class. There was no mention of StringBuilder in the source code, but the compiler decided to use it anyway, because it is much more efficient. 
  In this case, the compiler creates a StringBuilder object to build the String s, and calls append( ) four times, one for each of the pieces. Finally, it calls toString( ) to produce the result, which it stores (with astore_2) as s. 
  Before you assume that you should just use Strings everywhere and that the compiler will make everything efficient, let’s look a little more closely at what the compiler is doing. Here’s an example that produces a String result in two ways: using Strings, and by hand-coding with StringBuilder: 
  Now if you run javap -c WitherStringBuilder, you can see the (simplified) code for the two different methods. First, implicit( ): 
  public java.lang.String implicit(java.lang.String[]); Code: 0: ldc #2; //String 2: astore_2 3: iconst_0 4: istore_3    5: iload_3 6: aload_1 7: arraylength 8: if_icmpge 38 11: new #3; //class StringBuilder 14: dup 15: invokespecial #4; // StringBuilder.”<init>”:() 18: aload_2 19: invokevirtual #5; // StringBuilder.append:() 22: aload_1 23 iload_3 24 aaload 25: invokevirtual #5; // StringBuilder.append:() 28: invokevirtual #6; // StringBuiIder.toString:() 31: astore_2 32: iinc 3, 1 35: goto 5 38: aload_2 39 areturn 
  Notice 8: and 35:, which together form a loop. 8: does an "integer compare greater than or equal to" of the operands on the stack and jumps to 38: when the loop is done. 35: is a goto back to the beginning of the loop, at 5:. The important thing to note is that the StringBuilder construction happens inside this loop, which means you’re going to get a new StringBuilder object every time you pass through the loop. 
  Here are the bytecodes for explicit( ): 
  public java.lang.String explicit(java.lang.String[]); Code: 0: new #3; //class StringBuilder 3: dup 4: invokespecial #4; // StringBuilder.”<init>”:() 7: astore_2 8: iconst_0 9: istore_3 10: iload_3 11: aload_1 12: arraylength 13: if_icmpge 30 16: aload_2 17: aload_1 18: iload_3 19: aaload 20 invokevirtual #5; // StringBuilder.append:() 23 pop 24: iinc 3,1 27: goto 10 30: aload_2 31: invokevirtual #6; // StringBuiIder.toString:() 34: areturn  Not only is the loop code shorter and simpler, the method only creates a single StringBuilder object. Creating an explicit StringBuilder also allows you to preallocate its size if you have extra information about how big it might need to be, so that it doesn’t need to constantly reallocate the buffer. 
  Thus, when you create a toString( ) method, if the operations are simple ones that the compiler can figure out on its own, you can generally rely on the compiler to build the result in a reasonable fashion. But if looping is involved, you should explicitly use a StringBuilder in your toString( ), like this: 
  Notice that each piece of the result is added with an append( ) statement. If you try to take shortcuts and do something like append(a + ": " + c), the compiler will jump in and start making more StringBuilder objects again. 
  If you are in doubt about which approach to use, you can always run javap to double-check. 
  Although StringBuilder has a full complement of methods, including insert( ), replace( ), substring( ) and even reverse( ), the ones you will generally use are append( ) and toString( ). Note the use of delete( ) to remove the last comma and space before adding the closing square bracket. 
  StringBuilder was introduced in Java SE5. Prior to this, Java used StringBuffer, which ensured thread safety (see the Concurrency chapter) and so was significantly more expensive. Thus, string operations in Java SE5/6 should be faster. 
  Exercise 1: (2) Analyze SprinklerSystem.toString( ) in reusing/SprinklerSystem.java to discover whether writing the toString( ) with an explicit StringBuilder will save any StringBuilder creations. 
