  An important goal of the interface keyword is to allow the programmer to isolate components, and thus reduce coupling. If you write to interfaces, you accomplish this, but with type information it’s possible to get around that— interfaces are not airtight guarantees of decoupling. Here’s an example, starting with an interface: 
  This interface is then implemented, and you can see how to sneak around to the actual implementation type: 
  Using RTTI, we discover that a has been implemented as a B. By casting to B, we can call a method that’s not in A. 
  This is perfectly legal and acceptable, but you may not want client programmers to do this, because it gives them an opportunity to couple more closely to your code than you’d like. That is, you may think that the interface keyword is protecting you, but it isn’t, and the fact that you’re using B to implement A in this case is effectively a matter of public record.5  One solution is to simply say that programmers are on their own if they decide to use the actual class rather than the interface. This is probably reasonable in many cases, but if "probably" isn’t enough, you might want to apply more stringent controls. 
  The easiest approach is to use package access for the implementation, so that clients outside the package may not see it: 
  The only public part of this package, HiddenC, produces an A interface when you call it. What’s interesting about this is that even if you were to return a C from makeA( ), you still couldn’t use anything but an A from outside the package, since you cannot name C outside the package. 
  Now if you try to downcast to C, you can’t do it because there is no ‘C type available outside the package: 
  As you can see, it’s still possible to reach in and call all of the methods using reflection, even private methods! If you know the name of the method, you can call setAccessible(true) on the Method object to make it callable, as seen in callHiddenMethod( ). 
  You may think that you can prevent this by only distributing compiled code, but that’s no solution. All you must do is run javap, which is the decompiler that comes with the JDK. Here’s the command line: 
  javap -private C  The -private flag indicates that all members should be displayed, even private ones. Here’s the output: 
  class typeinfo.packageaccess.C extends java.lang.Object implements typeinfo.interfacea.A { typeinfo.packageaccess.C(); public void f( ); public void g( ); void u( ); protected void v( ); private void w(); } 
  So anyone can get the names and signatures of your most private methods, and call them. 
  What if you implement the interface as a private inner class? Here’s what it looks like: 
  That didn’t hide anything from reflection. What about an anonymous class? 
  There doesn’t seem to be any way to prevent reflection from reaching in and calling methods that have non-public access. This is also true for fields, even private fields: 
  However, final fields are actually safe from change. The runtime system accepts any attempts at change without complaint, but nothing actually happens. 
  In general, all these access violations are not the worst thing in the world. If someone uses such a technique to call methods that you marked with private or package access (thus clearly indicating they should not call them), then it’s difficult for them to complain if you change some aspect of those methods. On the other hand, the fact that you always have a back door into a class may allow you to solve certain types of problems that could otherwise be difficult or impossible, and the benefits of reflection in general are undeniable. 
  Exercise 25: (2) Create a class containing private, protected and package-access methods. Write code to access these methods from outside of the class’s package. 
