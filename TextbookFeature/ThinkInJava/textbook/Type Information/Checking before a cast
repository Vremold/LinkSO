  So far, you’ve seen forms of RTTI, including: 
  1. The classic cast; e.g., "(Shape)," which uses RTTI to make sure the cast is correct. This will throw a ClassCastException if you’ve performed a bad cast. 
  2. The Class object representing the type of your object. The Class object can be queried for useful runtime information. 
  In C++, the classic cast "(Shape)" does not perform RTTI. It simply tells the compiler to treat the object as the new type. In Java, which does perform the type check, this cast is often called a "type-safe downcast." The reason for the term "downcast" is the historical arrangement of the class hierarchy diagram. If casting a Circle to a Shape is an upcast, then casting a Shape to a Circle is a downcast. However, because it knows that a Circle is also a Shape, the compiler freely allows an upcast assignment, without requiring any explicit cast syntax. The compiler cannot know, given a Shape, what that Shape actually is—it could be exactly a Shape, or it could be a subtype of Shape, such as a Circle, Square, Triangle or some other type. At compile time, the compiler only sees a Shape. Thus, it won’t allow you to perform a downcast assignment without using an explicit cast, to tell it that you have extra information that allows you to know that it is a particular type (the compiler will check to see if that downcast is reasonable, so it won’t let you downcast to a type that’s not actually a subclass). 
  There’s a third form of RTTI in Java. This is the keyword instanceof, which tells you if an object is an instance of a particular type. It returns a boolean so you use it in the form of a question, like this: 
  if(x instanceof Dog) ((Dog)x).bark(); 
  The if statement checks to see if the object x belongs to the class Dog before casting x to a Dog. It’s important to use instanceof before a downcast when you don’t have other information that tells you the type of the object; otherwise, you’ll end up with a ClassCastException. 
  Ordinarily, you might be hunting for one type (triangles to turn purple, for example), but you can easily tally all of the objects by using instanceof. For example, suppose you have a family of classes to describe Pets (and their people, a feature which will come in handy in a later example). Each Individual in the hierarchy has an id and an optional name. Although the classes that follow inherit from Individual, there are some complexities in the Individual class, so that code will be shown and explained in the Containers in Depth chapter. As you can see, it’s not really necessary to see the code for Individual at this point—you only need to know that you can create it with or without a name, and that each Individual has a method id( ) that returns a unique identifier (created by counting each object). There’s also a toString( ) method; if you don’t provide a name for an Individual, toString( ) only produces the simple type name. 
  Here is the class hierarchy that inherits from Individual: 
  Next, we need a way to randomly create different types of pets, and for convenience, to create arrays and Lists of pets. To allow this tool to evolve through several different implementations, we’ll define it as an abstract class: 
  The abstract getTypes( ) method defers to a derived class to get the List of Class objects (this is a variation of the Template Method design pattern). Notice that the type of class is specified to be "anything derived from Pet," so that newlnstance( ) produces a Pet without requiring a cast. randomPet( ) randomly indexes into the List and uses the selected Class object to generate a new instance of that class with Class.newlnstance( ). The createArray( ) method uses randomPet( ) to fill an array, and arrayList( ) uses createArray( ) in turn. 
  You can get two kinds of exceptions when calling newlnstance( ). You can see these handled in the catch clauses following the try block. Again, the names of the exceptions are relatively useful explanations of what went wrong (IllegalAccessException relates to a violation of the Java security mechanism, in this case if the default constructor is private). 
  When you derive a subclass of PetCreator, the only thing you need to supply is the List of the types of pet that you want to create using randomPet( ) and the other methods. The getTypes( ) method will normally just return a reference to a static List. Here’s an implementation using forName( ): 
  The loader( ) method creates the List of Class objects using Class.forName( ). This may generate a ClassNotFoundException, which makes sense since you’re passing it a String which cannot be validated at compile time. Since the Pet objects are in package typeinfo, the package name must be used when referring to the classes. 
  In order to produce a typed List of Class objects, a cast is required, which produces a compile-time warning. The loader( ) method is defined separately and then placed inside a static initialization clause because the @SuppressWarnings annotation cannot be placed directly onto the static initialization clause. To count Pets, we need a tool that keeps track of the quantities of various different types of Pets. A Map is perfect for this; the keys are the Pet type names and the values are Integers to hold the Pet quantities. This way, you can say, "How many Hamster objects are there?" We can use instanceof to count Pets: 
  In countPets( ), an array is randomly filled with Pets using a PetCreator. Then each Pet in the array is tested and counted using instanceof. There’s a rather narrow restriction on instanceof: You can compare it to a named type only, and not to a Class object. In the preceding example you might feel that it’s tedious to write out all of those instanceof expressions, and you’re right. But there is no way to cleverly automate instanceof by creating an array of Class objects and comparing it to those instead (stay tuned—you’ll see an alternative). This isn’t as great a restriction as you might think, because you’ll eventually understand that your design is probably flawed if you end up writing a lot of instanceof expressions. 
Using class literals
  If we reimplement the PetCreator using class literals, the result is cleaner in many ways: 
  In the upcoming PetCount3.java example, we need to pre-load a Map with all the Pet types (not just the ones that are to be randomly generated), so the allTypes List is necessary. The types list is the portion of allTypes (created using List.subList( )) that includes the exact pet types, so it is used for random Pet generation. 
  This time, the creation of types does not need to be surrounded by a try block since it’s evaluated at compile time and thus won’t throw any exceptions, unlike Class.forName( ). 
  We now have two implementations of PetCreator in the typeinfo.pets library. In order to provide the second one as a default implementation, we can create a Faqade that utilizes LiteralPetCreator: 
  This also provides indirection to randomPet( ), createArray( ) and arrayList( ). 
  Because PetCount.countPets( ) takes a PetCreator argument, we can easily test the LiteralPetCreator (via the above Facade): 
  The output is the same as that of PetCount.java. 
  
A dynamic instanceof
  The Class.islnstance( ) method provides a way to dynamically test the type of an object. Thus, all those tedious instanceof statements can be removed from PetCount.java: 
  In order to count all the different types of Pet, the PetCounter Map is preloaded with the types from LiteralPetCreator.allTypes. This uses the net.mindview.util.MapData class, which takes an Iterable (the allTypes List) and a constant value (zero, in this case), and fills the Map with keys taken from allTypes and values of zero). Without pre-loading the Map, you would only end up counting the types that are randomly generated, and not the base types like Pet and Cat. 
  You can see that the isInstance( ) method has eliminated the need for the instanceof expressions. In addition, this means that you can add new types of Pet simply by changing the LiteralPetCreator.types array; the rest of the program does not need modification (as it did when using the instanceof expressions). 
  The toString( ) method has been overloaded for easier-to-read output that still matches the typical output that you see when printing a Map. 
Counting recursively
  The Map in PetCount3.PetCounter was pre-loaded with all the different Pet classes. Instead of pre-loading the map, we can use Class.isAssignableFrom( ) and create a general-purpose tool that is not limited to counting Pets: 
  The count( ) method gets the Class of its argument, and uses isAssignableFrom( ) to perform a runtime check to verify that the object that you’ve passed actually belongs to the hierarchy of interest. countClass( ) first counts the exact type of the class. Then, if baseType is assignable from the superclass, countClass( ) is called recursively on the superclass. 
  As you can see from the output, both base types as well as exact types are counted. 
  Exercise 11: (2) Add Gerbil to the typeinfo.pets library and modify all the examples in this chapter to adapt to this new class. 
  Exercise 12: (3) Use TypeCounter with the CoffeeGenerator.java class in the Generics chapter. 
  Exercise 13: (3) Use TypeCounter with the RegisteredFactories.java example in this chapter. 
