  To understand how RTTI works in Java, you must first know how type information is represented at run time. This is accomplished through a special kind of object called the Class object, which contains information about the class. In fact, the Class object is used to create all of the "regular" objects of your class. Java performs its RTTI using the Class object, even if you’re doing something like a cast. The class Class also has a number of other ways you can use RTTI. 
  There’s one Class object for each class that is part of your program. That is, each time you write and compile a new class, a single Class object is also created (and stored, appropriately enough, in an identically named .class file). To make an object of that class, the Java Virtual Machine (JVM) that’s executing your program uses a subsystem called a class loader. 
  The class loader subsystem can actually comprise a chain of class loaders, but there’s only one primordial class loader, which is part of the JVM implementation. The primordial class loader loads so-called trusted classes, including Java API classes, typically from the local disk. It’s usually not necessary to have additional class loaders in the chain, but if you have special needs (such as loading classes in a special way to support Web server applications, or downloading classes across a network), then you have a way to hook in additional class loaders. 
  All classes are loaded into the JVM dynamically, upon the first use of a class. This happens when the program makes the first reference to a static member of that class. It turns out that the constructor is also a static method of a class, even though the static keyword is not used for a constructor. Therefore, creating a new object of that class using the new operator also counts as a reference to a static member of the class. 
  Thus, a Java program isn’t completely loaded before it begins, but instead pieces of it are loaded when necessary. This is different from many traditional languages. Dynamic loading enables behavior that is difficult or impossible to duplicate in a statically loaded language like C++. 
  The class loader first checks to see if the Class object for that type is loaded. If not, the default class loader finds the .class file with that name (an add-on class loader might, for example, look for the bytecodes in a database instead). As the bytes for the class are loaded, they are verified to ensure that they have not been corrupted and that they do not comprise bad Java code (this is one of the lines of defense for security in Java). 
  Once the Class object for that type is in memory, it is used to create all objects of that type. Here’s a program to prove it: 
  Each of the classes Candy, Gum, and Cookie has a static clause that is executed as the class is loaded for the first time. Information will be printed to tell you when loading occurs for that class. In main( ), the object creations are spread out between print statements to help detect the time of loading. 
  You can see from the output that each Class object is loaded only when it’s needed, and the static initialization is performed upon class loading. 
  A particularly interesting line is: 
  Class.forName("Gum"); 
  All Class objects belong to the class Class. A Class object is like any other object, so you can get and manipulate a reference to it (that’s what the loader does). One of the ways to get a reference to the Class object is the static forName( ) method, which takes a String containing the textual name (watch the spelling and capitalization!) of the particular class you want a reference for. It returns a Class reference, which is being ignored here; the call to forName( ) is being made for its side effect, which is to load the class Gum if it isn’t already loaded. In the process of loading, Gum’s static clause is executed. 
  In the preceding example, if Class.forName( ) fails because it can’t find the class you’re trying to load, it will throw a ClassNotFoundException. Here, we simply report the problem and move on, but in more sophisticated programs, you might try to fix the problem inside the exception handler. 
  Anytime you want to use type information at run time, you must first get a reference to the appropriate Class object. Class.forName( ) is one convenient way to do this, because you don’t need an object of that type in order to get the Class reference. However, if you already have an object of the type you’re interested in, you can fetch the Class reference by calling a method that’s part of the Object root class: getClass( ). This returns the Class reference representing the actual type of the object. Class has many interesting methods; here are a few of them: 
  FancyToy inherits from Toy and implements the interfaces HasBatteries, Waterproof, and Shoots. In main( ), a Class reference is created and initialized to the FancyToy Class using forName( ) inside an appropriate try block. Notice that you must use the fully qualified name (including the package name) in the string that you pass to forName( ). 
  printInfo( ) uses getName( ) to produce the fully qualified class name, and getSimpleName( ) and getCanonicalName( ) (introduced in Java SE5) to produce the name without the package, and the fully qualified name, respectively. As its name implies, islnterface( ) tells you whether this Class object represents an interface. Thus, with the Class object you can find out just about everything you want to know about a type. 
  The Class.getlnterfaces( ) method called in main( ) returns an array of Class objects representing the interfaces that are contained in the Class object of interest. 
  If you have a Class object, you can also ask it for its direct base class using getSuperclass( ). This returns a Class reference that you can further query. Thus you can discover an object’s entire class hierarchy at run time. 
  The newlnstance( ) method of Class is a way to implement a "virtual constructor," which allows you to say, "I don’t know exactly what type you are, but create yourself properly anyway." In the preceding example, up is just a Class reference with no further type information known at compile time. And when you create a new instance, you get back an Object reference. But that reference is pointing to a Toy object. Of course, before you can send any messages other than those accepted by Object, you must investigate it a bit and do some casting. In addition, the class that’s being created with newlnstance( ) must have a default constructor. Later in this chapter, you’ll see how to dynamically create objects of classes using any constructor, with the Java reflection API. 
  Exercise 1: (1) In ToyTest.java, comment out Toy’s default constructor and explain what happens. 
  Exercise 2: (2) Incorporate a new kind of interface into ToyTest.java and verify that it is detected and displayed properly. 
  Exercise 3: (2) Add Rhomboid to Shapes.java. Create a Rhomboid, upcast it to a Shape, then downcast it back to a Rhomboid. Try downcasting to a Circle and see what happens. 
  Exercise 4: (2) Modify the previous exercise so that it uses instanceof to check the type before performing the downcast. 
  Exercise 5: (3) Implement a rotate(Shape) method in Shapes.java, such that it checks to see if it is rotating a Circle (and, if so, doesn’t perform the operation). 
  Exercise 6: (4) Modify Shapes.java so that it can "highlight" (set a flag in) all shapes of a particular type. The toString( ) method for each derived Shape should indicate whether that Shape is "highlighted." 
  Exercise 7: (3) Modify SweetShop.java so that each type of object creation is controlled by a command-line argument. That is, if your command line is "Java Sweetshop Candy," then only the Candy object is created. Notice how you can control which Class objects are loaded via the commandline argument. 
  Exercise 8: (5) Write a method that takes an object and recursively prints all the classes in that object’s hierarchy. 
  Exercise 9: (5) Modify the previous exercise so that it uses Class.getDeclaredFields( ) to also display information about the fields in a class. 
  Exercise 10: (3) Write a program to determine whether an array of char is a primitive type or a true Object. 
Class literals
  Java provides a second way to produce the reference to the Class object: the class literal. In the preceding program this would look like: 
  FancyToy.class; 
  which is not only simpler, but also safer since it’s checked at compile time (and thus does not need to be placed in a try block). Because it eliminates the forName( ) method call, it’s also more efficient. 
  Class literals work with regular classes as well as interfaces, arrays, and primitive types. In addition, there’s a standard field called TYPE that exists for each of the primitive wrapper classes. The TYPE field produces a reference to the Class object for the associated primitive type, such that: 
  ... is equivalent to ... boolean.class Boolean.TYPE char.class Character.TYPE byte.class Byte.TYPE short.class Short.TYPE int.class Integer.TYPE long.class Long.TYPE float.class Float.TYPE double.class Double.TYPE void.class Void.TYPE  My preference is to use the ".class" versions if you can, since they’re more consistent with regular classes. 
  It’s interesting to note that creating a reference to a Class object using ".class" doesn’t automatically initialize the Class object. There are actually three steps in preparing a class for use: 
  1. Loading, which is performed by the class loader. This finds the bytecodes (usually, but not necessarily, on your disk in your classpath) and creates a Class object from those bytecodes. 
  2. Linking. The link phase verifies the bytecodes in the class, allocates storage for static fields, and if necessary, resolves all references to other classes made by this class. 
  3. Initialization. If there’s a superclass, initialize that. Execute static initializers and static initialization blocks. 
  Initialization is delayed until the first reference to a static method (the constructor is implicitly static) or to a non-constant static field: 
  Effectively, initialization is "as lazy as possible." From the creation of the initable reference, you can see that just using the .class syntax to get a reference to the class doesn’t cause initialization. However, Class.forName( ) initializes the class immediately in order to produce the Class reference, as you can see in the creation of initable3. 
  If a static final value is a "compile-time constant," such as Initable.staticFinal, that value can be read without causing the Initable class to be initialized. Making a field static and final, however, does not guarantee this behavior: accessing Initable.staticFinal2 forces class initialization because it cannot be a compile-time constant. 
  If a static field is not final, accessing it always requires linking (to allocate storage for the field) and initialization (to initialize that storage) before it can be read, as you can see in the access to Initable2.staticNonFinal. 
Generic class references
  A Class reference points to a Class object, which manufactures instances of classes and contains all the method code for those instances. It also contains the statics for that class. So a Class reference really does indicate the exact type of what it’s pointing to: an object of the class Class. 
  However, the designers of Java SE5 saw an opportunity to make this a bit more specific by allowing you to constrain the type of Class object that the Class reference is pointing to, using the generic syntax. In the following example, both syntaxes are correct: 
  The ordinary class reference does not produce a warning. However, you can see that the ordinary class reference can be reassigned to any other Class object, whereas the generic class reference can only be assigned to its declared type. By using the generic syntax, you allow the compiler to enforce extra type checking. 
  What if you’d like to loosen the constraint a little? Initially, it seems like you ought to be able to do something like: 
  Class<Number> genericNumberClass = int.class; 
  This would seem to make sense because Integer is inherited from Number. But this doesn’t work, because the Integer Class object is not a subclass of the Number Class    object (this may seem like a subtle distinction; we’ll look into it more deeply in the Generics chapter). 
  To loosen the constraints when using generic Class references, I employ the wildcard, which is part of Java generics. The wildcard symbol is ‘?’, and it indicates "anything." So we can add wildcards to the ordinary Class reference in the above example and produce the same results: 
  In Java SE5, Class<?> is preferred over plain Class, even though they are equivalent and the plain Class, as you saw, doesn’t produce a compiler warning. The benefit of Class<?> is that it indicates that you aren’t just using a non-specific class reference by accident, or out of ignorance. You chose the non-specific version. 
  In order to create a Class reference that is constrained to a type or any subtype, you combine the wildcard with the extends keyword to create a bound. So instead of just saying Class<Number>, you say: 
  The reason for adding the generic syntax to Class references is only to provide compile-time type checking, so that if you do something wrong you find out about it a little sooner. You can’t actually go astray with ordinary Class references, but if you make a mistake you won’t find out until run time, which can be inconvenient. 
  Here’s an example that uses the generic class syntax. It stores a class reference, and later produces a List filled with objects that it generates using newlnstance( ): 
  Notice that this class must assume that any type that it works with has a default constructor (one without arguments), and you’ll get an exception if that isn’t the case. The compiler does not issue any warnings for this program. 
  An interesting thing happens when you use the generic syntax for Class objects: newlnstance( ) will return the exact type of the object, rather than just a basic Object as you saw in ToyTest.java. This is somewhat limited: 
  If you get the superclass, the compiler will only allow you to say that the superclass reference is "some class that is a superclass of FancyToy" as seen in the expression Class <? super FancyToy >. It will not accept a declaration of Class<Toy>. This seems a bit strange because getSuperclass( ) returns the base class (not interface) and the compiler knows what that class is at compile time—in this case, Toy.class, not just "some superclass of FancyToy." In any event, because of the vagueness, the return value of up.newlnstance( ) is not a precise type, but just an Object. 
New cast syntax
  Java SE5 also adds a casting syntax for use with Class references, which is the cast( ) method: 
  The cast( ) method takes the argument object and casts it to the type of the Class reference. Of course, if you look at the above code it seems like a lot of extra work compared to the last line in main( ), which does the same thing. 
  The new casting syntax is useful for situations where you can’t just use an ordinary cast. This usually happens when you’re writing generic code (which you’ll learn about in the Generics chapter), and you’ve stored a Class reference that you want to use to cast with at a later time. It turns out to be a rare thing—I found only one instance where cast( ) was used in the entire Java SE5 library (it was in com.sun.mirror.util.DeclarationFilter). 
  Another new feature had no usage in the Java SE5 library: Class.asSubclass( ). This allows you to cast the class object to a more specific type. 
