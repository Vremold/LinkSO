  Proxy is one of the basic design patterns. It is an object that you insert in place of the "real" object in order to provide additional or different operations—these usually involve communication with a "real" object, so a proxy typically acts as a go-between. Here’s a trivial example to show the structure of a proxy: 
  Because consumer( ) accepts an Interface, it can’t know if it’s getting a RealObject or a SimpleProxy, because both implement Interface. But the SimpleProxy inserted between the client and the RealObject performs operations and then calls the identical method on a RealObject. 
  A proxy can be helpful anytime you’d like to separate extra operations into a different place than the "real object," and especially when you want to easily change from not using the extra operations to using them, and vice versa (the point of design patterns is to encapsulate change—so you need to be changing things in order to justify the pattern). For example, what if you wanted to track calls to the methods in the RealObject, or to measure the overhead of such calls? This is not code you want to have incorporated in your application, so a proxy allows you to add and remove it easily. 
  Java’s dynamic proxy takes the idea of a proxy one step further, by both creating the proxy object dynamically and handling calls to the proxied methods dynamically. All calls made on a dynamic proxy are redirected to a single invocation handler, which has the job of discovering what the call is and deciding what to do about it. Here’s SimpleProxyDemo.java rewritten to use a dynamic proxy: 
  You create a dynamic proxy by calling the static method Proxy.newProxyInstance( ), which requires a class loader (you can generally just hand it a class loader from an object that has already been loaded), a list of interfaces (not classes or abstract classes) that you wish the proxy to implement, and an implementation of the interface InvocationHandler. The dynamic proxy will redirect all calls to the invocation handler, so the constructor for the invocation handler is usually given the reference to the "real" object so that it can forward requests once it performs its intermediary task. 
  The invoke( ) method is handed the proxy object, in case you need to distinguish where the request came from—but in many cases you won’t care. However, be careful when calling methods on the proxy inside invoke( ), because calls through the interface are redirected through the proxy. 
  In general you will perform the proxied operation and then use Method.invoke( ) to forward the request to the proxied object, passing the necessary arguments. This may initially seem limiting, as if you can only perform generic operations. However, you can filter for certain method calls, while passing others through: 
  Here, we are just looking for method names, but you could also be looking for other aspects of the method signature, and you could even search for particular argument values. 
  The dynamic proxy is not a tool that you’ll use every day, but it can solve certain types of problems very nicely. You can learn more about Proxy and other design patterns in Thinking in Patterns (see www.MindView.net) and Design Patterns, by Erich Gamma et al. (Addison- Wesley, 1995). 
  Exercise 21: (3) Modify SimpleProxyDemo.java so that it measures method-call times. 
  Exercise 22: (3) Modify SimpleDynamicProxy.java so that it measures method-call times. 
  Exercise 23: (3) Inside invoke( ) in SimpleDynamicProxy.java, try to print the proxy argument and explain what happens. 
  Project:2 Write a system using dynamic proxies to implement transactions, where the proxy performs a commit if the proxied call is successful (doesn’t throw any exceptions) and a rollback if it fails. Your commit and rollback should work on an external text file, which is outside the control of Java exceptions. You will have to pay attention to the atomicity of operations. 
