  Processing annotations can become complex. The example above is a relatively simple annotation processor and only interprets one annotation, but still requires a fair amount of complexity to make it work. To prevent the complexity from scaling up badly when you have more annotations and more processors, the mirror API provides classes to support the Visitor design pattern. Visitor is one of the classic design patterns from the book Design Patterns by Gamma et al., and you can also find a more a detailed explanation in Thinking in Patterns. 
  A Visitor traverses a data structure or collection of objects, performing an operation on each one. The data structure need not be ordered, and the operation that you perform on each object will be specific to its type. This decouples the operations from the objects themselves, meaning that you can add new operations without adding methods to the class definitions. 
  This makes it useful for processing annotations, because a Java class can be thought of as a collection of objects such as TypeDeclarations, FieldDeclarations, MethodDeclarations, and so on. When you use the apt tool with the Visitor pattern, you provide a Visitor class which has a method for handling each type of declaration that you visit. Thus you can implement appropriate behavior for annotations on methods, classes, fields and so on. 
  Here is the SQL table generator again, this time using a factory and a processor that makes use of the Visitor pattern: 
  The output is identical to the previous DBTable example. 
  The processor and the visitor are inner classes in this example. Note that the process( ) method only adds the visitor class and initializes the SQL string. 
  Both parameters of getDeclarationScanner( ) are visitors; the first is used before each declaration is visited and the second is used afterwards. This processor only needs the pre- visit visitor, so NO_OP is given as the second parameter. This is a static field in the DeclarationVisitor interface, which is a DeclarationVisitor that doesnâ€™t do anything. 
  TableCreationVisitor extends SimpleDeclarationVisitor, overriding the two methods visitClassDeclaration( ) and visitFieldDeclaration( ). The    SimpleDeclarationVisitor is an adapter that implements all of the methods on the Declaration Visitor interface, so you can concentrate on the ones you need. In visitClassDeclaration( ), the ClassDeclaration object is checked for the DBTable annotation, and if it is there, the first part of the SQL creation String is initialized. In visitFieldDeclaration( ), the field declaration is queried for its field annotations and the information is extracted in much the same way as it was in the original example, earlier in the chapter. 
  This may seem like a more complicated way of doing things, but it produces a more scalable solution. If the complexity of your annotation processor increases, then writing your own standalone processor as in the earlier example would soon become quite complicated. 
  Exercise 3: (2) Add support for more SQL types to TableCreationProcessorFactory.java. 
