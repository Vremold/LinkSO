  Unit testing is the practice of creating one or more tests for each method in a class, in order to regularly test the portions of a class for correct behavior. The most popular tool used for unit testing in Java is called JUnit; at the time of this writing, JUnit was in the process of 6 being updated to JUnit version 4, in order to incorporate annotations. One of the main problems with preannotation versions of JUnit is the amount of "ceremony" necessary in order to set up and run JUnit tests. This has been reduced over time, but annotations will move testing closer to "the simplest unit testing system that can possibly work." 
  With pre-annotation versions of JUnit, you must create a separate class to hold your unit tests. With annotations we can include the unit tests inside the class to be tested, and thus reduce the time and trouble of unit testing to a minimum. This approach has the additional benefit of being able to test private methods as easily as public ones. 
  Since this example test framework is annotation-based, it’s called @Unit. The most basic form of testing, and one which you will probably use much of the time, only needs the @Test annotation to indicate which methods should be tested. One option is for the test methods to take no arguments and return a boolean to indicate success or failure. You can use any name you like for test methods. Also, @Unit test methods can have any access that you’d like, including private. 
  7 To use @Unit, all you need to do is import net.mindview.atunit, mark the appropriate methods and fields with @Unit test tags (which you’ll learn about in the following examples) and then have your build system run @Unit on the resulting class. Here’s a simple example: 
  Classes to be @Unit tested must be placed in packages. 
  The @Test annotation preceding the methods methodOneTest( ), m2( ), m3( ), failureTest( ) and anotherDisappointment( ) tells @Unit to run these methods as unit tests. It will also ensure that those methods take no arguments and return a boolean or void. Your only responsibility when you write the unit test is to determine whether the test succeeds or fails and returns true or false, respectively (for methods that return boolean). 
  If you’re familiar with JUnit, you’ll also note @Unit’s more informative output—you can see the test that’s currently being run so the output from that test is more useful, and at the end it tells you the classes and tests that caused failures. 
  You’re not forced to embed test methods inside your classes, if that doesn’t work for you. The easiest way to create non-embedded tests is with inheritance: 
  This example also demonstrates the value of flexible naming (in contrast to JUnit’s requirement to start all your tests with the word "test"). Here, @Test methods that are directly testing another method are given the name of that method starting with an underscore (I’m not suggesting that this is an ideal style, just showing a possibility). 
  You can also use composition to create non-embedded tests: 
  A new member testObject is created for each test, since an AtUnitComposition object is created for each test. 
  There are no special "assert" methods as there are in JUnit, but the second form of the @Test method allows you to return void (or boolean, if you still want to return true or false in this case). To test for success, you can use Java assert statements. Java assertions normally have to be enabled with the -ea flag on the java command line, but @Unit automatically enables them. To indicate failure, you can even use an exception. One of the @Unit design goals is to require as little additional syntax as possible, and Java’s assert and exceptions are all that is necessary to report errors. A failed assert or an exception that emerges from the test method is treated as a failed test, but @Unit does not halt in this case—it continues until all the tests are run. Here’s an example: 
  Here’s an example using non-embedded tests with assertions, performing some simple tests of java.util.HashSet: 
  The inheritance approach would seem to be simpler, in the absence of other constraints. 
  Exercise 4: (3) Verify that a new testObject is created before each test. 
  Exercise 5: (1) Modify the above example to use the inheritance approach. 
  Exercise 6: (1) Test LinkedList using the approach shown in HashSetTest.j ava. 
  Exercise 7: (1) Modify the previous exercise to use the inheritance approach. 
  For each unit test, @Unit creates an object of the class under test using the default constructor. The test is called for that object, and then the object is discarded to prevent side effects from leaking into other unit tests. This relies on the default constructor to create the objects. If you don’t have a default constructor or you need more sophisticated construction for objects, you create a static method to build the object and attach the @TestObjectCreate annotation, like this: 
  The @TestObjectCreate method must be static and must return an object of the type that you’re testing—the @Unit program will ensure that this is true. 
  Sometimes you need additional fields to support your unit testing. The @TestProperty annotation can be used to tag fields that are only used for unit testing (so that they can be removed before you deliver the product to the client). Here’s an example that reads values from a String that is broken up using the String.split( ) method. This input is used to produce test objects: 
  @TestProperty can also be used to tag methods that may be used during testing, but are not tests themselves. 
  Note that this program relies on the execution order of the tests, which is in general not a good practice. 
  If your test object creation performs initialization that requires later cleanup, you can optionally add a static @TestObjectCleanup method to perform cleanup when you are finished with the test object. In this example, @TestObjectCreate opens a file to create each test object, so the file must be closed before the test object is discarded: 
  You can see from the output that the cleanup method is automatically run after each test. 
Using @Unit with generics
  Generics pose a special problem, because you can’t "test generically." You must test for a specific type parameter or set of parameters. The solution is simple: Inherit a test class from a specified version of the generic class. 
  Here’s a simple implementation of a stack: 
  To test a String version, inherit a test class from StackL<String>: 
  The only potential drawback to inheritance is that you lose the ability to access private methods in the class under test. If this is a problem, you can either make the method in question protected, or add a non-private @TestProperty method that calls the private method (the @TestProperty method will then be stripped out of the production code by the AtUnitRemover tool that is shown later in this chapter). 
  Exercise 8: (2) Create a class with a private method and add a non-private @TestProperty method as described above. Call this method in your test code. 
  Exercise 9: (2) Write basic @Unit tests for HashMap. 
  Exercise 10: (2) Select an example from elsewhere in the book and add @Unit tests. 
No “suites” necessary
  One of the big advantages of @Unit over JUnit is that "suites" are unnecessary. In JUnit, you need to somehow tell the unit testing tool what it is that you need to test, and this requires the introduction of "suites" to group tests together so that JUnit can find them and run the tests. 
  @Unit simply searches for class files containing the appropriate annotations, and then executes the @Test methods. Much of my goal with the @Unit testing system is to make it incredibly transparent, so that people can begin using it by simply adding @Test methods, with no other special code or knowledge like that required by JUnit and many other unit testing frameworks. It’s hard enough to write tests without adding any new hurdles, so @Unit tries to make it trivial. This way, you’re more likely to actually write the tests. 
  
Implementing @Unit
  First, we need to define all the annotation types. These are simple tags, and have no fields. The @Test tag was defined at the beginning of the chapter, and here are the rest of the annotations: 
  All the tests have RUNTIME retention because the @Unit system must discover the tests in compiled code. 
  To implement the system that runs the tests, we use reflection to extract the annotations. The program uses this information to decide how to build the test objects and run tests on them. Because of annotations this is surprisingly small and straightforward: 
  AtUnit.java uses the ProcessFiles tool in net.mindview.util. The AtUnit class implements ProcessFiles.Strategy, which comprises the method process( ). This way, an instance of AtUnit can be passed to the ProcessFiles constructor. The second constructor argument tells ProcessFiles to look for all files that have "class" extensions. 
  If you do not provide a command-line argument, the program will traverse the current directory tree. You may also provide multiple arguments which can be either class files (with or without the .class extension) or directories. Since @Unit will automatically find the 8 testable classes and methods, no "suite" mechanism is necessary. 
  One of the problems that AtUnit.java must solve when it discovers class files is that the actual qualified class name (including package) is not evident from the class file name. In order to discover this information, the class file must be analyzed, which is not trivial, but not impossible, either.9 So the first thing that happens when a .class file is found is that it is opened and its binary data is read and handed to ClassNameFinder.thisClass( ). Here, we are moving into the realm of "bytecode engineering," because we are actually analyzing the contents of a class file: 
  Although it’s not possible to go into full detail here, each class file follows a particular format and I’ve tried to use meaningful field names for the pieces of data that are picked out of the ByteArraylnputStream; you can also see the size of each piece by the length of the read performed on the input stream. For example, the first 32 bits of any class file is always the 10 "magic number" hex 0xcafebabe, and the next two shorts are version information. The constant pool contains the constants for the program and so is of variable size; the next short tells how big it is, so that an appropriate-sized array can be allocated. Each entry in the constant pool may be a fixed-size or variablesized value, so we must examine the tag that begins each one to find out what to do with it—that’s the switch statement. Here, we are not trying to accurately analyze all the data in the class file, but merely to step through and store the pieces of interest, so you’ll notice that a fair amount of data is discarded. Information   it had something to do with fantasizing about a woman in a coffee shop. 
  about classes is stored in the classNameTable and the offsetTable. After the constant pool is read, the this_class information can be found, which is an index into the offsetTable, which produces an index into the classNameTable, which produces the class name. 
  Back in AtUnit.java, process( ) now has the class name and can look to see if it contains a ‘.’, which means it’s in a package. Unpackaged classes are ignored. If a class is in a package, the standard class loader is used to load the class with Class.forName( ). Now the class can be analyzed for @Unit annotations. 
  We only need to look for three things: @Test methods, which are stored in a TestMethods list, and whether there’s an @TestObjectCreate and @TestObjectCleanup method. These are discovered through the associated method calls that you see in the code, which look for the annotations. 
  If any @Test methods have been found, the name of the class is printed so the viewer can see what’s happening, and then each test is executed. This means printing the method name, then calling createTestObject( ), which will use the @TestObjectCreate method if one exists, or will fall back to the default constructor otherwise. Once the test object has been created, the test method is invoked upon that object. If the test returns a boolean, the result is captured. If not, we assume success if there is no exception (which would happen in the case of a failed assert or any other kind of exception). If an exception is thrown, the exception information is printed to show the cause. If any failure occurs, the failure count is increased and the class name and method are added to failedTests so these can be reported at the end of the run. 
  Exercise 11: (5) Add an @TestNote annotation to @Unit, so that the accompanying note is simply displayed during testing. 
Removing test code
  Although in many projects it won’t make a difference if you leave the test code in the deliverable (especially if you make all the test methods private, which you can do if you like), in some cases you will want to strip out the test code either to keep the deliverable small or so that it is not exposed to the client. 
  This requires more sophisticated bytecode engineering than it is comfortable to do by hand. 11 However, the open-source Javassist library brings bytecode engineering into the realm of the possible. The following program takes an optional -r flag as its first argument; if you provide the flag it will remove the @Test annotations, and if you do not it will simply display the @Test annotations. ProcessFiles is also used here to traverse the files and directories of your choosing: 
  The ClassPool is a kind of picture of all the classes in the system that you are modifying. It guarantees the consistency of all the modified classes. You must get each CtClass from the ClassPool, similar to the way the class loader and Class.forName( ) load classes into the JVM. 
  The CtClass contains the bytecodes for a class object and allows you to produce information about the class and to manipulate the code in the class. Here, we call    getDeclaredMethods( ) (just like Java’s reflection mechanism) and get a MethodInfo object from each CtMethod object. From this, we can look at the annotations. If a method has an annotation in the net.mindview.atunit package, that method is removed. 
  If the class has been modified, the original class file is overwritten with the new class. 
  12 At the time of this writing, the "remove" functionality in Javassist had recently been added, and we discovered that removing @TestProperty fields turns out to be more complex than removing methods. Because there may be static initialization operations that refer to those fields, you cannot simply remove them. So the above version of the code only removes @Unit methods. However, you should check the Javassist Web site for updates; field removal should eventually be possible. In the meantime, note that the external testing method shown in AtUnitExternalTest.java allows all tests to be removed by simply deleting the class file created by the test code. 
