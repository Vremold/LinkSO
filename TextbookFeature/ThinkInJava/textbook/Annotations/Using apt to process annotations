  The annotation processing tool apt is Sun’s first version of a tool that aids the processing of annotations. Because it is an early incarnation, the tool is still a little primitive, but it has features which can make your life easier. 
  Like javac, apt is designed to be run on Java source files rather than compiled classes. By default, apt compiles the source files when it has finished processing them. This is useful if you are automatically creating new source files as part of your build process. In fact, apt checks newly created source files for annotations and compiles them all in the same pass. 
  When your annotation processor creates a new source file, that file is itself checked for annotations in a new round (as it is referred to in the documentation) of processing. The tool will continue round after round of processing until no more source files are being created. It then compiles all of the source files. 
  Each annotation you write will need its own processor, but the apt tool can easily group several annotation processors together. It allows you to specify multiple classes to be processed, which is a lot easier than having to iterate through File classes yourself. You can also add listeners to receive notification of when an annotation processing round is complete. 
  At the time of this writing, apt is not available as an Ant task (see the supplement at http://MindView.net/Books/BetterJava), but it can obviously be run as an external task from Ant in the meantime. In order to compile the annotation processors in this section you must have tools.jar in your classpath; this library also contains the the com.sun.mirror.* interfaces. 
  apt works by using an AnnotationProcessorFactory to create the right kind of annotation processor for each annotation it finds. When you run apt, you specify either a factory class or a classpath where it can find the factories it needs. If you don’t do this, apt will embark on an arcane discovery process, the details of which can be found in the Developing an Annotation Processor section of Sun’s documentation. 
  When you create an annotation processor for use with apt, you can’t use the reflection 4 features in Java because you are working with source code, not compiled classes. The mirror API5 solves this problem by allowing you to view methods, fields and types in uncompiled source code. 
  Here is an annotation that can be used to extract the public methods from a class and turn them into an interface: 
  classes. 
  The RetentionPolicy is SOURCE because there is no point in keeping this annotation in the class file after we have extracted the interface from the class. The following class provides a public method which can become part of a useful interface: 
  The Multiplier class (which only works with positive integers) has a multiply( ) method which calls the private add( ) method numerous times to perform multiplication. The add( ) method is not public, so is not part of the interface. The annotation is given the value of IMultiplier, which is the name of the interface to create. 
  Now you need a processor to do the extraction: 
  The process( ) method is where all the work is done. The MethodDeclaration class and its getModifiers( ) method are used to identify the public methods (but ignore the static ones) of the class being processed. If any are found, they are stored in an ArrayList and used to create the methods of a new interface definition in a .java file. 
  Notice that an AnnotationProcessorEnvironment object is passed into the constructor. You can query this object for all of the types (class definitions) that the apt tool is processing, and you can use it to get a Messager object and a Filer object. The Messager enables you to report messages to the user, e.g., any errors that might have occurred with the processing and where they are in the source code. The Filer is a kind of PrintWriter through which you will create new files. The main reason that you use a Filer object, rather than a plain PrintWriter, is that it allows apt to keep track of any new files that you create, so it can check them for annotations and compile them if it needs to. 
  You will also see that the method createSourceFile( ) opens an ordinary output stream with the correct name for your Java class or interface. There isn’t any support for creating Java language constructs, so you have to generate the Java source code using the somewhat primitive print( ) and println( ) methods. This means making sure that your brackets match up and that your code is syntactically correct. 
  process( ) is called by the apt tool, which needs a factory to provide the right processor: 
  There are only three methods on the AnnotationProcessorFactory interface. As you can see, the one which provides the processor is getProcessorFor( ), which takes a Set of type declarations (the Java classes that the apt tool is being run against), and the AnnotationProcessorEnvironment object, which you have already seen being passed through to the processor. The other two methods, supportedAnnotationTypes( ) and supportedOptions( ), are there so you can check that you have processors for all of the annotations found by apt and that you support all options specified at the command prompt. The getProcessorFor( ) method is particularly important because if you don’t return the full class name of your annotation type in the String collection, apt will warn you that there is no relevant processor and exit without doing anything. 
  The processor and factory are in the package annotations, so for the directory structure above, the command line is embedded in the ‘Exec’ comment tag at the beginning of InterfaceExtractorProcessor.java. This tells apt to use the factory class defined above and process the file Multiplier.java. The -s option specifies that any new files must be created in the directory annotations. The generated IMultiplier.java file, as you might guess by looking at the println( ) statements in the processor above, looks like this: 
  package annotations; public interface IMultiplier { public int multiply (int x, int y); } 
  This file will also be compiled by apt, so you will see the file IMultiplier.class in the same directory. 
  Exercise 2: (3) Add support for division to the interface extractor. 
