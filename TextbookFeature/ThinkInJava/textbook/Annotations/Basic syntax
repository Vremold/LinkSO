  In the example below, the method testExecute( ) is annotated with @Test. This doesn’t do anything by itself, but the compiler will ensure that you have a definition for the @Test annotation in your build path. As you will see later in the chapter, you can create a tool which runs this method for you via reflection. 
  Annotated methods are no different from other methods. The @Test annotation in this example can be used in combination with any of the modifiers like public or static or void. Syntactically, annotations are used in much the same way as modifiers. 
Defining annotations
  Here is the definition of the annotation above. You can see that annotation definitions look a lot like interface definitions. In fact, they compile to class files like any other Java interface: 
  Apart from the @ symbol, the definition of @Test is much like that of an empty interface. An annotation definition also requires the meta-annotations @Target and (@Retention. @Target defines where you can apply this annotation (a method or a field, for example). @Retention defines whether the annotations are available in the source code (SOURCE), in the class files (CLASS), or at run time (RUNTIME). 
  Annotations will usually contain elements to specify values in your annotations. A program or tool can use these parameters when processing your annotations. Elements look like interface methods, except that you can declare default values. 
  An annotation without any elements, such as @Test above, is called a marker annotation. 
  Here is a simple annotation that tracks use cases in a project. Programmers annotate each method or set of methods which fulfill the requirements of a particular use case. A project manager can get an idea of project progress by counting the implemented use cases, and developers maintaining the project can easily find use cases if they need to update or debug business rules within the system. 
  Notice that id and description resemble method declarations. Because id is type-checked by the compiler, it is a reliable way of linking a tracking database to the use case document and the source code. The element description has a default value which is picked up by the annotation processor if no value is specified when a method is annotated. 
  Here is a class with three methods annotated as use cases: 
  The values of the annotation elements are expressed as name-value pairs in parentheses after the @UseCase declaration. The annotation for encryptPassword( ) is not passed a value for the description element here, so the default value defined in the ©interface UseCase will appear when the class is run through an annotation processor. 
  You could imagine using a system like this in order to "sketch" out your system, and then filling in the functionality as you build it. 
Meta-annotations
  There are currently only three standard annotations (described earlier) and four meta- annotations defined in the Java language. The meta-annotations are for annotating annotations: 
  @Target Where this annotation can be applied. The possible ElementType arguments are: CONSTRUCTOR: Constructor declaration FIELD: Field declaration (includes enum constants) LOCAL_VARIABLE: Local variable declaration METHOD: Method declaration    PACKAGE: Package declaration PARAMETER: Parameter declaration TYPE: Class, interface (including annotation type), or enum declaration @Retention How long the annotation information is kept. The possible RetentionPolicy arguments are: SOURCE: Annotations are discarded by the compiler. CLASS: Annotations are available in the class file by the compiler but can be discarded by the VM. RUNTIME: Annotations are retained by the VM at run time, so they may be read reflectively. @Documented Include this annotation in the Javadocs. @Inherited Allow subclasses to inherit parent annotations. 
  Most of the time, you will be defining your own annotations and writing your own processors to deal with them. 
