  In java.util, you’ll find the Arrays class, which holds a set of static utility methods for arrays. There are six basic methods: equals( ), to compare two arrays for equality (and a deepEquals( ) for multidimensional arrays); fill( ), which you’ve seen earlier in this chapter; sort( ), to sort an array; binarySearch( ), to find an element in a sorted array; toString( ), to produce a String representation for an array; and hashCode( ), to produce the hash value of an array (you’ll learn what this means in the Containers in Depth chapter). All of these methods are overloaded for all the primitive types and Objects. In addition, Arrays.asList( ) takes any sequence or array and turns it into a List container—this method was covered in the Holding Your Objects chapter. 
  Before discussing the Arrays methods, there’s one other useful method that isn’t part of Arrays. 
Copying an array
  The Java standard library provides a static method, System.arraycopy( ), which can copy arrays far more quickly than if you use a for loop to perform the copy by hand. System.arraycopyC ) is overloaded to handle all types. Here’s an example that manipulates arrays of int: 
  The arguments to arraycopy( ) are the source array, the offset into the source array from whence to start copying, the destination array, the offset into the destination array where the copying begins, and the number of elements to copy. Naturally, any violation of the array boundaries will cause an exception. 
  The example shows that both primitive arrays and object arrays can be copied. However, if you copy arrays of objects, then only the references get copied—there’s no duplication of the objects themselves. This is called a shallow copy (see the online supplements for this book for more details). 
  System.arraycopy( ) will not perform autoboxing or autounboxing—the two arrays must be of exactly the same type. 
  Exercise 18: (3) Create and fill an array of BerylliumSphere. Copy this array to a new array and show that it’s a shallow copy. 
  
Comparing arrays
  Arrays provides the equals( ) method to compare entire arrays for equality, which is overloaded for all the primitives and for Object. To be equal, the arrays must have the same number of elements, and each element must be equivalent to each corresponding element in the other array, using the equals( ) for each element. (For primitives, that primitive’s wrapper class equals( ) is used; for example, Integer.equals( ) for int.) For example: 
  Originally, a1 and a2 are exactly equal, so the output is "true," but then one of the elements is changed, which makes the result "false." In the last case, all the elements of s1 point to the same object, but s2 has five unique objects. However, array equality is based on contents (via Object.equals( )), so the result is "true." 
  Exercise 19: (2) Create a class with an int field that’s initialized from a constructor argument. Create two arrays of these objects, using identical initialization values for each array, and show that Arrays.equals( ) says that they are unequal. Add an equals( ) method to your class to fix the problem. 
  Exercise 20: (4) Demonstrate deepEquals( ) for multidimensional arrays. 
  
Array element comparisons
  Sorting must perform comparisons based on the actual type of the object. Of course, one approach is to write a different sorting method for every different type, but such code is not reusable for new types. 
  A primary goal of programming design is to "separate things that change from things that stay the same," and here, the code that stays the same is the general sort algorithm, but the thing that changes from one use to the next is the way objects are compared. So instead of placing the comparison code into many different sort routines, the Strategy design pattern is 2 used. With a Strategy, the part of the code that varies is encapsulated inside a separate class (the Strategy object). You hand a Strategy object to the code that’s always the same, which uses the Strategy to fulfill its algorithm. That way, you can make different objects to express different ways of comparison and feed them to the same sorting code. 
  Java has two ways to provide comparison functionality. The first is with the "natural" comparison method that is imparted to a class by implementing the java.lang.Comparable interface. This is a very simple interface with a single method, compareTo( ). This method takes another object of the same type as an argument and produces a negative value if the current object is less than the argument, zero if the argument is equal, and a positive value if the current object is greater than the argument. 
  Here’s a class that implements Comparable and demonstrates the comparability by using the Java standard library method Arrays.sort( ): 
  When you define the comparison method, you are responsible for deciding what it means to compare one of your objects to another. Here, only the i values are used in the comparison, and the j values are ignored. 
  The generator( ) method produces an object that implements the Generator interface by creating an anonymous inner class. This builds CompType objects by initializing them with random values. In main( ), the generator is used to fill an array of CompType, which is then sorted. If Comparable hadn’t been implemented, then you’d get a ClassCastException at run time when you tried to call sort( ). This is because sort( ) casts its argument to Comparable. 
  Now suppose someone hands you a class that doesn’t implement Comparable, or hands you this class that does implement Comparable, but you decide you don’t like the way it works and would rather have a different comparison method for the type. To solve the problem, you create a separate class that implements an interface called Comparator (briefly introduced in the Holding Your Objects chapter). This is an example of the Strategy design pattern. It has two methods, compare( ) and equals( ). However, you don’t have to implement equals( ) except for special performance needs, because anytime you create a class, it is implicitly inherited from Object, which has an equals( ). So you can just use the default Object equals( ) and satisfy the contract imposed by the interface. 
  The Collections class (which we’ll look at more in the next chapter) contains a method reverseOrder( ) that produces a Comparator to reverse the natural sorting order. This can be applied to CompType: 
  You can also write your own Comparator. This one compares CompType objects based on their j values rather than their i values: 
  Exercise 21: (3) Try to sort an array of the objects in Exercise 18. Implement Comparable to fix the problem. Now create a Comparator to sort the objects into reverse order. 
  
Sorting an array
  With the built-in sorting methods, you can sort any array of primitives, or any array of objects that either implements Comparable or has an associated Comparator.3 Here’s an example that generates random String objects and sorts them: 
  One thing you’ll notice about the output in the String sorting algorithm is that it’s lexicographic, so it puts all the words starting with uppercase letters first, followed by all the words starting with lowercase letters. (Telephone books are typically sorted this way.) If you want to group the words together regardless of case, use String.CASE_INSENSITIVE_ORDER as shown in the last call to sort( ) in the above example. 
  The sorting algorithm that’s used in the Java standard library is designed to be optimal for the particular type you’re sorting—a Quicksort for primitives, and a stable merge sort for objects. You don’t need to worry about performance unless your profiler points you to the sorting process as a bottleneck. 
  
Searching a sorted array
  Once an array is sorted, you can perform a fast search for a particular item by using Arrays.binarySearch( ). However, if you try to use binarySearchC ) on an unsorted array the results will be unpredictable. The following example uses a RandomGenerator.Integer to fill an array, and then uses the same generator to produce search values: 
  In the while loop, random values are generated as search items until one of them is found. 
  Arrays.binarySearch( ) produces a value greater than or equal to zero if the search item is found. Otherwise, it produces a negative value representing the place that the element should be inserted if you are maintaining the sorted array by hand. The value produced is  -(insertion point) - 1 
  The insertion point is the index of the first element greater than the key, or a.size( ), if all elements in the array are less than the specified key. 
  If an array contains duplicate elements, there is no guarantee which of those duplicates will be found. The search algorithm is not designed to support duplicate elements, but rather to tolerate them. If you need a sorted list of non-duplicated elements, use a TreeSet (to maintain sorted order) or LinkedHashSet (to maintain insertion order). These classes take care of all the details for you automatically. Only in cases of performance bottlenecks should you replace one of these classes with a hand-maintained array. 
  If you sort an object array using a Comparator (primitive arrays do not allow sorting with a Comparator), you must include that same Comparator when you perform a binarySearch( ) (using the overloaded version of binarySearch( )). For example, the StringSorting.java program can be modified to perform a search: 
  The Comparator must be passed to the overloaded binarySearch( ) as the third argument. In this example, success is guaranteed because the search item is selected from the array itself. 
  Exercise 22: (2) Show that the results of performing a binarySearch( ) on an unsorted array are unpredictable. 
  Exercise 23: (2) Create an array of Integer, fill it with random int values (using autoboxing), and sort it into reverse order using a Comparator. 
  Exercise 24: (3) Show that the class from Exercise 19 can be searched. 
