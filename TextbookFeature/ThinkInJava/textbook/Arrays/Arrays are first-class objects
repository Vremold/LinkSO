  Regardless of what type of array you’re working with, the array identifier is actually a reference to a true object that’s created on the heap. This is the object that holds the references to the other objects, and it can be created either implicitly, as part of the array initialization syntax, or explicitly with a new expression. Part of the array object (in fact, the only field or method you can access) is the read-only length member that tells you how many elements can be stored in that array object. The ‘[ ]’ syntax is the only other access that you have to the array object. 
  The following example summarizes the various ways that an array can be initialized, and how the array references can be assigned to different array objects. It also shows that arrays of    objects and arrays of primitives are almost identical in their use. The only difference is that arrays of objects hold references, but arrays of primitives hold the primitive values directly. 
  The array a is an uninitialized local variable, and the compiler prevents you from doing anything with this reference until you’ve properly initialized it. The array b is initialized to point to an array of BerylliumSphere references, but no actual BerylliumSphere objects are ever placed in that array. However, you can still ask what the size of the array is, since b is pointing to a legitimate object. This brings up a slight drawback: You can’t find out how many elements are actually in the array, since length tells you only how many elements can be placed in the array; that is, the size of the array object, not the number of elements it actually holds. However, when an array object is created, its references are automatically initialized to null, so you can see whether a particular array slot has an object in it by checking to see whether it’s null. Similarly, an array of primitives is automatically initialized to zero for numeric types, (char)o for char, and false for boolean. 
  Array c shows the creation of the array object followed by the assignment of BerylliumSphere objects to all the slots in the array. Array d shows the "aggregate initialization" syntax that causes the array object to be created (implicitly with new on the heap, just like for array c) and initialized with BerylliumSphere objects, all in one statement. 
  The next array initialization can be thought of as a "dynamic aggregate initialization." The aggregate initialization used by d must be used at the point of d’s definition, but with the second syntax you can create and initialize an array object anywhere. For example, suppose hide( ) is a method that takes an array of BerylliumSphere objects. You could call it by saying: 
  hide(d); 
  but you can also dynamically create the array you want to pass as the argument: 
  hide(new BerylliumSphere[]{ new BerylliumSphere(), new BerylliumSphere() }); 
  In many situations this syntax provides a more convenient way to write code. 
  The expression: 
  a = d; 
  shows how you can take a reference that’s attached to one array object and assign it to another array object, just as you can do with any other type of object reference. Now both a and d are pointing to the same array object on the heap. 
  The second part of ArrayOptions.java shows that primitive arrays work just like object arrays except that primitive arrays hold the primitive values directly. 
  Exercise 1: (2) Create a method that takes an array of BerylliumSphere as an argument. Call the method, creating the argument dynamically. Demonstrate that ordinary aggregate array initialization doesn’t work in this case. Discover the only situations where ordinary aggregate array initialization works, and where dynamic aggregate initialization is redundant. 
