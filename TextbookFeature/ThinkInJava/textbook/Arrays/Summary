  In this chapter, you’ve seen that Java provides reasonable support for fixedsized, low-level arrays. This sort of array emphasizes performance over flexibility, just like the C and C++ array model. In the initial version of Java, fixed-sized, low-level arrays were absolutely necessary, not only because the Java designers chose to include primitive types (also for performance), but because the support for containers in that version was very minimal. Thus, in early versions of Java, it was always reasonable to choose arrays. 
  In subsequent versions of Java, container support improved significantly, and now containers tend to outshine arrays in all ways except for performance, and even then, the performance of containers has been significantly improved. As stated in other places in this book, performance problems are usually never where you imagine them to be, anyway. 
  With the addition of autoboxing and generics, holding primitives in containers has become effortless, which further encourages you to replace low-level arrays with containers. Because generics produce type-safe containers, arrays no long have an advantage on that front, either. 
  As noted in this chapter and as you’ll see when you try to use them, generics are fairly hostile towards arrays. Often, even when you can get generics and arrays to work together in some form (as you’ll see in the next chapter), you’ll still end up with "unchecked" warnings during compilation. 
  On several occasions I have been told directly by Java language designers that I should be using containers instead of arrays, when we were discussing particular examples (I was using arrays to demonstrate specific techniques and so I did not have that option). 
  All of these issues indicate that you should "prefer containers to arrays" when programming in recent versions of Java. Only when it’s proven that performance is an issue (and that switching to an array will make a difference) should you refactor to arrays. 
  This is a rather bold statement, but some languages have no fixed-sized, lowlevel arrays at all. They only have resizable containers with significantly more functionality than C/C++/Java- style arrays. Python,4 for example, has a list type that uses basic array syntax, but has much greater functionality—you can even inherit from it: 
  #: arrays/PythonLists.py  aList = [1, 2, 3, 4, 5] print type(aList) # <type ‘list’> print aList # [1, 2, 3, 4, 5] print aList[4] # 5 Basic list indexing aList.append(6) # lists can be resized aList += [7, 8] # Add a list to a list print aList # [1, 2, 3, 4, 5, 6, 7, 8] aSlice = aList[2:4] print aSlice # [3, 4] 
  class MyList(list): # Inherit from list # Define a method, ‘this’ pointer is explicit: def getReversed(self): reversed = self[:] # Copy list using slices reversed.reverse() # Built-in list method return reversed        list2 = MyList(aList) # No ‘new’ needed for object creation print type(list2) # <class ‘__main__.MyList’> print list2.getReversed() # [8, 7, 6, 5, 4, 3, 2, 1] #:~ 
  Basic Python syntax was introduced in the previous chapter. Here, a list is created by simply surrounding a comma-separated sequence of objects with square brackets. The result is an object with a runtime type of list (the output of the print statements is shown as comments on the same line). The result of printing a list is the same as that of using Arrays.toString() in Java. 
  Creating a sub-sequence of a list is accomplished with "slicing," by placing the’:’ operator inside the index operation. The list type has many more builtin operations. 
  MyList is a class definition; the base classes are placed within the parentheses. Inside the class, def statements produce methods, and the first argument to the method is automatically the equivalent of this in Java, except that in Python it’s explicit and the identifier self is used by convention (it’s not a keyword). Notice how the constructor is automatically inherited. 
  Although everything in Python really is an object (including integral and floating point types), you still have an escape hatch in that you can optimize performance-critical portions of your code by writing extensions in C, C++ or a special tool called Pyrex, which is designed to easily speed up your code. This way you can have object purity without being prevented from performance improvements. 
  The PHP language5 goes even further by having only a single array type, which acts as both an int-indexed array and an associative array (a Map). 
  It’s interesting to speculate, after this many years of Java evolution, whether the designers would put primitives and low-level arrays in the language if they were to start over again. If these were left out, it would be possible to make a truly pure object-oriented language (despite claims, Java is not a pure 0 0 language, precisely because of the low-level detritus). The initial argument for efficiency always seems compelling, but over time we have seen an evolution away from this idea and towards the use of higher-level components like containers. Add to this the fact that if containers can be built into the core language as they are in some languages, then the compiler has a much better opportunity to optimize. 
  Green-fields speculation aside, we are certainly stuck with arrays, and you will see them when reading code. Containers, however, are almost always a better choice. 
  Exercise 25: (3) Rewrite PythonLists.py in Java. 
  Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from www.MindView.net. 
