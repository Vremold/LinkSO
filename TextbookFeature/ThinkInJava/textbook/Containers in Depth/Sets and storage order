  The Set examples in the Holding Your Objects chapter provide a good introduction to the operations that can be performed with basic Sets. However, those examples conveniently use predefined Java types such as Integer and String, which were designed to be usable inside containers. When creating your own types, be aware that a Set needs a way to maintain storage order. How the storage order is maintained varies from one implementation of Set to another. Thus, different Set implementations not only have different behaviors, they have different requirements for the type of object that you can put into a particular Set: 
  Set (interface) Each element that you add to the Set must be unique; otherwise, the Set doesn’t add the duplicate element. Elements added to a Set must at least define equals( ) to establish object uniqueness. Set has exactly the same interface as Collection. The Set interface does not guarantee that it will maintain its elements in any particular order. HashSet* For Sets where fast lookup time is important. Elements must also define hashCode( ). TreeSet An ordered Set backed by a tree. This way, you can extract an ordered sequence from a Set. Elements must also implement the Comparable interface. LinkedHashSet Has the lookup speed of a HashSet, but internally maintains the order in which you add the elements (the insertion order) using a linked list. Thus, when you iterate through the Set, the results appear in insertion order. Elements must also define hashCode( ). 
  The asterisk on HashSet indicates that, in the absence of other constraints, this should be your default choice because it is optimized for speed. 
  Defining hashCode( ) will be described later in this chapter. You must create an equals( ) for both hashed and tree storage, but the hashCode( ) is necessary only if the class will be placed in a HashSet (which is likely, since that should generally be your first choice as a Set implementation) or LinkedHashSet. However, for good programming style, you should always override hashCode( ) when you override equals( ). 
  This example demonstrates the methods that must be defined in order to successfully use a type with a particular Set implementation: 
  In order to prove which methods are necessary for a particular Set and at the same time to avoid code duplication, three classes are created. The base class, SetType, simply stores an int, and produces it via toString( ). Since all classes stored in Sets must have an equals( ), that method is also placed in the base class. Equality is based on the value of the int i. 
  HashType inherits from SetType and adds the hashCode( ) method necessary for an object to be placed in a hashed implementation of a Set. 
  The Comparable interface, implemented by TreeType, is necessary if an object is to be used in any kind of sorted container, such as a SortedSet (of which TreeSet is the only implementation). In compareTo( ), note that I did not use the "simple and obvious" form return i-i2. Although this is a common programming error, it would only work properly if i and i2 were "unsigned" ints (if Java had an "unsigned" keyword, which it does not). It breaks for Java’s signed int, which is not big enough to represent the difference of two signed ints. If i is a large positive integer and j is a large negative integer, i-j will overflow and return a negative value, which will not work. 
  You’ll usually want the compareTo( ) method to produce a natural ordering that is consistent with the equals( ) method. If equals( ) produces true for a particular comparison, then compareTo( ) should produce a zero result for that comparison, and if equals ( ) produces false for a comparison then compareTo( ) should produce a nonzero result for that comparison. 
  In TypesForSets, both fill( ) and test( ) are defined using generics, in order to prevent code duplication. To verify the behavior of a Set, test( ) calls fill( ) on the test set three times, attempting to introduce duplicate objects. The fill( ) method takes a Set of any type, and a Class object of the same type. It uses the Class object to discover the constructor that takes an int argument, and calls that constructor to add elements to the Set. 
  From the output, you can see that the HashSet keeps the elements in some mysterious order (which will be made clear later in the chapter), the LinkedHashSet keeps the elements in the order in which they were inserted, and the TreeSet maintains the elements in sorted order (because of the way that compareTo( ) is implemented, this happens to be descending order). 
  If we try to use types that don’t properly support the necessary operations with Sets that require those operations, things go very wrong. Placing a SetType or TreeType object, which doesn’t include a redefined hashCode( ) method, into any hashed implementations results in duplicate values, so the primary contract of the Set is violated. This is rather disturbing because there’s not even a runtime error. However, the default hashCode( ) is legitimate and so this is legal behavior, even if it’s incorrect. The only reliable way to ensure the correctness of such a program is to incorporate unit tests into your build system (see the supplement at http://MindView.net/Books/BetterJava for more information). 
  If you try to use a type that doesn’t implement Comparable in a TreeSet, you get a more definitive result: An exception is thrown when the TreeSet attempts to use the object as a Comparable. 
SortedSet
  The elements in a SortedSet are guaranteed to be in sorted order, which allows additional functionality to be provided with the following methods that are in the SortedSet interface: Comparator comparator( ): Produces the Comparator used for this Set, or null for natural ordering. 
  Object first( ): Produces the lowest element. 
  Object last( ): Produces the highest element. 
  SortedSet subSet(fromElement, toElement): Produces a view of this Set with elements from fromElement, inclusive, to toElement, exclusive. 
  SortedSet headSet(toElement): Produces a view of this Set with elements less than toElement. 
  SortedSet tailSet(fromElement): Produces a view of this Set with elements greater than or equal to fromElement. 
  Here’s a simple demonstration: 
  Note that SortedSet means "sorted according to the comparison function of the object," not "insertion order." Insertion order can be preserved using a LinkedHashSet. 
  Exercise 9: (2) Use RandomGenerator.String to fill a TreeSet, but use alphabetic ordering. Print the TreeSet to verify the sort order. 
  Exercise 10: (7) Using a LinkedList as your underlying implementation, define your own SortedSet. 
