  As you learned in the Holding Your Objects chapter, the basic idea of a map (also called an associative array) is that it maintains key-value associations (pairs) so you can look up a value using a key. The standard Java library contains different basic implementations of Maps: HashMap, TreeMap, LinkedHashMap, WeakHashMap, ConcurrentHashMap, and IdentityHashMap. They all have the same basic Map interface, but they differ in behaviors including efficiency, the order in which the pairs are held and presented, how long the objects are held by the map, how the map works in multithreaded programs, and how key equality is determined. The number of implementations of the Map interface should tell you something about the importance of this tool. 
  So you can gain a deeper understanding of Maps, it is helpful to look at how an associative array is constructed. Here is an extremely simple implementation: 
  The essential methods in an associative array are put( ) and get( ), but for easy display, toString( ) has been overridden to print the key-value pairs. To show that it works, main( ) loads an AssociativeArray with pairs of strings and prints the resulting map, followed by a get( ) of one of the values. 
  To use the get( ) method, you pass in the key that you want it to look up, and it produces the associated value as the result or returns null if it can’t be found. The get( ) method is using what is possibly the least efficient approach imaginable to locate the value: starting at the top of the array and using equals( ) to compare keys. But the point here is simplicity, not efficiency. 
  So the above version is instructive, but it isn’t very efficient and it has a fixed size, which is inflexible. Fortunately, the Maps in java.util do not have these problems and can be substituted into the above example. 
  Exercise 12: (1) Substitute a HashMap, a TreeMap and a LinkedHashMap in AssociativeArray .Java’s main( ). 
  Exercise 13: (4) Use AssociativeArray Java to create a wordoccurrence counter, mapping String to Integer. Using the net.mindview.util.TextFile utility in this book, open a text file and break up the words in that file using whitespace and punctuation, and count the occurrence of the words in that file. 
Performance
  Performance is a fundamental issue for maps, and it’s very slow to use a linear search in get( ) when hunting for a key. This is where HashMap speeds things up. Instead of a slow search for the key, it uses a special value called a hash code. The hash code is a way to take some information in the object in question and turn it into a "relatively unique" int for that object. hashCode( ) is a method in the root class Object, so all Java objects can produce a hash code. A HashMap takes the hashCode( ) of the object and uses it to quickly hunt for 6 the key. This results in a dramatic performance improvement. 
  Here are the basic Map implementations. The asterisk on HashMap indicates that, in the absence of other constraints, this should be your default choice because it is optimized for   Map and customizing it to your particular types to avoid delays due to casting to and from Objects. To reach even higher levels of performance, speed enthusiasts can use Donald Knuth’s The Art of Computer Programming, Volume 3: Sorting and Searching, Second Edition, to replace overflow bucket lists with arrays that have two additional benefits: they can be optimized for disk storage characteristics and they can save most of the time of creating and garbage collecting individual records. 
  speed. The other implementations emphasize other characteristics, and are thus not as fast as HashMap. 
  HashMap* Implementation based on a hash table. (Use this class instead of Hashtable.) Provides constant-time performance for inserting and locating pairs. Performance can be adjusted via constructors that allow you to set the capacity and load factor of the hash table. LinkedHashMap Like a HashMap, but when you iterate through it, you get the pairs in insertion order, or in least-recently-used (LRU) order. Only slightly slower than a HashMap, except when iterating, where it is faster due to the linked list used to maintain the internal ordering. TreeMap Implementation based on a red-black tree. When you view the keys or the pairs, they will be in sorted order (determined by Comparable or Comparator). The point of a TreeMap is that you get the results in sorted order. TreeMap is the only Map with the subMap( ) method, which allows you to return a portion of the tree. WeakHashMap A map of weak keys that allow objects referred to by the map to be released; designed to solve certain types of problems. If no references to a particular key are held outside the map, that key may be garbage collected. ConcurrentHashMap A thread-safe Map which does not involve synchronization locking. This is discussed in the Concurrency chapter. IdentityHashMap A hash map that uses == instead of equals( ) to compare keys. Only for solving special types of problems; not for general use. 
  Hashing is the most commonly used way to store elements in a map. Later, you’ll learn how hashing works. 
  The requirements for the keys used in a Map are the same as for the elements in a Set. You saw these demonstrated in TypesForSets.java. Any key must have an equals( ) method. If the key is used in a hashed Map, it must also have a proper hashCode( ). If the key is used in a TreeMap, it must implement Comparable. 
  The following example shows the operations available through the Map interface, using the previously defined CountingMapData test data set: 
  The printKeys( ) method demonstrates how to produce a Collection view of a Map. The keySet( ) method produces a Set backed by the keys in the Map. Because of improved printing support in Java SE5, you can simply print the result of the values( ) method, which produces a Collection containing all the values in the Map. (Note that keys must be unique, but values may contain duplicates.) Since these Collections are backed by the Map, any changes in a Collection will be reflected in the associated Map. 
  The rest of the program provides simple examples of each Map operation and tests each basic type of Map. 
  Exercise 14: (3) Show that java.util.Properties works in the above program. 
  
SortedMap
  If you have a SortedMap (of which TreeMap is the only one available), the keys are guaranteed to be in sorted order, which allows additional functionality to be provided with these methods in the SortedMap interface: 
  Comparator comparator( ): Produces the comparator used for this Map, or null for natural ordering. 
  T firstKey( ): Produces the lowest key. 
  T lastKey( ): Produces the highest key. 
  SortedMap subMap(fromKey, toKey): Produces a view of this Map with keys from fromKey, inclusive, to toKey, exclusive. 
  SortedMap headMap(toKey): Produces a view of this Map with keys less than toKey. 
  SortedMap tailMap(fromKey): Produces a view of this Map with keys greater than or equal to fromKey. 
  Here’s an example that’s similar to SortedSetDemo.java and shows this additional behavior of TreeMaps: 
  Here, the pairs are stored by key-sorted order. Because there is a sense of order in the TreeMap, the concept of "location" makes sense, so you can have first and last elements and submaps. 
LinkedHashMap
  The LinkedHashMap hashes everything for speed, but also produces the pairs in insertion order during a traversal (System.out.println( ) iterates through the map, so you see the results of traversal). In addition, a LinkedHashMap can be configured in the constructor to use a leastrecently- used (LRU) algorithm based on accesses, so elements that haven’t been accessed (and thus are candidates for removal) appear at the front of the list. This allows easy creation of programs that do periodic cleanup in order to save space. Here’s a simple example showing both features: 
  You can see from the output that the pairs are indeed traversed in insertion order, even for the LRU version. However, after the first six items (only) are accessed in the LRU version, the last three items move to the front of the list. Then, when "o" is accessed again, it moves to the back of the list. 
