  Although the problem of printing containers is solved, filling containers suffers from the same deficiency as java.utiLArrays. Just as with Arrays, there is a companion class called Collections containing static utility methods, including one called fill( ). Like the Arrays version, this fill( ) just duplicates a single object reference throughout the container. In addition, it only works for List objects, but the resulting list can be passed to a constructor or to an addAll( ) method: 
  This example shows two ways to fill a Collection with references to a single object. The first, Collections.nCopies( ), creates a List which is passed to the constructor; this fills the ArrayList. 
  The toString( ) method in StringAddress calls Object.toString( ), which produces the class name followed by the unsigned hexadecimal representation of the hash code of the object (generated by the hashCode( ) method). You can see from the output that all the references are set to the same object, and this is also true after the second method, Collections.fill( ), is called. The fill( ) method is made even less useful by the fact that it can only replace elements that are already in the List and will not add new elements. 
A Generator solution
  Virtually all Collection subtypes have a constructor that takes another Collection object, from which it can fill the new container. In order to easily create test data, then, all we need to do is build a class that takes constructor arguments of a Generator (defined in the Generics chapter and further explored in the Arrays chapter) and a quantity value: 
  This uses the Generator to put as many objects into the container as you need. The resulting container can then be passed to the constructor for any Collection, and that constructor will copy the data into itself. The addAll( ) method that’s part of every Collection subtype can also be used to populate an existing Collection. 
  The generic convenience method reduces the amount of typing necessary when using the class. 
  1 CollectionData is an example of the Adapter design pattern; it adapts a Generator to the constructor for a Collection. 
  Here’s an example that initializes a LinkedHashSet: 
  The elements are in the same order in which they are inserted because a LinkedHashSet maintains a linked list holding the insertion order. 
  All the generators defined in the Arrays chapter are now available via the CollectionData adapter. Here’s an example that uses two of them: 
  The String length produced by RandomGenerator.String is controlled by the constructor argument. 
Map generators
  We can take the same approach for a Map, but that requires a Pair class since a pair of objects (one key and one value) must be produced by each call to a Generator’s next( ) in order to populate a Map: 
  The key and value fields are made public and final so that Pair becomes a read-only Data Transfer Object (or Messenger). 
  The Map adapter can now use various combinations of Generators, Iterables, and constant values to fill Map initialization objects: 
  This gives you a choice of using a single Generator<Pair<K,V> >, two separate Generators, one Generator and a constant value, an Iterable (which includes any Collection) and a Generator, or an Iterable and a single value. The generic convenience methods reduce the amount of typing necessary when creating a MapData object. 
  Here’s an example using MapData. The Letters Generator also implements Iterable by producing an Iterator; this way, it can be used to test the MapData.map( ) methods that work with an Iterable: 
  This example also uses the generators from the Arrays chapter. 
  You can create any generated data set for Maps or Collections using these tools, and then initialize a Map or Collection using the constructor or the Map.putAll( ) or Collection.addAll( ) methods. 
Using Abstract classes
  An alternative approach to the problem of producing test data for containers is to create custom Collection and Map implementations. Each java.util container has its own Abstract class that provides a partial implementation of that container, so all you must do is implement the necessary methods in order to produce the desired container. If the resulting container is read-only, as it typically is for test data, the number of methods you need to provide is minimized. 
  Although it isn’t particularly necessary in this case, the following solution also provides the opportunity to demonstrate another design pattern: the Flyweight. You use a flyweight when the ordinary solution requires too many objects, or when producing normal objects takes up too much space. The Flyweight pattern externalizes part of the object so that, instead of everything in the object being contained within the object, some or all of the object is looked up in a more efficient external table (or produced through some other calculation that saves space). 
  An important point of this example is to demonstrate how relatively simple it is to create a custom Map and Collection by inheriting from the java.util.Abstract classes. In order to create a read-only Map, you inherit from AbstractMap and implement entrySet( ). In order to create a readonly Set, you inherit from AbstractSet and implement iterator( ) and size( ). 
  2 The data set in this example is a Map of the countries of the world and their capitals. The capitals( ) method produces a Map of countries and capitals. The names( ) method produces a List of the country names. In both cases you can get a partial listing by providing an int argument indicating the desired size: 
  The two-dimensional array of String DATA is public so it can be used elsewhere. FlyweightMap must implement the entrySet( ) method, which requires both a custom Set implementation and a custom Map.Entry class. Here’s part of the flyweight: each Map.Entry object simply stores its index, rather than the actual key and value. When you call getKey( ) or getValue( ), it uses the index to return the appropriate DATA element. The EntrySet ensures that its size is no bigger than DATA. 
  You can see the other part of the flyweight implemented in EntrySet.Iterator. Instead of creating a Map.Entry object for each data pair in DATA, there’s only one Map.Entry object per iterator. The Entry object is used as a window into the data; it only contains an index into the static array of strings. Every time you call next( ) for the iterator, the index in the Entry is incremented so that it points to the next element pair, and then that 3 Iterator’s single Entry object is returned from next( ). 
  The select( ) method produces a FlyweightMap containing an EntrySet of the desired size, and this is used in the overloaded capitals( ) and names( ) methods that you see demonstrated in main( ). 
  were to simply copy the entire Map.Entry then this approach would cause a problem. 
  For some tests, the limited size of Countries is a problem. We can take the same approach to produce initialized custom containers that have a data set of any size. This class is a List that can be any size, and is (effectively) preinitialized with Integer data: 
  To create a read-only List from an AbstractList, you must implement get( ) and size( ). Again, a flyweight solution is used: get( ) produces the value when you ask for it, so the List doesn’t actually have to be populated. 
  Here is a Map containing pre-initialized unique Integers and Strings; it can also be any size: 
  Here, a LinkedHashSet is used instead of creating a custom Set class, so the flyweight is not fully implemented. 
  Exercise 1: (1) Create a List (try both ArrayList and LinkedList) and fill it using Countries. Sort the list and print it, then apply Collections.shuffle( ) to the list repeatedly, printing it each time so that you can see how the shuffle( ) method randomizes the list differently each time. 
  Exercise 2: (2) Produce a Map and a Set containing all the countries that begin with ‘A’. 
  Exercise 3: (1) Using Countries, fill a Set multiple times with the same data and verify that the Set ends up with only one of each instance. Try this with HashSet, LinkedHashSet, and TreeSet. 
  Exercise 4: (2) Create a Collection initializer that opens a file and breaks it into words using TextFile, and then uses the words as the source of data for the resulting Collection. Demonstrate that it works. 
  Exercise 5: (3) Modify CountingMapData.java to fully implement the flyweight by adding a custom EntrySet class like the one in Countries.java. 
