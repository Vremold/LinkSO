  The examples in the Holding Your Objects chapter used predefined classes as HashMap keys. These examples worked because the predefined classes had all the necessary wiring to make them behave correctly as keys. A common pitfall occurs when you create your own classes to be used as keys for HashMaps, and forget to put in the necessary wiring. For example, consider a weather predicting system that matches Groundhog objects to Prediction objects. This seems fairly straightforward—you create the two classes, and use Groundhog as the key and Prediction as the value: 
  Each Groundhog is given an identity number, so you can look up a Prediction in the HashMap by saying, "Give me the Prediction associated with Groundhog #3." The Prediction class contains a boolean that is initialized using java.util.random( ) and a toString( ) that interprets the result for you. The detectSpring( ) method is created using reflection to instantiate and use the class Groundhog or any class derived from Groundhog. This will come in handy later, when we inherit a new type of Groundhog to solve the problem demonstrated here. 
  A HashMap is filled with Groundhogs and their associated Predictions. The HashMap is printed so that you can see it has been filled. Then a Groundhog with an identity number of 3 is used as a key to look up the prediction for Groundhog #3 (which you can see must be in the Map). 
  It seems simple enough, but it doesn’t work—it can’t find the key for #3. The problem is that Groundhog is automatically inherited from the common root class Object, and it is Object’s hashCode( ) method that is used to generate the hash code for each object. By default this just uses the address of its object. Thus, the first instance of Groundhog(3) does not produce a hash code equal to the hash code for the second instance of Groundhog(3) that we tried to use as a lookup. 
  You might think that all you need to do is write an appropriate override for hashCode( ). But it still won’t work until you’ve done one more thing: override the equals( ) that is also part of Object.equals( ) is used by the HashMap when trying to determine if your key is equal to any of the keys in the table. 
  A proper equals( ) must satisfy the following five conditions: 
  1. Reflexive: For any x, x.equals(x) should return true. 
  2. Symmetric: For any x and y, x.equals(y) should return true if and only if y.equals(x) returns true. 
  3. Transitive: For any x, y, and z, if x.equals(y) returns true and y.equals(z) returns true, then x.equals(z) should return true. 
  4. Consistent: For any x and y, multiple invocations of x.equals(y) consistently return true or consistently return false, provided no information used in equals comparisons on the object is modified. 
  5. For any non-null x, x.equals(null) should return false. 
  Again, the default Object.equals( ) simply compares object addresses, so one Groundhog(3) is not equal to another Groundhog(3). Thus, to use your own classes as keys in a HashMap, you must override both hashCode( ) and equals( ), as shown in the following solution to the groundhog problem: 
  Groundhog2.hashCode( ) returns the groundhog number as a hash value. In this example, the programmer is responsible for ensuring that no two groundhogs exist with the same ID number. The hashCode( ) is not required to return a unique identifier (something you’ll understand better later in this chapter), but the equals( ) method must strictly determine whether two objects are equivalent. Here, equals( ) is based on the groundhog number, so if two Groundhog2 objects exist as keys in the HashMap with the same groundhog number, it will fail. 
  Even though it appears that the equals( ) method is only checking to see whether the argument is an instance of Groundhog2 (using the instanceof keyword, which was explained in the Type Information chapter), the instanceof actually quietly does a second sanity check to see if the object is null, since instanceof produces false if the left-hand argument is null. Assuming it’s the correct type and not null, the comparison is based on the actual number values in each object. You can see from the output that the behavior is now correct. 
  When creating your own class to use in a HashSet, you must pay attention to the same issues as when it is used as a key in a HashMap. 
Understanding hashCodeQ
  The preceding example is only a start toward solving the problem correctly. It shows that if you do not override hashCode( ) and equals( ) for your key, the hashed data structure (HashSet, HashMap, LinkedHashSet, or LinkedHashMap) probably won’t deal with your key properly. For a good solution to the problem, however, you need to understand what’s going on inside the hashed data structure. 
  First, consider the motivation behind hashing: You want to look up an object using another object. But you can also accomplish this with a TreeMap, or you can even implement your    own Map. In contrast to a hashed implementation, the following example implements a Map using a pair of ArrayLists. Unlike AssociativeArray.java, this includes a full implementation of the Map interface, which accounts for the entrySet( ) method: 
  The put( ) method simply places the keys and values in corresponding ArrayLists. In accordance with the Map interface, it must return the old key or null if there was no old key. 
  Also following the specifications for Map, get( ) produces null if the key is not in the SlowMap. If the key exists, it is used to look up the numerical index indicating its location in the keys List, and this number is used as an index to produce the associated value from the values List. Notice that the type of key is Object in get( ), rather than the    parameterized type K as you might expect (and which was indeed used in AssociativeArray.java). This is a result of the injection of generics into the Java language at such a late date—if generics had been an original feature in the language, get( ) could have specified the type of its parameter. 
  The Map.entrySet( ) method must produce a set of Map.Entry objects. However, Map.Entry is an interface describing an implementationdependent structure, so if you want to make your own type of Map, you must also define an implementation of Map.Entry: 
  Here, a very simple class called MapEntry holds and retrieves the keys and values. This is used in entrySet( ) to produce a Set of key-value pairs. Notice that entrySet( ) uses a HashSet to hold the pairs, and MapEntry takes the simple approach of just using key’s hashCode( ). Although this solution is very simple, and appears to work in the trivial test in SlowMap.main( ), it is not a correct implementation because a copy of the keys and values is made. A correct implementation of entrySet( ) will provide a view into the Map, rather than a copy, and this view will allow modification of the original map (which a copy doesn’t). Exercise 16 provides the opportunity to repair the problem. 
  Note that the equals( ) method in MapEntry must check both keys and values. The meaning of the hashCode( ) method will be described shortly. The String representation of the contents of the SlowMap is automatically produced by the toString( ) method defined in AbstractMap. 
  In SlowMap.main( ), a SlowMap is loaded and then the contents are displayed. A call to get( ) shows that it works. 
  Exercise 15: (1) Repeat Exercise 13 using a SlowMap. 
  Exercise 16: (7) Apply the tests in Maps.java to SlowMap to verify that it works. Fix anything in SlowMap that doesn’t work correctly. 
  Exercise 17: (2) Implement the rest of the Map interface for SlowMap. 
  Exercise 18: (3) Using SlowMap.java for inspiration, create a SlowSet. 
Hashing for speed
  SlowMap.java shows that it’s not that hard to produce a new type of Map. But as the name suggests, a SlowMap isn’t very fast, so you probably wouldn’t use it if you had an alternative available. The problem is in the lookup of the key; the keys are not kept in any particular order, so a simple linear search is used. A linear search is the slowest way to find something. 
  The whole point of hashing is speed: Hashing allows the lookup to happen quickly. Since the bottleneck is in the speed of the key lookup, one of the solutions to the problem is to keep the keys sorted and then use Collections.binarySearch( ) to perform the lookup (an exercise will walk you through this process). 
  Hashing goes further by saying that all you want to do is to store the key somewhere in a way that it can be found quickly. The fastest structure in which to store a group of elements is an array, so that will be used for representing the key information (note that I said "key information," and not the key itself). But because an array cannot be resized, we have a problem: We want to store an indeterminate number of values in the Map, but if the number of keys is fixed by the array size, how can this be? 
  The answer is that the array will not hold the keys. From the key object, a number will be derived that will index into the array. This number is the hash code, produced by the hashCode( ) method (in computer science parlance, this is the hash function) defined in Object and presumably overridden by your class. 
  To solve the problem of the fixed-size array, more than one key may produce the same index. That is, there may be collisions. Because of this, it doesn’t matter how big the array is; any key object’s hash code will land somewhere in that array. 
  So the process of looking up a value starts by computing the hash code and using it to index into the array. If you could guarantee that there were no collisions (which is possible if you have a fixed number of values), then you’d have a perfect hashing junction, but that’s a special case7 In all other cases, collisions are handled by external chaining: The array doesn’t point directly to a value, but instead to a list of values. These values are searched in a linear fashion using the equals( ) method. Of course, this aspect of the search is much slower, but if the hash function is good, there will only be a few values in each slot. So instead of searching through the entire list, you quickly jump to a slot where you only have to compare a few entries to find the value. This is much faster, which is why the HashMap is so quick. 
  Knowing the basics of hashing, you can implement a simple hashed Map: 
  Because the "slots" in a hash table are often referred to as buckets, the array that represents the actual table is called buckets. To promote even distribution, the number of buckets is 8 typically a prime number. Notice that it is an array of LinkedList, which automatically provides for collisions: Each new item is simply added to the end of the list in a particular bucket. Even though Java will not let you create an array of generics, it is possible to make a reference to such an array. Here, it is convenient to upcast to such an array, to prevent extra casting later in the code. 
  For a put( ), the hashCode( ) is called for the key and the result is forced to a positive number. To fit the resulting number into the buckets array, the modulus operator is used with the size of that array. If that location is null, it means there are no elements that hash to that location, so a new LinkedList is created to hold the object that just did hash to that location. However, the normal process is to look through the list to see if there are duplicates, and if there are, the old value is put into oldValue and the new value replaces the old. The found flag keeps track of whether an old key-value pair was found and, if not, the new pair is appended to the end of the list. 
  The get( ) calculates the index into the buckets array in the same fashion as put( ) (this is important in order to guarantee that you end up in the same spot). If a LinkedList exists, it is searched for a match. 
  Note that this implementation is not meant to be tuned for performance; it is only intended to show the operations performed by a hash map. If you look at the source code for java.util.HashMap, you’ll see a tuned implementation. Also, for simplicity SimpleHashMap uses the same approach to entrySet( ) as did SlowMap, which is oversimplified and will not work for a general-purpose Map. 
  Exercise 19: (1) Repeat Exercise 13 using a SimpleHashMap. 
  Exercise 20: (3) Modify SimpleHashMap so that it reports collisions, and test this by adding the same data set twice so that you see collisions. 
  Exercise 21: (2) Modify SimpleHashMap so that it reports the number of "probes" necessary when collisions occur. That is, how many calls to next( ) must be made on the Iterators that walk the LinkedLists looking for matches? 
  Exercise 22: (4) Implement the clear( ) and remove( ) methods for SimpleHashMap. 
  Java use a power-of-two size (after extensive testing). Division or remainder is the slowest operation on a modern processor. With a power-of-two hash table length, masking can be used instead of division. Since get( ) is by far the most common operation, the % is a large part of the cost, and the power-of-two approach eliminates this (but may also affect some hashCode( ) methods). 
  Exercise 23: (3) Implement the rest of the Map interface for SimpleHashMap. Exercise 24: (5) Following the example in SimpleHashMap.java, create and test a SimpleHashSet. 
  Exercise 25: (6) Instead of using a Listlterator for each bucket, modify MapEntry so that it is a self-contained singly linked list (each MapEntry should have a forward link to the next MapEntry). Modify the rest of the code in SimpleHashMap.java so that this new approach works correctly. 
Overriding hashCode()
  Now that you understand how hashing works, writing your own hashCode( ) method will make more sense. 
  First of all, you don’t control the creation of the actual value that’s used to index into the array of buckets. That is dependent on the capacity of the particular HashMap object, and that capacity changes depending on how full the container is, and what the load factor is (this term will be described later). Thus, the value produced by your hashCode( ) will be further processed in order to create the bucket index (in SimpleHashMap, the calculation is just a modulo by the size of the bucket array). 
  The most important factor in creating a hashCode( ) is that, regardless of when hashCode( ) is called, it produces the same value for a particular object every time it is called. If you end up with an object that produces one hashCode( ) value when it is put( ) into a HashMap and another during a get( ), you won’t be able to retrieve the objects. So if your hashCode( ) depends on mutable data in the object, the user must be made aware that changing the data will produce a different key because it generates a different hashCode( ). 
  In addition, you will probably nor want to generate a hashCode( ) that is based on unique object information—in particular, the value of this makes a bad hashCode( ) because then you can’t generate a new key identical to the one used to put( ) the original key-value pair. This was the problem that occurred in SpringDetector.java, because the default implementation of hashCode( ) does use the object address. So you’ll want to use information in the object that identifies the object in a meaningful way. 
  One example can be seen in the String class. Strings have the special characteristic that if a program has several String objects that contain identical character sequences, then those String objects all map to the same memory. So it makes sense that the hashCode( ) produced by two separate instances of the String "hello" should be identical. You can see this in the following program: 
  The hashCode( ) for String is clearly based on the contents of the String. 
  So, for a hashCode( ) to be effective, it must be fast and it must be meaningful; that is, it must generate a value based on the contents of the object. Remember that this value doesn’t have to be unique—you should lean toward speed rather than uniqueness—but between hashCode( ) and equals( ), the identity of the object must be completely resolved. 
  Because the hashCode( ) is further processed before the bucket index is produced, the range of values is not important; it just needs to generate an int. 
  There’s one other factor: A good hashCode( ) should result in an even distribution of values. If the values tend to cluster, then the HashMap or HashSet will be more heavily loaded in some areas and will not be as fast as it can be with an evenly distributed hashing function. 
  In Effective Java™ Programming Language Guide (Addison-Wesley, 2001), Joshua Bloch gives a basic recipe for generating a decent hashCode( ): 
  1. Store some constant nonzero value, say 17, in an int variable called result. 
  2. For each significant field fin your object (that is, each field taken into account by the equals( ) method), calculate an int hash code c for the field: 
  Field type Calculation boolean c = ( f ? 0 : 1) byte, char, short, or c = (int)f int long c = (int)(f ^ (f>>>32)) float c = Float.floatToIntBits(f); double long l = Double.doubleToLongBits(f); c = (int)(1 ^ (l>>>32)) Object, where c = f.hashCode( ) equals( ) calls equals( ) for this field Array Apply above rules to each element  3. Combine the hash code(s) computed above: result = 37 * result + c; 
  4. Return result. 
  5. Look at the resulting hashCode( ) and make sure that equal instances have equal hash codes. 
  Here’s an example that follows these guidelines: 
  CountedString includes a String and an id that represents the number of CountedString objects that contain an identical String. The counting is accomplished in the constructor by iterating through the static ArrayList where all the Strings are stored. 
  Both hashCode( ) and equals( ) produce results based on both fields; if they were just based on the String alone or the id alone, there would be duplicate matches for distinct values. 
  In main( ), several CountedString objects are created using the same String, to show that the duplicates create unique values because of the count id. The HashMap is displayed so that you can see how it is stored internally (no discernible orders), and then each key is looked up individually to demonstrate that the lookup mechanism is working properly. 
  As a second example, consider the Individual class that was used as the base class for the typeinfo.pet library defined in the Type Information chapter. The Individual class was used in that chapter but the definition has been delayed until this chapter so you could properly understand the implementation: 
  The compareTo( ) method has a hierarchy of comparisons, so that it will produce a sequence that is sorted first by actual type, then by name if there is one, and finally falls back to creation order. Here’s an example that shows how it works: 
  Since all of these pets have names, they are sorted first by type, then by name within their type. 
  Writing a proper hashCode( ) and equals( ) for a new class can be tricky. You can find tools to help you do this in Apache’s "Jakarta Commons" project atjakarta.apache.org/commons, under "lang" (this project also has many other potentially useful libraries, and appears to be the Java community’s answer to the C++ community’s www.boost.org). 
  Exercise 26: (2) Add a char field to CountedString that is also initialized in the constructor, and modify the hashCode( ) and equals( ) methods to include the value of this char. 
  Exercise 27: (3) Modify the hashCode( ) in CountedString.java by removing the combination with id, and demonstrate that CountedString still works as a key. What is the problem with this approach? 
  Exercise 28: (4) Modify net/mindview/util/Tuple.java to make it a general-purpose class by adding hashCode( ), equals( ), and implementing Comparable for each type of Tuple. 
