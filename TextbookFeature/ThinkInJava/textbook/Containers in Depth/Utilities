  There are a number of standalone utilities for containers, expressed as static methods inside the java.util.Collections class. You’ve already seen some of these, such as addAll( ), reverseOrder( ) and binarySearch( ). Here are the others (the synchronized and unmodifiable utilities will be covered in sections that follow). In this table, generics are used when they are relevant: 
  checkedCollection( Produces a dynamically type-safe Collection<T>, Class<T> type) view of a Collection, or a specific checkedList( subtype of Collection. Use this List<T>, Class<T> type) when it’s not possible to use the checkedMap(Map<K,V>, statically checked version. Class <K> keyType, Class <V> valueType) These were shown in the Generics checkedSet(Set<T>, chapter under the heading Class<T> type) "Dynamic type safety." checkedSortedMap( SortedMap<K,V>, Class<K> keyType, Class <V> valueType) checkedSortedSet( SortedSet<T>, Class<T> type) max(Collection) Produces the maximum or min(Collection) minimum element in the argument using the natural comparison method of the objects in the Collection. max(Collection, Comparator) Produces the maximum or min(Collection, Comparator) minimum element in the Collection using the Comparator. indexOfSubList(List source, Produces starting index of the first List target) place where target appears inside source, or -1 if none occurs. lastIndexOfSubList(List Produces starting index of the last source, List target) place where target appears inside source, or -1 if none occurs. replaceAll(List<T>, Replaces all oldVal with newVal. T oldVal, T newVal) reverse(List) Reverses all the elements in place. reverseOrder( ) Returns a Comparator that reverseOrder( reverses the natural ordering of a Comparator<T>) collection of objects that implement Comparable<T>. The second version reverses the order of the supplied Comparator. 
  rotate(List, int distance) Moves all elements forward by distance, taking the ones off the end and placing them at the beginning. shuffle(List) Randomly permutes the specified shuffle(List, Random) list. The first form provides its own randomization source, or you may provide your own with the second form. sort(List<T>) Sorts the List<T> using its natural sort(List<T>, ordering. The second form allows Comparator<? super T> c) you to provide a Comparator for sorting. copy(List<? super T> dest, Copies elements from src to dest. List<? extends T> src) swap(List, int i, int j) Swaps elements at locations i and j in the List. Probably faster than what you’d write by hand. fill(List<? super T>, T x) Replaces all the elements of list with x. nCopies(int n, T x) Returns an immutable List<T> of size n whose references all point to x. disjoint(Collection, Collection) Returns true if the two collections have no elements in common. frequency(Collection, Object x) Returns the number of elements in the Collection equal to x. emptyList( ) Returns an immutable empty List, emptyMap( ) Map, or Set. These are generic, so emptySet( ) the resulting Collection will be parameterized to the desired type. singleton(T x) Produces an immutable Set<T>, singletonList(T x) List<T>, or Map<K,V> singletonMap(K key, V value) containing a single entry based on the given argument(s). list(Enumeration<T> e) Produces an ArrayList<T> containing the elements in the order in which they are returned by the (old-style) Enumeration (predecessor to the Iterator). For converting from legacy code. enumeration(Collection<T>) Produces an old-style Enumeration<T> for the argument. 
  Note that min( ) and max( ) work with Collection objects, not with Lists, so you don’t need to worry about whether the Collection should be sorted or not. (As mentioned earlier, you do need to sort( ) a List or an array before performing a binarySearch( ).)  Here’s an example showing the basic use of most of the utilities in the above table: 
  The output explains the behavior of each utility method. Note the difference in min( ) and max( ) with the String.CASE_INSENSITIVE_ORDER Comparator because of capitalization. 
Sorting and searching Lists
  Utilities to perform sorting and searching for Lists have the same names and signatures as those for sorting arrays of objects, but are static methods of Collections instead of Arrays. Here’s an example that uses the list data from Utilities.java: 
  Just as when searching and sorting with arrays, if you sort using a Comparator, you must binarySearch( ) using the same Comparator. 
  This program also demonstrates the shuffle( ) method in Collections, which randomizes the order of a List. A ListIterator is created at a particular location in the shuffled list, and used to remove the elements from that location until the end of the list. 
  Exercise 40: (5) Create a class containing two String objects and make it Comparable so that the comparison only cares about the first String. Fill an array and an ArrayList with objects of your class, using the RandomGenerator generator. Demonstrate that sorting works properly. Now make a Comparator that only cares about the second String, and demonstrate that sorting works properly. Also perform a binary search using your Comparator. 
  Exercise 41: (3) Modify the class in the previous exercise so that it will work with HashSets and as a key in HashMaps. 
  Exercise 42: (2) Modify Exercise 40 so that an alphabetic sort is used. Making a Collection or Map unmodifiable  Often it is convenient to create a read-only version of a Collection or Map. The Collections class allows you to do this by passing the original container into a method that hands back a read-only version. There are a number of variations on this method, for Collections (if you can’t treat a Collection as a more specific type), Lists, Sets, and Maps. This example shows the proper way to build read-only versions of each: 
  Calling the "unmodifiable" method for a particular type does not cause compile-time checking, but once the transformation has occurred, any calls to methods that modify the contents of a particular container will produce an UnsupportedOperationException. 
  In each case, you must fill the container with meaningful data before you make it read-only. Once it is loaded, the best approach is to replace the existing reference with the reference that is produced by the "unmodifiable" call. That way, you don’t run the risk of accidentally trying to change the contents once you’ve made it unmodifiable. On the other hand, this tool also allows you to keep a modifiable container as private within a class and to return a read-only reference to that container from a method call. So, you can change it from within the class, but everyone else can only read it. 
Synchronizing a Collection or Map
  The synchronized keyword is an important part of the subject of multithreading, a more complicated topic that will not be introduced until the Concurrency chapter. Here, I shall note only that the Collections class contains a way to automatically synchronize an entire container. The syntax is similar to the "unmodifiable" methods: 
  It is best to immediately pass the new container through the appropriate "synchronized" method, as shown above. That way, there’s no chance of accidentally exposing the unsynchronized version. 
  Fail fast  The Java containers also have a mechanism to prevent more than one process from modifying the contents of a container. The problem occurs if you’re in the middle of iterating through a container, and then some other process steps in and inserts, removes, or changes an object in that container. Maybe you’ve already passed that element in the container, maybe it’s ahead of you, maybe the size of the container shrinks after you call size( )—there are many scenarios for disaster. The Java containers library uses a fail-fast mechanism that looks for any changes to the container other than the ones your process is personally responsible for. If it detects that someone else is modifying the container, it immediately produces a ConcurrentModification- Exception. This is the "fail-fast" aspect—it doesn’t try to detect a problem later on using a more complex algorithm. 
  It’s quite easy to see the fail-fast mechanism in operation—all you must do is create an iterator and then add something to the collection that the iterator is pointing to, like this: 
  The exception happens because something is placed in the container after the iterator is acquired from the container. The possibility that two parts of the program might modify the same container produces an uncertain state, so the exception notifies you that you should change your code—in this case, acquire the iterator after you have added all the elements to the container. 
  The ConcurrentHashMap, CopyOnWriteArrayList, and CopyOnWriteArraySet use techniques that avoid ConcurrentModificationExceptions. 
