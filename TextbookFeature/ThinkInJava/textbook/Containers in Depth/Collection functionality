  The following table shows everything you can do with a Collection (not including the methods that automatically come through with Object), and thus, everything you can do with a Set or a List. (List also has additional functionality.) Maps are not inherited from Collection and will be treated separately. 
  boolean add(T) Ensures that the container holds the argument which is of generic type T. Returns false if it doesn’t add the argument. (This is an "optional" method, described in the next section.) boolean addAll( Adds all the elements in the argument. Collection<? extends T>) Returns true if any elements were added. ("Optional.") void clear( ) Removes all the elements in the container. ("Optional.") boolean contains (T) true if the container holds the argument which is of generic type T. Boolean containsAll( true if the container holds all the Collection<?>) elements in the argument. boolean isEmpty( ) true if the container has no elements. Iterator<T> iterator( ) Returns an Iterator<T> that you can use to move through the elements in the container. Boolean If the argument is in the container, one remove(Object) instance of that element is removed. Returns true if a removal occurred. ("Optional") boolean removeAll( Removes all the elements that are Collection<?>) contained in the argument. Returns true if any removals occurred. ("Optional.") Boolean retainAll( Retains only elements that are contained Collection<?>) in the argument (an "intersection," from set theory). Returns true if any changes occurred. ("Optional.") int size( ) Returns the number of elements in the container. Object[] toArray( ) Returns an array containing all the elements in the container. <T>T[] toArray(T[] a) Returns an array containing all the elements in the container. The runtime type of the result is that of the argument array a rather than plain Object. 
  Notice that there’s no get( ) method for random-access element selection. That’s because Collection also includes Set, which maintains its own internal ordering (and thus makes random-access lookup meaningless). Thus, if you want to examine the elements of a Collection, you must use an iterator. 
  The following example demonstrates all of these methods. Although these methods work with anything that implements Collection, an ArrayList is used as a "least-common denominator": 
  ArrayLists are created containing different sets of data and upcast to Collection objects, so it’s clear that nothing other than the Collection interface is being used. main( ) uses simple exercises to show all of the methods in Collection. 
  Subsequent sections in this chapter describe the various implementations of List, Set, and Map and indicate in each case (with an asterisk) which one should be your default choice. Descriptions of the legacy classes Vector, Stack, and Hashtable are delayed to the end of the chapter—although you shouldn’t use these classes, you will see them in old code. 
