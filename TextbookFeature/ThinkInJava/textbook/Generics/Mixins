  The term mixin seems to have acquired numerous meanings over time, but the fundamental concept is that of mixing in capabilities from multiple classes in order to produce a resulting class that represents all the types of the mixins. This is often something you do at the last minute, which makes it convenient to easily assemble classes. 
  One value of mixins is that they consistently apply characteristics and behaviors across multiple classes. As a bonus, if you want to change something in a mixin class, those changes are then applied across all the classes where the mixin is applied. Because of this, mixins have part of the flavor of aspect-oriented programming (AOP), and aspects are often suggested to solve the mixin problem. 
Mixins in C++
  One of the strongest arguments made for multiple inheritance in C++ is for the use of mixins. However, a more interesting and elegant approach to mixins is using parameterized types, whereby a mixin is a class that inherits from its type parameter. In C++, you can easily create mixins because C++ remembers the type of its template parameters. 
  Here’s a C++ example with two mixin types: one that allows you to mix in the property of having a time stamp, and another that mixes in a serial number for each object instance: 
  In main( ), the resulting type of mixin1 and mixin2 has all the methods of the mixed-in types. You can think of a mixin as a function that maps existing classes to new subclasses. Notice how trivial it is to create a mixin using this technique; basically, you just say, "Here’s what I want," and it happens: 
  TimeStamped<SerialNumbered<Basic> > mixin1, mixin2; 
  Unfortunately, Java generics don’t permit this. Erasure forgets the base-class type, so a generic class cannot inherit directly from a generic parameter. 
Mixing with interfaces
  A commonly suggested solution is to use interfaces to produce the effect of mixins, like this: 
  The Mixin class is basically using delegation, so each mixed-in type requires a field in Mixin, and you must write all the necessary methods in Mixin to forward calls to the appropriate object. This example uses trivial classes, but with a more complex mixin the code grows rapidly.4  Exercise 37: (2) Add a new mixin class Colored to Mixins.java, mix it into Mixin, and show that it works. 
Using the Decorator pattern
  When you look at the way that it is used, the concept of a mixin seems closely related to the Decorator design pattern.5 Decorators are often used when, in order to satisfy every possible combination, simple subclassing produces so many classes that it becomes impractical. 
  The Decorator pattern uses layered objects to dynamically and transparently add responsibilities to individual objects. Decorator specifies that all objects that wrap around your initial object have the same basic interface. Something is decoratable, and you layer on functionality by wrapping other classes around the decoratable. This makes the use of the decorators transparentthere are a set of common messages you can send to an object whether it has been decorated or not. A decorating class can also add methods, but as you shall see, this is limited. 
  Decorators are implemented using composition and formal structures (the decoratable/decorator hierarchy), whereas mixins are inheritance-based. So you could think of parameterized-type-based mixins as a generic decorator mechanism that does not require the inheritance structure of the Decorator design pattern. 
  The previous example can be recast using Decorator: 
  The class resulting from a mixin contains all the methods of interest, but the type of the object that results from using decorators is the last type that it was decorated with. That is, although it’s possible to add more than one layer, the final layer is the actual type, so only the final layer’s methods are visible, whereas the type of the mixin is all the types that have been mixed together. So a significant drawback to Decorator is that it only effectively works with one layer of decoration (the final one), and the mixin approach is arguably more natural. Thus, Decorator is only a limited solution to the problem addressed by mixins. 
  Exercise 38: (4) Create a simple Decorator system by starting with basic coffee, then providing decorators of steamed milk, foam, chocolate, caramel and whipped cream. 
Mixins with dynamic proxies
  It’s possible to use a dynamic proxy to create a mechanism that more closely models mixins than does the Decorator (see the Type Information chapter for an explanation of how Java’s dynamic proxies work). With a dynamic proxy, the dynamic type of the resulting class is the combined types that have been mixed in. 
  Because of the constraints of dynamic proxies, each class that is mixed in must be the implementation of an interface: 
  Because only the dynamic type, and not the static type, includes all the mixed-in types, this is still not quite as nice as the C++ approach, because you’re forced to downcast to the appropriate type before you can call methods for it. However, it is significantly closer to a true mixin. 
  There has been a fair amount of work done towards the support of mixins for Java, including the creation of at least one language add-on, the Jam language, specifically for supporting mixins. 
  Exercise 39: (1) Add a new mixin class Colored to DynamicProxyMixin.java, mix it into mixin, and show that it works. 
