  So far we’ve looked at parameterizing entire classes. You can also parameterize methods within a class. The class itself may or may not be generic—this is independent of whether you have a generic method. 
  A generic method allows the method to vary independently of the class. As a guideline, you should use generic methods "whenever you can." That is, if it’s possible to make a method generic rather than the entire class, it’s probably going to be clearer to do so. In addition, if a method is static, it has no access to the generic type parameters of the class, so if it needs to use genericity it must be a generic method. 
  To define a generic method, you simply place a generic parameter list before the return value, like this: 
  The class GenericMethods is not parameterized, although both a class and its methods may be parameterized at the same time. But in this case, only the method f( ) has a type parameter, indicated by the parameter list before the method’s return type. 
  Notice that with a generic class, you must specify the type parameters when you instantiate the class. But with a generic method, you don’t usually have to specify the parameter types, because the compiler can figure that out for you. This is called type argument inference. So calls to f( ) look like normal method calls, and it appears that f( ) has been infinitely overloaded. It will even take an argument of the type GenericMethods. 
  For the calls to f( ) that use primitive types, autoboxing comes into play, automatically wrapping the primitive types in their associated objects. In fact, generic methods and autoboxing can eliminate some code that previously required hand conversion. 
  Exercise 9: (1) Modify GenericMethods.java so that f( ) accepts three arguments, all of which are of a different parameterized type. 
  Exercise 10: (1) Modify the previous exercise so that one of f( )’s arguments is non- parameterized. 
Leveraging type argument inference
  One of the complaints about generics is that it adds even more text to your code. Consider holding/MapOfList.java from the Holding Your Objects chapter. The creation of the Map of List looks like this: 
  Map<Person, List<? extends Pet>> petPeople = new HashMap<Person, List<? extends Pet>>(); 
  (This use of extends and the question marks will be explained later in this chapter.) It appears that you are repeating yourself, and that the compiler should figure out one of the generic argument lists from the other. Alas, it cannot, but type argument inference in a generic method can produce some simplification. For example, we can create a utility containing various static methods, which produces the most commonly used implementations of the various containers: 
  In main( ) you can see examples of how this is used—type argument inference eliminates the need to repeat the generic parameter list. This can be applied to holding/MapOfList.java: 
  Although this is an interesting example of type argument inference, it’s difficult to say how much it actually buys you. The person reading the code is required to parse and understand this additional library and its implications, so it might be just as productive to leave the original (admittedly repetitious) definition in place—ironically, for simplicity. However, if the standard Java library were to add something like the New.java utility above, it would make sense to use it. 
  Type inference doesn’t work for anything other than assignment. If you pass the result of a method call such as New.map( ) as an argument to another method, the compiler will not try to perform type inference. Instead it will treat the method call as though the return value is assigned to a variable of type Object. Here’s an example that fails: 
  Exercise 11: (1) Test New.java by creating your own classes and ensuring that New will work properly with them. 
  Explicit type specification  It is possible to explicitly specify the type in a generic method, although the syntax is rarely needed. To do so, you place the type in angle brackets after the dot and immediately preceding the method name. When calling a method from within the same class, you must use this before the dot, and when working with static methods, you must use the class name before the dot. The problem shown in LimitsOflnference.java can be solved using this syntax: 
  Of course, this eliminates the benefit of using the New class to reduce the amount of typing, but the extra syntax is only required when you are not writing an assignment statement. 
  Exercise 12: (1) Repeat the previous exercise using explicit type specification. 
Varargs and generic methods
  Generic methods and variable argument lists coexist nicely: 
  The makeList( ) method shown here produces the same functionality as the standard library’s java.util.Arrays.asList( ) method. 
  A generic method to use with Generators  It is convenient to use a generator to fill a Collection, and it makes sense to "generify" this operation: 
  Notice how the generic method fill( ) can be transparently applied to both Coffee and Integer containers and generators. 
  Exercise 13: (4) Overload the fill( ) method so that the arguments and return types are the specific subtypes of Collection: List, Queue and Set. This way, you don’t lose the type of container. Can you overload to distinguish between List and LinkedList? 
A general-purpose Generator
  Here’s a class that produces a Generator for any class that has a default constructor. To reduce typing, it also includes a generic method to produce a BasicGenerator: 
  This class provides a basic implementation that will produce objects of a class that (1) is public (because BasicGenerator is in a separate package, the class in question must have public and not just package access) and (2) has a default constructor (one that takes no arguments). To create one of these BasicGenerator objects, you call the create( ) method and pass it the type token for the type you want generated. The generic create( ) method allows you to say BasicGenerator.create(MyType.class) instead of the more awkward new BasicGenerator<MyType>(MyType.class). 
  For example, here’s a simple class that has a default constructor: 
  The CountedObject class keeps track of how many instances of itself have been created, and reports these in its toString( ). 
  Using BasicGenerator, you can easily create a Generator for CountedObject: 
  You can see how the generic method reduces the amount of typing necessary to produce the Generator object. Java generics force you to pass in the Class object anyway, so you might as well use it for type inference in the create( ) method. 
  Exercise 14: (1) Modify BasicGeneratorDemo.java to use the explicit form of creation for the Generator (that is, use the explicit constructor instead of the generic create( ) method). 
Simplifying tuple use
  Type argument inference, together with static imports, allows the tuples we saw earlier to be rewritten into a more general-purpose library. Here, tuples can be created using an overloaded static method: 
  Here’s a modification of TupleTest.java to test Tuple.java: 
  Notice that f( ) returns a parameterized TwoTuple object, while f2( ) returns an unparameterized TwoTuple object. The compiler doesn’t warn about f2( ) in this case because the return value is not being used in a parameterized fashion; in a sense, it is being "upcast" to an unparameterized TwoTuple. However, if you were to try to capture the result of f2( ) into a parameterized TwoTuple, the compiler would issue a warning. 
  Exercise 15: (1) Verify the previous statement. 
  Exercise 16: (2) Add a SixTuple to Tuple.java, and test it in TupleTest2 .j ava. 
A Set utility
  For another example of the use of generic methods, consider the mathematical relationships that can be expressed using Sets. These can be conveniently defined as generic methods, to be used with all different types: 
  The first three methods duplicate the first argument by copying its references into a new HashSet object, so the argument Sets are not directly modified. The return value is thus a new Set object. 
  The four methods represent mathematical set operations: union( ) returns a Set containing the combination of the two arguments, intersection( ) returns a Set containing the common elements between the two arguments, difference( ) performs a subtraction of the subset elements from the superset, and complement( ) returns a Set of all the elements that are not in the intersection. To create a simple example showing the effects of these methods, here’s an enum containing different names of watercolors: 
  For convenience (so that all the names don’t have to be qualified), this is imported statically into the following example. This example uses the EnumSet, which is a Java SE5 tool for easy creation of Sets from enums. (You’ll learn more about EnumSet in the Enumerated Types chapter.) Here, the static method EnumSet.range( ) is given the first and last elements of the range to create in the resulting Set: 
  You can see the results of each operation from the output. The following example uses Sets.difference( ) to show the method differences between various Collection and Map classes in java.util: 
  The output of this program was used in the "Summary" section of the Holding Your Objects chapter. 
  Exercise 17: (4) Study the JDK documentation for EnumSet. You’ll see that there’s a clone( ) method defined. However, you cannot clone( ) from the reference to the Set interface passed in Sets.java. Can you modify Sets.java to handle both the general case of a Set interface as shown, and the special case of an EnumSet, using clone( ) instead of creating a new HashSet? 
