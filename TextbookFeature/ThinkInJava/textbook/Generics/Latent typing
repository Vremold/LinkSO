  The beginning of this chapter introduced the idea of writing code that can be applied as generally as possible. To do this, we need ways to loosen the constraints on the types that our code works with, without losing the benefits of static type checking. We are then able to write code that can be used in more situations without change—that is, more "generic" code. 
  Java generics appear to take a further step in this direction. When you are writing or using generics that simply hold objects, the code works with any type (except for primitives, although as you’ve seen, autoboxing smoothes this over). Or, put another way, "holder" generics are able to say, "I don’t care what type you are." Code that doesn’t care what type it works with can indeed be applied everywhere, and is thus quite "generic." 
  As you’ve also seen, a problem arises when you want to perform manipulations on generic types (other than calling Object methods), because erasure requires that you specify the bounds of the generic types that may be used, in order to safely call specific methods for the generic objects in your code. This is a significant limitation to the concept of "generic" because you must constrain your generic types so that they inherit from particular classes or implement particular interfaces. In some cases you might end up using an ordinary class or interface instead, because a bounded generic might be no different from specifying a class or interface. 
  One solution that some programming languages provide is called latent typing or structural typing. A more whimsical term is duck typing, as in, "If it walks like a duck and talks like a duck, you might as well treat it like a duck." Duck typing has become a fairly popular term, possibly because it doesn’t carry the historical baggage that other terms do. 
  Generic code typically only calls a few methods on a generic type, and a language with latent typing loosens the constraint (and produces more generic code) by only requiring that a subset of methods be implemented, not a particular class or interface. Because of this, latent typing allows you to cut across class hierarchies, calling methods that are not part of a common interface. So a piece of code might say, in effect, "I don’t care what type you are as long as you can speak( ) and sit( )." By not requiring a specific type, your code can be more generic. 
  Latent typing is a code organization and reuse mechanism. With it you can write a piece of code that can be reused more easily than without it. Code organization and reuse are the foundational levers of all computer programming: Write it once, use it more than once, and keep the code in one place. Because I am not required to name an exact interface that my code operates upon, with latent typing I can write less code and apply it more easily in more places. 
  Two examples of languages that support latent typing are Python (freely downloadable from 6 www.Python.org) and C++. Python is a dynamically typed language (virtually all the type checking happens at run time) and C++ is a statically typed language (the type checking happens at compile time), so latent typing does not require either static or dynamic type checking. 
  If we take the above description and express it in Python, it looks like this: 
  #: generics/DogsAndRobots.py  class Dog: def speak(self): print "Arf!" def sit(self): print "Sitting" def reproduce(self): pass 
  class Robot: def speak(self): print "Click!" def sit(self): print "Clank!" def oilChange(self) : pass  def perform(anything): anything.speak() anything.sit() 
  a = Dog() b = Robot() perform(a) perform(b) #:~ 
  Python uses indentation to determine scope (so no curly braces are needed), and a colon to begin a new scope. A ‘#’ indicates a comment to the end of the line, like ‘//’ in Java. The methods of a class explicitly specify the equivalent of the this reference as the first argument, called self by convention. Constructor calls do not require any sort of "new" keyword. And Python allows regular (non-member) functions, as evidenced by perform( ). 
  In perform(anything), notice that there is no type for anything, and anything is just an identifier. It must be able to perform the operations that perform( ) asks of it, so an interface is implied. But you never have to explicitly write out that interface—it’s latent. perform( ) doesn’t care about the type of its argument, so I can pass any object to it as long as it supports the speak( ) and sit( ) methods. If you pass an object to perform( ) that does not support these operations, you’ll get a runtime exception. 
  We can produce the same effect in C++: 
  In both Python and C++, Dog and Robot have nothing in common, other than that they happen to have two methods with identical signatures. From a type standpoint, they are completely distinct types. However, perform( ) doesn’t care about the specific type of its argument, and latent typing allows it to accept both types of object. 
  C++ ensures that it can actually send those messages. The compiler gives you an error message if you try to pass the wrong type (these error messages have historically been terrible and verbose, and are the primary reason that C++ templates have a poor reputation). Although they do it at different times— C++ at compile time, and Python at run time—both languages ensure that types cannot be misused and are thus considered to be strongly typed.7 Latent typing does not compromise strong typing. 
  Because generics were added to Java late in the game, there was no chance that any kind of latent typing could be implemented, so Java has no support for this feature. As a result, it initially seems that Java’s generic mechanism is "less generic" than a language that supports 8 latent typing. For instance, if we try to implement the above example in Java, we are forced to use a class or an interface and specify it in a bounds expression: 
  However, note that perform( ) does not need to use generics in order to work. It can simply be specified to accept a Performs object: 
  In this case, generics were simply not necessary, since the classes were already forced to implement the Performs interface. 
