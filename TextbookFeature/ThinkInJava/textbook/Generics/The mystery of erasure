  As you begin to delve more deeply into generics, there are a number of things that won’t initially make sense. For example, although you can say ArrayList.class, you cannot say ArrayList<Integer>.class. And consider the following: 
  Array List < String > and Array List < Integer > could easily be argued to be distinct types. Different types behave differently, and if you try, for example, to put an Integer into an Array List < String >, you get different behavior (it fails) than if you put an Integer into an ArrayList< Integer > (it succeeds). And yet the above program suggests that they are the same type. 
  Here’s an example that adds to this puzzle: 
  According to the JDK documentation, Class.getTypeParameters( ) "returns an array of TypeVariable objects that represent the type variables declared by the generic declaration..." This seems to suggest that you might be able to find out what the parameter types are. However, as you can see from the output, all you find out is the identifiers that are used as the parameter placeholders, which is not such an interesting piece of information. 
  The cold truth is: 
  There’s no information about generic parameter types available inside generic code. 
  Thus, you can know things like the identifier of the type parameter and the bounds of the generic type—you just can’t know the actual type parameter(s) used to create a particular instance. This fact, which is especially frustrating if you’re coming from C++, is the most fundamental issue that you must deal with when working with Java generics. 
  Java generics are implemented using erasure. This means that any specific type information is erased when you use a generic. Inside the generic, the only thing that you know is that you’re using an object. So List<String> and List< Integer> are, in fact, the same type at run time. Both forms are "erased" to their raw type, List. Understanding erasure and how you must deal with it will be one of the biggest hurdles you will face when learning Java generics, and that’s what we’ll explore in this section. 
  
The C++ approach
  Here’s a C++ example which uses templates. You’ll notice that the syntax for parameterized types is quite similar, because Java took inspiration from C++: 
  The Manipulator class stores an object of type T. What’s interesting is the manipulate( ) method, which calls a method f( ) on obj. How can it know that the f( ) method exists for the type parameter T? The C++ compiler checks when you instantiate the template, so at the point of instantiation of Manipulator <HasF>, it sees that HasF has a method f( ). If it were not the case, you’d get a compile-time error, and thus type safety is preserved. 
  Writing this kind of code in C++ is straightforward because when a template is instantiated, the template code knows the type of its template parameters. Java generics are different. Here’s the translation of HasF: 
  If we take the rest of the example and translate it to Java, it won’t compile: 
  Because of erasure, the Java compiler can’t map the requirement that manipulate( ) must be able to call f( ) on obj to the fact that HasF has a method f( ). In order to call f( ), we must assist the generic class by giving it a bound that tells the compiler to only accept types that conform to that bound. This reuses the extends keyword. Because of the bound, the following compiles: 
  The bound <T extends HasF> says that T must be of type HasF or something derived from HasF. If this is true, then it is safe to call f( ) on obj. 
  We say that a generic type parameter erases to its first bound (it’s possible to have multiple bounds, as you shall see later). We also talk about the erasure of the type parameter. The compiler actually replaces the type parameter with its erasure, so in the above case, T erases to HasF, which is the same as replacing T with HasF in the class body. 
  You may correctly observe that in Manipulations.Java, generics do not contribute anything. You could just as easily perform the erasure yourself and produce a class without generics: 
  This brings up an important point: Generics are only useful when you want to use type parameters that are more "generic" than a specific type (and all its subtypes)—that is, when you want code to work across multiple classes. As a result, the type parameters and their application in useful generic code will usually be more complex than simple class replacement. However, you can’t just say that anything of the form <T extends HasF> is therefore flawed. For example, if a class has a method that returns T, then generics are helpful, because they will then return the exact type: 
  You have to look at all the code and understand whether it is "complex enough" to warrant the use of generics. 
  We’ll look at bounds in more detail later in the chapter. 
  Exercise 20: (1) Create an interface with two methods, and a class that implements that interface and adds another method. In another class, create a generic method with an argument type that is bounded by the interface, and show that the methods in the interface are callable inside this generic method. In main( ), pass an instance of the implementing class to the generic method. 
Migration compatibility
  To allay any potential confusion about erasure, you must clearly understand that it is not a language feature. It is a compromise in the implementation of Java generics, necessary because generics were not made part of the language from the beginning. This compromise will cause you pain, so you need to get used to it early and to understand why it’s there. 
  If generics had been part of Java l.o, the feature would not have been implemented using erasure—it would have used reification to retain the type parameters as first-class entities, so you would have been able to perform type-based language and reflective operations on type parameters. You’ll see later in this chapter that erasure reduces the "genericity" of generics. Generics are still useful in Java, just not as useful as they could be, and the reason is erasure. 
  In an erasure-based implementation, generic types are treated as secondclass types that cannot be used in some important contexts. The generic types are present only during static type checking, after which every generic type in the program is erased by replacing it with a non-generic upper bound. For example, type annotations such as List<T> are erased to List, and ordinary type variables are erased to Object unless a bound is specified. 
  The core motivation for erasure is that it allows generified clients to be used with non- generified libraries, and vice versa. This is often called migration compatibility. In the ideal world, we would have had a single day when everything was generified at once. In reality, even if programmers are only writing generic code, they will have to deal with non-generic libraries that were written before Java SE5. The authors of those libraries may never have the incentive to generify their code, or they may just take their time in getting to it. 
  So Java generics not only must support backwards compatibility—existing code and class files are still legal, and continue to mean what they meant before—but also must support migration compatibility, so that libraries can become generic at their own pace, and when a library does become generic, it doesn’t break code and applications that depend upon it. After deciding that this was the goal, the Java designers and the various groups working on the problem decided that erasure was the only feasible solution. Erasure enables this migration towards generics by allowing non-generic code to coexist with generic code. 
  For example, suppose an application uses two libraries, X and Y, and Y uses library Z. With the advent of Java SE5, the creators of this application and these libraries will probably, eventually, want to migrate to generics. Each of them, however, will have different motivations and constraints as to when that migration happens. To achieve migration compatibility, each library and application must be independent of all the others regarding whether generics are used. Thus, they must not be able to detect whether other libraries are or are not using generics. Ergo, the evidence that a particular library is using generics must be "erased." 
  Without some kind of migration path, all the libraries that had been built up over time stood the chance of being cut off from the developers that chose to move to Java generics. Libraries are arguably the part of a programming language that has the greatest productivity impact, so this was not an acceptable cost. Whether or not erasure was the best or only migration path is something that only time will tell. 
  
The problem with erasure
  So the primary justification for erasure is the transition process from nongenerified code to generified code, and to incorporate generics into the language without breaking existing libraries. Erasure allows existing nongeneric client code to continue to be used without change, until clients are ready to rewrite code for generics. This is a noble motivation, because it doesn’t suddenly break all existing code. 
  The cost of erasure is significant. Generic types cannot be used in operations that explicitly refer to runtime types, such as casts, instanceof operations, and new expressions. Because all the type information about the parameters is lost, whenever you’re writing generic code you must constantly be reminding yourself that it only appears that you have type information about a parameter. So when you write a piece of code like this: 
  class Foo<T> { T var; } 
  it appears that when you create an instance of Foo: 
  Foo<Cat> f = new Foo<Cat>(); 
  the code in class Foo ought to know that it is now working with a Cat. The syntax strongly suggests that the type T is being substituted everywhere throughout the class. But it isn’t, and you must remind yourself, "No, it’s just an Object," whenever you’re writing the code for the class. 
  In addition, erasure and migration compatibility mean that the use of generics is not enforced when you might want it to be: 
  Derived2 inherits from GenericBase with no generic parameters, and the compiler doesn’t issue a warning. The warning doesn’t occur until set( ) is called. 
  To turn off the warning, Java provides an annotation, the one that you see in the listing (this annotation was not supported in earlier releases of Java SE5): 
  @SuppressWarnings("unchecked")  Notice that this is placed on the method that generates the warning, rather than the entire class. It’s best to be as "focused" as possible when you turn off a warning, so that you don’t accidentally cloak a real problem by turning off warnings too broadly. 
  Presumably, the error produced by Derived3 means that the compiler expects a raw base class. 
  Add to this the extra effort of managing bounds when you want to treat your type parameter as more than just an Object, and you have far more effort for much less payoff than you get in parameterized types in languages like C++, Ada or Eiffel. This is not to say that those languages in general buy you more than Java does for the majority of programming problems, but rather that their parameterized type mechanisms are more flexible and powerful than Java’s. 
The action at the boundaries
  Because of erasure, I find that the most confusing aspect of generics is the fact that you can represent things that have no meaning. For example: 
  Even though kind is stored as Class<T>, erasure means that it is actually just being stored as a Class, with no parameter. So, when you do something with it, as in creating an array, Array.newInstance( ) doesn’t actually have the type information that’s implied in kind; so it cannot produce the specific result, which must therefore be cast, which produces a warning that you cannot satisfy. 
  Note that using Array.newInstance( ) is the recommended approach for creating arrays in generics. 
  If we create a container instead of an array, things are different: 
  The compiler gives no warnings, even though we know (from erasure) that the <T> in new ArrayList<T>( ) inside create( ) is removed—at run time there’s no <T> inside the class, so it seems meaningless. But if you follow this idea and change the expression to new ArrayList( ), the compiler gives a warning. 
  Is it really meaningless in this case? What if you were to put some objects in the list before returning it, like this: 
  Even though the compiler is unable to know anything about T inside create( ), it can still ensure—at compile time—that what you put into result is of type T, so that it agrees with ArrayList<T>. Thus, even though erasure removes the information about the actual type inside a method or class, the compiler can still ensure internal consistency in the way that the type is used within the method or class. 
  Because erasure removes type information in the body of a method, what matters at run time is the boundaries: the points where objects enter and leave a method. These are the points at which the compiler performs type checks at compile time, and inserts casting code. Consider the following nongeneric example: 
  If we decompile the result with javap -c SimpleHolder, we get (after editing): 
  public void set(java.lang.Object); 0: aload_0 1: aload_1 2: putfield #2; //Field obj:Object; 5: return  public java.lang.Object get(); 0: aload_0 1: getfield #2; //Field obj:Object; 4: areturn 
  public static void main(java.lang.String[]); 0: new #3; //class SimpleHolder 3: dup 4: invokespecial #4; //Method "<init>":()V 7: astore_1 8: aload_1 9: ldc #5; //String Item 11: invokevirtual #6; //Method set:(Object;)V 14: aload_1 15: invokevirtual #7; //Method get:()Object; 18: checkcast #8; //class java/lang/String 21: astore_2 22: return  The set( ) and get( ) methods simply store and produce the value, and the cast is checked at the point of the call to get( ). 
  Now incorporate generics into the above code: 
  The need for the cast from get( ) has disappeared, but we also know that the value passed to set( ) is being type-checked at compile time. Here are the relevant bytecodes: 
  public void set(java.lang.Object); 0: aload_0 1: aload_1 2: putfield #2; //Field obj:Object; 5: return  public java.lang.Object get(); 0: aload_0 1: getfield #2; //Field obj:Object; 4: areturn 
  public static void main(java.lang.String[]); 
  0: new #3; //class GenericHolder 3: dup 4: invokespecial #4; //Method "<init>":()V 7: astore_1 8: aload_1 9: ldc #5; //String Item 11: invokevirtual #6; //Method set:(Object;)V 14: aload_1 15: invokevirtual #7; //Method get:()Object; 18: checkcast #8; //class java/lang/String 21: astore_2 22: return  The resulting code is identical. The extra work of checking the incoming type in set( ) is free, because it is performed by the compiler. And the cast for the outgoing value of get( ) is still there, but it’s no less than you’d have to do yourself—and it’s automatically inserted by the compiler, so the code you write (and read) is less noisy. 
  Since get( ) and set( ) produce the same bytecodes, all the action in generics happens at the boundaries—the extra compile-time check for incoming values, and the inserted cast for outgoing values. It helps to counter the confusion of erasure to remember that "the boundaries are where the action takes place." 
