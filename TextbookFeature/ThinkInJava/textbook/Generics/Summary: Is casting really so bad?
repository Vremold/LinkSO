  bad? 
  Having worked to explain C++ templates since their inception, I have probably been putting forward the following argument longer than most people. Only recently have I stopped to wonder how often this argument is valid—how many times does the problem I’m about to describe really slip through the cracks? 
  The argument goes like this. One of the most compelling places to use a generic type mechanism is with container classes such as the Lists, Sets, Maps, etc. that you saw in Holding Your Objects and that you shall see more of in the Containers in Depth chapter. Before Java SE5, when you put an object into a container, it would be upcast to Object, so you’d lose the type information. When you wanted to pull it back out to do something with it, you had to cast it back down to the proper type. My example was a List of Cat (a variation of this using apples and oranges is shown at the beginning of the Holding Your Objects chapter). Without the Java SE5 generic version of the container, you put Objects in and you get Objects out, so it’s easily possible to put a Dog in a List of Cat. 
  However, pre-generic Java wouldn’t let you misuse the objects that you put into a container. If you threw a Dog into a container of Cats and then tried to treat everything in the container as a Cat, you’d get a RuntimeException when you pulled the Dog reference out of the Cat container and tried to cast it to a Cat. You’d still discover the problem, but you discovered it at run time rather than compile time. 
  In previous editions of this book, I go on to say: 
  This is more than just an annoyance. It’s something that can create difficult-to-find bugs. If one part (or several parts) of a program inserts objects into a container, and you discover only in a separate part of the program through an exception that a bad object was placed in the container, then you must find out where the bad insert occurred. 
  However, upon further examination of the argument, I began to wonder about it. First, how often does it happen? I don’t remember this kind of thing ever happening to me, and when I asked people at conferences, I didn’t hear anyone say that it had happened to them. Another book used an example of a list called files that contained String objects—in this example it seemed perfectly natural to add a File object to files, so a better name for the object might have been fileNames. No matter how much type checking Java provides, it’s still possible to write obscure programs, and a badly written program that compiles is still a badly written program. Perhaps most people use well-named containers such as "cats" that provide a visual warning to the programmer who would try to add a non-Cat. And even if it did happen, how long would such a thing really stay buried? It would seem that as soon as you started running tests with real data, you’d see an exception pretty quickly. 
  One author even asserted that such a bug could "remain buried for years." But I do not recall any deluge of reports of people having great difficulty finding "dog in cat list" bugs, or even producing them very often. Whereas you will see in the Concurrency chapter that with threads, it is very easy and common to have bugs that may appear extremely rarely, and only give you a vague idea of what’s wrong. So is the "dog in cat list" argument really the reason that this very significant and fairly complex feature has been added to Java? 
  I believe the intent of the general-purpose language feature called "generics" (not necessarily Java’s particular implementation of it) is expressiveness, not just creating type-safe containers. Type-safe containers come as a side effect of the ability to create more general- purpose code. 
  So even though the "dog in cat list" argument is often used to justify generics, it is questionable. And as I asserted at the beginning of the chapter, I do not believe that this is what the concept of generics is really about. Instead, generics are as their name implies—a way to write more "generic" code that is less constrained by the types it can work with, so a single piece of code can be applied to more types. As you have seen in this chapter, it is fairly easy to write truly generic "holder" classes (which the Java containers are), but to write generic code that manipulates its generic types requires extra effort, on the part of both the class creator and the class consumer, who must understand the concept and implementation of the Adapter design pattern. That extra effort reduces the ease of use of the feature, and may thus make it less applicable in places where it might otherwise have added value. 
  Also note that because generics were back-engineered into Java instead of being designed into the language from the start, some of the containers cannot be made as robust as they should be. For example, look at Map, in particular the methods containsKey(Object key) and get(Object key). If these classes had been designed with pre-existing generics, these methods would have used parameterized types instead of Object, thus affording the compile-time checking that generics are supposed to provide. In C++ maps, for example, the key type is always checked at compile time. 
  One thing is very clear: Introducing any kind of generic mechanism in a later version of a language, after that language has come into general use, is a very, very messy proposition, and one that cannot be accomplished without pain. In C++, templates were introduced in the initial ISO version of the language (although even that caused some pain because there was an earlier nontemplate version in use before the first Standard C++ appeared), so in effect templates were always a part of the language. In Java, generics were not introduced until almost 10 years after the language was first released, so the issues of migrating to generics are quite considerable, and have made a significant impact on the design of generics. The result is that you, the programmer, will suffer because of the lack of vision exhibited by the Java designers when they created version l.o. When Java was first being created, the designers, of course, knew about C++ templates, and they even considered including them in the language, but for one reason or another decided to leave them out (indications are that they were in a hurry). As a result, both the language and the programmers that use it will suffer. Only time will show the ultimate impact that Java’s approach to generics will have on the language. 
  Some languages, notably Nice (see http://nice.sourceforge.net; this language generates Java bytecodes and works with existing Java libraries) and NextGen (see http://japan.cs.rice.edu/nextgen) have incorporated cleaner and less impactful approaches to parameterized types. It’s not impossible to imagine such a language becoming a successor to Java, because it takes exactly the approach that C++ did with C: Use what’s there and improve upon it. 
  
Further reading
  The introductory document for generics is Generics in the Java Programming Language, by Gilad Bracha, located at http://java.sun.eom/j2se/1.5/pdf/generics-tutorial.pdf  Angelika Langer’s Java Generics FAQs is a very helpful resource, located at www.angelikalanger.com/GenericsFAQ/JavaGenericsFAQ.html. 
  You can find out more about wildcards in Adding Wildcards to the Java Programming Language, by Torgerson, Ernst, Hansen, von der Ahe, Bracha and Gafter, located at www.jot.fm/issues/issue_2004_12/article5. 
  Solutions to selected exercises can be found in the electronic document The Thinking in Java Annotated Solution Guide, available for sale from www.MindView.net. 
