  As we’ve seen, erasure loses the ability to perform certain operations in generic code. Anything that requires the knowledge of the exact type at run time won’t work: 
  Occasionally you can program around these issues, but sometimes you must compensate for erasure by introducing a type tag. This means you explicitly pass in the Class object for your type so that you can use it in type expressions. 
  For example, the attempt to use instanceof in the previous program fails because the type information has been erased. If you introduce a type tag, a dynamic islnstance( ) can be used instead: 
  The compiler ensures that the type tag matches the generic argument. 
  Exercise 21: (4) Modify ClassTypeCapture.java by adding a Map<String,Class<?>>, a method addType(String typename, Class<?> kind), and a method createNew(String typename). createNew( ) will either produce a new instance of the class associated with its argument string, or produce an error message. 
Creating instances of types
  The attempt to create a new T( ) in Erased.java won’t work, partly because of erasure, and partly because the compiler cannot verify that T has a default (no-arg) constructor. But in C++ this operation is natural, straightforward, and safe (it’s checked at compile time): 
  The solution in Java is to pass in a factory object, and use that to make the new instance. A convenient factory object is just the Class object, so if you use a type tag, you can use newlnstance( ) to create a new object of that type: 
  This compiles, but fails with ClassAsFactory<Integer> because Integer has no default constructor. Because the error is not caught at compile time, this approach is frowned upon by the Sun folks. They suggest instead that you use an explicit factory and constrain the type so that it only takes a class that implements this factory: 
  Note that this is really just a variation of passing Class<T>. Both approaches pass factory objects; Class<T> happens to be the built-in factory object, whereas the above approach creates an explicit factory object. But you get compile-time checking. 
  Another approach is the Template Method design pattern. In the following example, get( ) is the Template Method, and create( ) is defined in the subclass to produce an object of that type: 
  Exercise 22: (6) Use a type tag along with reflection to create a method that uses the argument version of newInstance( ) to create an object of a class with a constructor that has arguments. 
  Exercise 23: (1) Modify FactoryConstraint.java so that create( ) takes an argument. 
  Exercise 24: (3) Modify Exercise 21 so that factory objects are held in the Map instead of Class<?>. 
  
Arrays of generics
  As you saw in Erased.java, you can’t create arrays of generics. The general solution is to use an ArrayList everywhere that you are tempted to create an array of generics: 
  Here you get the behavior of an array but the compile-time type safety afforded by generics. 
  At times, you will still want to create an array of generic types (the ArrayList, for example, uses arrays internally). Interestingly enough, you can define a reference in a way that makes the compiler happy. For example: 
  The compiler accepts this without producing warnings. But you can never create an array of that exact type (including the type parameters), so it’s a little confusing. Since all arrays have the same structure (size of each array slot and array layout) regardless of the type they hold, it seems that you should be able to create an array of Object and cast that to the desired array type. This does in fact compile, but it won’t run; it produces a ClassCastException: 
  The problem is that arrays keep track of their actual type, and that type is established at the point of creation of the array. So even though gia has been cast to a Generic < Integer >[], that information only exists at compile time (and without the @SuppressWarnings annotation, you’d get a warning for that cast). At run time, it’s still an array of Object, and    that causes problems. The only way to successfully create an array of a generic type is to create a new array of the erased type, and cast that. 
  Let’s look at a slightly more sophisticated example. Consider a simple generic wrapper around an array: 
  As before, we can’t say T[] array = new T[sz], so we create an array of objects and cast it. 
  The rep( ) method returns a T[], which in main( ) should be an Integer[] for gai, but if you call it and try to capture the result as an Integer [] reference, you get a ClassCastException, again because the actual runtime type is Object[]. 
  If you compile GenericArray .Java after commenting out the @SuppressWarnings annotation, the compiler produces a warning: 
  Note: GenericArray.Java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 
  In this case, we’ve gotten a single warning, and we believe that it’s about the cast. But if you really want to make sure, you should compile with -Xlint:unchecked: 
  GenericArray.java:7: warning: [unchecked] unchecked cast found : java.lang.Object[] required: T[] array = (T[])new Object[sz]; ^  It is indeed complaining about that cast. Because warnings become noise, the best thing we could possibly do, once we verify that a particular warning is expected, is to turn it off using @SuppressWarnings. That way, when a warning does appear, we’ll actually investigate it. 
  Because of erasure, the runtime type of the array can only be Object[]. If we immediately cast it to T[], then at compile time the actual type of the array is lost, and the compiler may miss out on some potential error checks. Because of this, it’s better to use an Object[] inside the collection, and add a cast to T when you use an array element. Let’s see how that would look with the GenericArray.java example: 
  Initially, this doesn’t look very different, just that the cast has been moved. Without the ©SuppressWarnings annotations, you will still get "unchecked" warnings. However, the internal representation is now Object[] rather than T[]. When get( ) is called, it casts the object to T, which is in fact the correct type, so that is safe. However, if you call rep( ), it again attempts to cast the Object[] to a T[], which is still incorrect, and produces a warning at compile time and an exception at run time. Thus there’s no way to subvert the type of the underlying array, which can only be Object[]. The advantage of treating array internally as Object[] instead of T[] is that it’s less likely that you’ll forget the runtime type of the array and accidentally introduce a bug (although the majority, and perhaps all, of such bugs would be rapidly detected at run time). 
  For new code, you should pass in a type token. In that case, the GenericArray looks like this: 
  The type token Class<T> is passed into the constructor in order to recover from the erasure, so that we can create the actual type of array that we need, although the warning from the cast must be suppressed with @SuppressWarnings. Once we do get the actual type, we can return it and get the desired results, as you see in main( ). The runtime type of the array is the exact type T[]. 
  Unfortunately, if you look at the source code in the Java SE5 standard libraries, you’ll see there are casts from Object arrays to parameterized types everywhere. For example, here’s the copy-ArrayList-from-Collection constructor, after cleaning up and simplifying: 
  public ArrayList(Collection c) { size = c.size(); elementData = (E[])new Object[size]; c.toArray(elementData); } 
  If you look through ArrayList.java, you’ll find plenty of these casts. And what happens when we compile it? 
  Note: ArrayList.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. 
  Sure enough, the standard libraries produce lots of warnings. If you’ve worked with C, especially pre-ANSI C, you remember a particular effect of warnings: When you discover you can ignore them, you do. For that reason, it’s best to not issue any kind of message from the compiler unless the programmer must do something about it. 
  In his weblog,3 Neal Gafter (one of the lead developers for Java SE5) points out that he was lazy when rewriting the Java libraries, and that we should not do what he did. Neal also points out that he could not fix some of the Java library code without breaking the existing interface. So even if certain idioms appear in the Java library sources, that’s not necessarily the right way to do it. When you look at library code, you cannot assume that it’s an example that you should follow in your own code. 
