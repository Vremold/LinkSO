  You’ve already seen some simple uses of wildcards—question marks in generic argument expressions—in the Holding Your Objects chapter and more in the Type Information chapter. This section will explore the issue more deeply. 
  We’ll start with an example that shows a particular behavior of arrays: You can assign an array of a derived type to an array reference of the base type: 
  The first line in main( ) creates an array of Apple and assigns it to a reference to an array of Fruit. This makes sense—an Apple is a kind of Fruit, so an array of Apple should also be an array of Fruit. 
  However, if the actual array type is Apple [], you should only be able to place an Apple or a subtype of Apple into the array, which in fact works at both compile time and run time. But notice that the compiler allows you to place a Fruit object into the array. This makes sense to the compiler, because it has a Fruit[] reference—why shouldn’t it allow a Fruit object, or anything descended from Fruit, such as Orange, to be placed into the array? So at compile    time, this is allowed. The runtime array mechanism, however, knows that it’s dealing with an Apple [] and throws an exception when a foreign type is placed into the array. 
  "Upcast" is actually rather a misnomer here. What you’re really doing is assigning one array to another. The array behavior is that it holds other objects, but because we are able to upcast, it’s clear that the array objects can preserve the rules about the type of objects they contain. It’s as if the arrays are conscious of what they are holding, so between the compile- time checks and the runtime checks, you can’t abuse them. 
  This arrangement for arrays is not so terrible, because you do find out at run time that you’ve inserted an improper type. But one of the primary goals of generics is to move such error detection to compile time. So what happens when we try to use generic containers instead of arrays? 
  The type of flist is now List<? extends Fruit>, which you can read as "a list of any type that’s inherited from Fruit." This doesn’t actually mean that the List will hold any type of Fruit, however. The wildcard refers to a definite type, so it means "some specific type which the flist reference doesn’t specify." So the List that’s assigned has to be holding some specified type such as Fruit or Apple, but in order to upcast to flist, that type is a "don’t actually care." 
  If the only constraint is that the List hold a specific Fruit or subtype of Fruit, but you don’t actually care what it is, then what can you do with such a List? If you don’t know what type the List is holding, how can you safely add an object? Just as with the "upcast" array in CovariantArrays.java, you can’t, except that the compiler prevents it from happening rather than the runtime system. You discover the problem sooner. 
  You might argue that things have gone a bit overboard, because now you can’t even add an Apple to a List that you just said would hold Apples. Yes, but the compiler doesn’t know that. A List<? extends Fruit> could legally point to a List<Orange>. Once you do this kind of "upcast," you lose the ability to pass anything in, even an Object. 
  On the other hand, if you call a method that returns Fruit, that’s safe because you know that anything in the List must at least be of type Fruit, so the compiler allows it. 
  Exercise 26: (2) Demonstrate array covariance using Numbers and Integers. 
  Exercise 27: (2) Show that covariance doesn’t work with Lists, using Numbers and Integers, then introduce wildcards. 
How smart is the compiler?
  Now, you might guess that you are prevented from calling any methods that take arguments, but consider this: 
  You can see calls to contains( ) and indexOf( ) that take Apple objects as arguments, and those are just fine. Does this mean that the compiler actually examines the code to see if a particular method modifies its object? 
  By looking at the documentation for ArrayList, we find that the compiler is not that smart. While add( ) takes an argument of the generic parameter type, contains( ) and indexOf( ) take arguments of type Object. So when you specify an ArrayList <? extends Fruit >, the argument for add( ) becomes’? extends Fruit’. From that description, the compiler cannot know which specific subtype of Fruit is required there, so it won’t accept any type of Fruit. It doesn’t matter if you upcast the Apple to a Fruit first—the compiler simply refuses to call a method (such as add( )) if a wildcard is involved in the argument list. 
  With contains( ) and indexOf( ), the arguments are of type Object, so there are no wildcards involved and the compiler allows the call. This means that it’s up to the generic class designer to decide which calls are "safe," and to use Object types for their arguments. To disallow a call when the type is used with wildcards, use the type parameter in the argument list. 
  You can see this in a very simple Holder class: 
  Holder has a set( ) which takes a T, a get( ) which returns a T, and an equals( ) that takes an Object. As you’ve already seen, if you create a Holder<Apple>, you cannot upcast it to a Holder<Fruit>, but you can upcast to a Holder<? extends Fruit>. If you call get( ), it only returns a Fruit—that’s as much as it knows given the "anything that extends Fruit" bound. If you know more about what’s there, you can cast to a specific type of Fruit and there won’t be any warning about it, but you risk a ClassCastException. The set( ) method won’t work with either an Apple or a Fruit, because the set( ) argument is also "? Extends Fruit," which means it can be anything and the compiler can’t verify type safety for "anything." 
  However, the equals( ) method works fine because it takes an Object instead of a T as an argument. Thus, the compiler is only paying attention to the types of objects that are passed and returned. It is not analyzing the code to see if you perform any actual writes or reads. 
Contravariance
  It’s also possible to go the other way, and use supertype wildcards. Here, you say that the wildcard is bounded by any base class of a particular class, by specifying <? super MyClass> or even using a type parameter: <? super T> (although you cannot give a generic parameter a supertype bound; that is, you cannot say <T super MyClass>). This    allows you to safely pass a typed object into a generic type. Thus, with supertype wildcards you can write into a Collection: 
  The argument apples is a List of some type that is the base type of Apple; thus you know that it is safe to add an Apple or a subtype of Apple. Since the lower bound is Apple, however, you don’t know that it is safe to add Fruit to such a List, because that would allow the List to be opened up to the addition of non-Apple types, which would violate static type safety. 
  You can thus begin to think of subtype and supertype bounds in terms of how you can "write" (pass into a method) to a generic type, and "read" (return from a method) from a generic type. 
  Supertype bounds relax the constraints on what you can pass into a method: 
  The writeExact( ) method uses an exact parameter type (no wildcards). In fi( ) you can see that this works fine—as long as you only put an Apple into a List<Apple>. However, writeExact( ) does not allow you to put an Apple into a List<Fruit>, even though you know that should be possible. 
  In writeWithWildcard( ), the argument is now a List<? super T>, so the List holds a specific type that is derived from T; thus it is safe to pass a T or anything derived from T as an argument to List methods. You can see this in f2( ), where it’s still possible to put an Apple    into a List<Apple>, as before, but it is now also possible to put an Apple into a List<Fruit>, as you expect. 
  We can perform this same type of analysis as a review of covariance and wildcards: 
  As before, the first method readExact( ) uses the precise type. So if you use the precise type with no wildcards, you can both write and read that precise type into and out of a List. In addition, for the return value, the static generic method readExact( ) effectively "adapts" to each method call, and returns an Apple from a List<Apple> and a Fruit from a List<Fruit>, as you can see in f1( ). Thus, if you can get away with a static generic method, you don’t necessarily need covariance if you’re just reading. 
  If you have a generic class, however, the parameter is established for the class when you make an instance of that class. As you can see in f2( ), the fruitReader instance can read a piece of Fruit from a List<Fruit>, since that is its exact type. But a List<Apple> should also produce Fruit objects, and the fruitReader doesn’t allow this. 
  To fix the problem, the CovariantReader.readCovariant( ) method takes a List<? extends T>, and so it’s safe to read a T from that list (you know that everything in that list is at least a T, and possibly something derived from a T). In f3( ) you can see that it’s now possible to read a Fruit from a List<Apple>. 
  Exercise 28: (4) Create a generic class Generic1<T> with a single method that takes an argument of type T. Create a second generic class Generic2<T> with a single method that returns an argument of type T. Write a generic method with a contravariant argument of the first generic class that calls its method. Write a second generic method with a covariant argument of the second generic class that calls its method. Test using the typeinfo.pets library. 
Unbounded wildcards
  The unbounded wildcard <?> appears to mean "anything," and so using an unbounded wildcard seems equivalent to using a raw type. Indeed, the compiler seems at first to agree with this assessment: 
  There are many cases like the ones you see here where the compiler could care less whether you use a raw type or <?>. In those cases, <?> can be thought of as a decoration; and yet it is valuable because, in effect, it says, "I wrote this code with Java generics in mind, and I don’t mean here that I’m using a raw type, but that in this case the generic parameter can hold any type." 
  A second example shows an important use of unbounded wildcards. When you are dealing with multiple generic parameters, it’s sometimes important to allow one parameter to be any type while establishing a particular type for the other parameter: 
  But again, when you have all unbounded wildcards, as seen in Map<?,?>, the compiler doesn’t seem to distinguish it from a raw Map. In addition, UnboundedWildcards1.java shows that the compiler treats List<?> and List<? extends Object> differently. 
  What’s confusing is that the compiler doesn’t always care about the difference between, for example, List and List<?>, so they can seem like the same thing. Indeed, since a generic argument erases to its first bound, List<?> would seem to be equivalent to List<Object>, and List is effectively List<Object> as well—except neither of those statements is exactly true. List actually means "a raw List that holds any Object type," whereas List<?> means "a non-raw List of some specific type, but we just don’t know what that type is." 
  When does the compiler actually care about the difference between raw types and types involving unbounded wildcards? The following example uses the previously defined Holder<T> class. It contains methods that take Holder as an argument, but in various forms: as a raw type, with a specific type parameter, and with an unbounded wildcard parameter: 
  In rawArgs( ), the compiler knows that Holder is a generic type, so even though it is expressed as a raw type here, the compiler knows that passing an Object to set( ) is unsafe. Since it’s a raw type, you can pass an object of any type into set( ), and that object is upcast to Object. So anytime you have a raw type, you give up compile-time checking. The call to get( ) shows the same issue: There’s no T, so the result can only be an Object. 
  It’s easy to start thinking that a raw Holder and a Holder<?> are roughly the same thing. But unboundedArg( ) emphasizes that they are differentit discovers the same kind of problems, but reports them as errors rather than warnings, because the raw Holder will hold a combination of any types, whereas a Holder<?> holds a homogeneous collection of some specific type, and thus you can’t just pass in an Object. 
  In exact1( ) and exact2( ), you see the exact generic parameters used—no wildcards. You’ll see that exact2( ) has different limitations than exact1( ), because of the extra argument. 
  In wildSubtype( ), the constraints on the type of Holder are relaxed to include a Holder of anything that extends T. Again, this means that T could be Fruit, while holder could legitimately be a Holder<Apple>. To prevent putting an Orange in a Holder<Apple>, the call to set( ) (or any method that takes an argument of the type parameter) is disallowed. However, you still know that anything that comes out of a Holder<? extends Fruit> will at least be Fruit, so get( ) (or any method that produces a return value of the type parameter) is allowed. 
  Supertype wildcards are shown in wildSupertype( ), which shows the opposite behavior of wildSubtype( ): holder can be a container that holds any type that’s a base class of T. Thus, set( ) can accept a T, since anything that works with a base type will polymorphically work with a derived type (thus a T). However, trying to call get( ) is not helpful, because the type held by holder can be any supertype at all, so the only safe one is Object. 
  This example also shows the limitations on what you can and can’t do with an unbounded parameter in unbounded( ): You can’t get( ) or set( ) a T because you don’t have a T. 
  In main( ) you can see which of these methods can accept which types of arguments without errors and warnings. For migration compatibility, rawArgs( ) will take all the different variations of Holder without producing warnings. The unboundedArg( ) method is equally accepting of all types, although, as previously noted, it handles them differently inside the body of the method. 
  If you pass a raw Holder reference into a method that takes an "exact" generic type (no wildcards), you get a warning because the exact argument is expecting information that doesn’t exist in the raw type. And if you pass an unbounded reference to exact1( ), there’s no type information to establish the return type. 
  You can see that exact2( ) has the most constraints, since it wants exactly a Holder<T> and an argument of type T, and because of this it generates errors or warnings unless you give it the exact arguments. Sometimes this is OK, but if it’s overconstraining, then you can use wildcards, depending on whether you want to get typed return values from your generic argument (as seen in wildSubtype( )) or you want to pass typed arguments to your generic argument (as seen in wildSupertype( )). 
  Thus, the benefit of using exact types instead of wildcard types is that you can do more with the generic parameters. But using wildcards allows you to accept a broader range of parameterized types as arguments. You must decide which trade-off is more appropriate for your needs on a case-by-case basis. 
Capture conversion
  One situation in particular requires the use of <?> rather than a raw type. If you pass a raw type to a method that uses <?>, it’s possible for the compiler to infer the actual type parameter, so that the method can turn around and call another method that uses the exact type. The following example demonstrates the technique, which is called capture conversion because the unspecified wildcard type is captured and converted to an exact type. Here, the comments about warnings only take effect when the @SuppressWarnings annotation is removed: 
  The type parameters in f1( ) are all exact, without wildcards or bounds. In f2( ), the Holder parameter is an unbounded wildcard, so it would seem to be effectively unknown. However, within f2( ), f1( ) is called and f1( ) requires a known parameter. What’s happening is that the parameter type is captured in the process of calling f2( ), so it can be used in the call to f1( ). 
  You might wonder if this technique could be used for writing, but that would require you to pass a specific type along with the Holder<?>. Capture conversion only works in situations where, within the method, you need to work with the exact type. Notice that you can’t return T from f2( ), because T is unknown for f2( ). Capture conversion is interesting, but quite limited. 
  Exercise 29: (5) Create a generic method that takes as an argument a Holder<List<?>>. Determine what methods you can and can’t call for the Holder and for the List. Repeat for an argument of List<Holder<?>>. 
