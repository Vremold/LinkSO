  Bounds were briefly introduced earlier in the chapter (see page 652). Bounds allow you to place constraints on the parameter types that can be used with generics. Although this allows you to enforce rules about the types that your generics can be applied to, a potentially more important effect is that you can call methods that are in your bound types. 
  Because erasure removes type information, the only methods you can call for an unbounded generic parameter are those available for Object. If, however, you are able to constrain that parameter to be a subset of types, then you can call the methods in that subset. To perform this constraint, Java generics reuse the extends keyword. It’s important for you to understand that extends has a significantly different meaning in the context of generic bounds than it does ordinarily. This example shows the basics of bounds: 
  You might observe that BasicBounds.java seems to contain redundancies that could be eliminated through inheritance. Here, you can see how each level of inheritance also adds bounds constraints: 
  Holdltem simply holds an object, so this behavior is inherited into Colored2, which also requires that its parameter conforms to HasColor. ColoredDimension2 and Solid2 further extend the hierarchy and add bounds at each level. Now the methods are inherited and they don’t have to be repeated in each class. 
  Here’s an example with more layers: 
  Notice that wildcards (which we shall study next) are limited to a single bound. 
  Exercise 25: (2) Create two interfaces and a class that implements both. Create two generic methods, one whose argument parameter is bounded by the first interface and one whose argument parameter is bounded by the second interface. Create an instance of the class that implements both interfaces, and show that it can be used with both generic methods. 
