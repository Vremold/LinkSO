  One of the most compelling initial motivations for generics is to create container classes, which you saw in the Holding Your Objects chapter (you’ll learn more about these in the Containers in Depth chapter). A container is a place to hold objects while you’re working with them. Although this is also true of arrays, containers tend to be more flexible and have different characteristics than simple arrays. Virtually all programs require that you hold a group of objects while you use them, so containers are one of the most reusable of class libraries. 
  Let’s look at a class that holds a single object. Of course, the class could specify the exact type of the object, like this: 
  But this is not a very reusable tool, since it can’t be used to hold anything else. We would prefer not to write a new one of these for every type we encounter. 
  Before Java SE5, we would simply make it hold an Object: 
  Now a Holder2 can hold anything—and in this example, a single Holder2 holds three different types of objects. 
  There are some cases where you want a container to hold multiple types of objects, but typically you only put one type of object into a container. One of the primary motivations for generics is to specify what type of object a container holds, and to have that specification backed up by the compiler. 
  So instead of Object, we’d like to use an unspecified type, which can be decided at a later time. To do this, you put a type parameter inside angle brackets after the class name, and then substitute an actual type when you use the class. For the "holder" class, it looks like this, where T is the type parameter: 
  Now when you create a Holders, you must specify what type you want to put into it using the same angle-bracket syntax, as you can see in main( ). You are only allowed to put objects of that type (or a subtype, since the substitution principle still works with generics) into the holder. And when you get a value out, it is automatically the right type. 
  That’s the core idea of Java generics: You tell it what type you want to use, and it takes care of the details. 
  In general, you can treat generics as if they are any other type—they just happen to have type parameters. But as you’ll see, you can use generics just by naming them along with their type argument list. 
  Exercise 1: (1) Use Holders with the typeinfo.pets library to show that a Holders that is specified to hold a base type can also hold a derived type. 
  Exercise 2: (1) Create a holder class that holds three objects of the same type, along with the methods to store and fetch those objects and a constructor to initialize all three. 
  
A tuple library
  One of the things you often want to do is return multiple objects from a method call. The return statement only allows you to specify a single object, so the answer is to create an object that holds the multiple objects that you want to return. Of course, you can write a special class every time you encounter the situation, but with generics it’s possible to solve the problem once and save yourself the effort in the future. At the same time, you are ensuring compile-time type safety. 
  This concept is called a tuple, and it is simply a group of objects wrapped together into a single object. The recipient of the object is allowed to read the elements but not put new ones in. (This concept is also called a Data Transfer Object (or Messenger.)  Tuples can typically be any length, but each object in the tuple can be of a different type. However, we want to specify the type of each object and ensure that when the recipient reads the value, they get the right type. To deal with the problem of multiple lengths, we create multiple different tuples. Here’s one that holds two objects: 
  The constructor captures the object to be stored, and toString( ) is a convenience function to display the values in a list. Note that a tuple implicitly keeps its elements in order. 
  Upon first reading, you may think that this could violate common safety principles of Java programming. Shouldn’t first and second be private, and only accessed with methods named getFirst( ) and getSecond( )? Consider the safety that you would get in that case: Clients could still read the objects and do whatever they want with them, but they could not assign first or second to anything else. The final declaration buys you the same safety, but the above form is shorter and simpler. 
  Another design observation is that you might want to allow a client programmer to point first or second to another object. However, it’s safer to leave it in the above form, and just force the user to create a new TwoTuple if they want one that has different elements. 
  The longer-length tuples can be created with inheritance. You can see that adding more type parameters is a simple matter: 
  To use a tuple, you simply define the appropriate-length tuple as the return value for your function, and then create and return it in your return statement: 
  Because of generics, you can easily create any tuple to return any group of types, just by writing the expression. 
  You can see how the final specification on the public fields prevents them from being reassigned after construction, in the failure of the statement ttsi.first = "there". 
  The new expressions are a little verbose. Later in this chapter you’ll see how to simplify them using generic methods. 
  Exercise 3 : (1) Create and test a SixTuple generic. 
  Exercise 4: (3) "Generify" innerclasses/Sequence.java. 
A stack class
  Let’s look at something slightly more complicated: the traditional pushdown stack. In the Holding Your Objects chapter, you saw this implemented using a LinkedList as the net.mindview.util.Stack class (page 412). In that example, you can see that a LinkedList already has the necessary methods to create a stack. The Stack was constructed by composing one generic class (Stack<T>) with another generic class (LinkedList<T>). In that example, notice that (with a few exceptions that we shall look at later) a generic type is just another type. 
  Instead of using LinkedList, we can implement our own internal linked storage mechanism. 
  The inner class Node is also a generic, and has its own type parameter. 
  This example makes use of an end sentinel to determine when the stack is empty. The end sentinel is created when the LinkedStack is constructed, and each time you call push( ) a new Node<T> is created and linked to the previous Node<T>. When you call pop( ), you always return the top.item, and then you discard the current Node<T> and move to the next one— except when you hit the end sentinel, in which case you don’t move. That way, if the client keeps calling pop( ), they keep getting null back to indicate that the stack is empty. 
  Exercise 5: (2) Remove the type parameter on the Node class and modify the rest of the code in LinkedStack.java to show that an inner class has access to the generic type parameters of its outer class. 
RandomList
  For another example of a holder, suppose you’d like a special type of list that randomly selects one of its elements each time you call select( ). When doing this you want to build a tool that works with all objects, so you use generics: 
  Exercise 6: (1) Use RandomList with two more types in addition to the one shown in main( ). 
