  all the objects  When you create a reference, you want to connect it with a new object. You do so, in general, with the new operator. The keyword new says, “Make me a new one of these objects.” So in the preceding example, you can say: 
  String s = new String("asdf"); 
  Not only does this mean “Make me a new String,” but it also gives information about how to make the String by supplying an initial character string. 
  Of course, Java comes with a plethora of ready-made types in addition to String. What’s more important is that you can create your own types. In fact, creating new types is the fundamental activity in Java programming, and it’s what you’ll be learning about in the rest of this book. Where storage lives It’s useful to visualize some aspects of how things are laid out while the program is running— in particular how memory is arranged. There are five different places to store data: 
  1. Registers. This is the fastest storage because it exists in a place different from that of other storage: inside the processor. However, the number of registers is severely limited, so registers are allocated as they are needed. You don’t have direct control, nor do you see any evidence in your programs that registers even exist (C & C++, on the other hand, allow you to suggest register allocation to the compiler). 
  2. The stack. This lives in the general random-access memory (RAM) area, but has direct support from the processor via its stack pointer. The stack pointer is moved down to create new memory and moved up to release that memory. This is an extremely fast and efficient way to allocate storage, second only to registers. The Java system must know, while it is creating the program, the exact lifetime of all the items that are stored on the stack. This constraint places limits on the flexibility of your programs, so while some Java storage exists on the stack—in particular, object references—Java objects themselves are not placed on the stack. 
  3. The heap. This is a general-purpose pool of memory (also in the RAM area) where all Java objects live. The nice thing about the heap is that, unlike the stack, the compiler doesn’t need to know how long that storage must stay on the heap. Thus, there’s a great deal of flexibility in using storage on the heap. Whenever you need an object, you simply write the code to create it by using new, and the storage is allocated on the heap when that code is executed. Of course there’s a price you pay for this flexibility: It may take more time to allocate and clean up heap storage than stack storage (if you even could create objects on the stack in Java, as you can in C++). 
  4. Constant storage. Constant values are often placed directly in the program code, which is safe since they can never change. Sometimes constants are cordoned off by themselves so that they can be optionally placed in read-only memory (ROM), in embedded systems.2  5. Non-RAM storage. If data lives completely outside a program, it can exist while the program is not running, outside the control of the program. The two primary examples of this are streamed objects, in which objects are turned into streams of bytes, generally to be sent to another machine, and persistent objects, in which the objects are placed on disk so they will hold their state even when the program is terminated. The trick with these types of storage is turning the objects into something that can exist on the other medium, and yet can be resurrected into a regular RAM- based object when necessary. Java provides support for lightweight persistence, and mechanisms such as JDBC and Hibernate provide more sophisticated support for storing and retrieving object information in databases. 
Special case: primitive types
  One group of types, which you’ll use quite often in your programming, gets special treatment. You can think of these as “primitive” types. The reason for the special treatment is that to create an object with new—especially a small, simple variable—isn’t very efficient, because new places objects on the heap. For these types Java falls back on the approach taken by C and C++. That is, instead of creating the variable by using new, an “automatic” variable is created that is not a reference. The variable holds the value directly, and it’s placed on the stack, so it’s much more efficient. 
  Java determines the size of each primitive type. These sizes don’t change from one machine architecture to another as they do in most languages. This size invariance is one reason Java programs are more portable than programs in most other languages. 
  Primitive Size Minimum Maximum Wrapper type type boolean — — — Boolean char 16 bits Unicode 0 Unicode 216- 1 Character byte 8 bits -128 +127 Byte 15 15 short 16 bits -2 +2 -1 Short 31 31 int 32 bits -2 +2 -1 Integer 63 63 long 64 bits -2 +2 -1 Long float 32 bits IEEE754 IEEE754 Float double 64 bits IEEE754 IEEE754 Double void — — — Void    and put into special static storage. All numeric types are signed, so don’t look for unsigned types. 
  The size of the boolean type is not explicitly specified; it is only defined to be able to take the literal values true or false. 
  The “wrapper” classes for the primitive data types allow you to make a non-primitive object on the heap to represent that primitive type. For example: 
  char c = ‘x’; Character ch = new Character(c); 
  Or you could also use: 
  Character ch = new Character(‘x’); 
  Java SE5 autoboxing will automatically convert from a primitive to a wrapper type: 
  Character ch = ‘x’; 
  and back: 
  char c = ch; 
  The reasons for wrapping primitives will be shown in a later chapter. 
  High-precision numbers  Java includes two classes for performing high-precision arithmetic: BigInteger and BigDecimal. Although these approximately fit into the same category as the “wrapper” classes, neither one has a primitive analogue. 
  Both classes have methods that provide analogues for the operations that you perform on primitive types. That is, you can do anything with a BigInteger or BigDecimal that you can with an int or float, it’s just that you must use method calls instead of operators. Also, since there’s more involved, the operations will be slower. You’re exchanging speed for accuracy. 
  BigInteger supports arbitrary-precision integers. This means that you can accurately represent integral values of any size without losing any information during operations. 
  BigDecimal is for arbitrary-precision fixed-point numbers; you can use these for accurate monetary calculations, for example. 
  Consult the JDK documentation for details about the constructors and methods you can call for these two classes. 
Arrays in Java
  Virtually all programming languages support some kind of arrays. Using arrays in C and C++ is perilous because those arrays are only blocks of memory. If a program accesses the array outside of its memory block or uses the memory before initialization (common programming errors), there will be unpredictable results. 
  One of the primary goals of Java is safety, so many of the problems that plague programmers in C and C++ are not repeated in Java. A Java array is guaranteed to be initialized and cannot  be accessed outside of its range. The range checking comes at the price of having a small amount of memory overhead on each array as well as verifying the index at run time, but the assumption is that the safety and increased productivity are worth the expense (and Java can sometimes optimize these operations). 
  When you create an array of objects, you are really creating an array of references, and each of those references is automatically initialized to a special value with its own keyword: null. When Java sees null, it recognizes that the reference in question isn’t pointing to an object. You must assign an object to each reference before you use it, and if you try to use a reference that’s still null, the problem will be reported at run time. Thus, typical array errors are prevented in Java. 
  You can also create an array of primitives. Again, the compiler guarantees initialization because it zeroes the memory for that array. 
  Arrays will be covered in detail in later chapters. 
