  and JavaBeans  So far in this book you’ve seen how valuable Java is for creating reusable pieces of code. The "most reusable" unit of code has been the class, since it comprises a cohesive unit of characteristics (fields) and behaviors (methods) that can be reused either directly via composition or through inheritance. 
  Inheritance and polymorphism are essential parts of object-oriented programming, but in the majority of cases when you’re putting together an application, what you really want is components that do exactly what you need. You’d like to drop these parts into your design like the chips an electronic engineer puts on a circuit board. It seems that there should be some way to accelerate this "modular assembly" style of programming. 
  "Visual programming" first became successful—very successful—with Microsoft’s Visual BASIC (VB), followed by a second-generation design in Borland’s Delphi (which was the primary inspiration for the JavaBeans design). With these programming tools the components are represented visually, which makes sense since they usually display some kind of visual component such as a button or a text field. The visual representation, in fact, is often exactly the way the component will look in the running program. So part of the process of visual programming involves dragging a component from a palette and dropping it onto your form. The Application Builder Integrated Development Environment (IDE) writes code as you do this, and that code will cause the component to be created in the running program. 
  Simply dropping the component onto a form is usually not enough to complete the program. Often, you must change the characteristics of a component, such as its color, the text that’s on it, the database it’s connected to, etc. Characteristics that can be modified at design time are referred to as properties. You can manipulate the properties of your component inside the IDE, and when you create the program, this configuration data is saved so that it can be rejuvenated when the program is started. 
  By now you’re probably used to the idea that an object is more than characteristics; it’s also a set of behaviors. At design time, the behaviors of a visual component are partially represented by events, meaning "Here’s something that can happen to the component." Ordinarily, you decide what you want to happen when an event occurs by tying code to that event. 
  Here’s the critical part: The IDE uses reflection to dynamically interrogate the component and find out which properties and events the component supports. Once it knows what they are, it can display the properties and allow you to change them (saving the state when you build the program), and also display the events. In general, you do something like double- clicking on an event, and the IDE creates a code body and ties it to that particular event. All you must do at that point is write the code that executes when the event occurs. 
  All this adds up to a lot of work that’s done for you by the IDE. As a result, you can focus on what the program looks like and what it is supposed to do, and rely on the IDE to manage the connection details for you. The reason that visual programming tools have been so successful is that they dramatically speed up the process of building an application—certainly the user interface, but often other portions of the application as well. 
What is a JavaBean?
  After the dust settles, then, a component is really just a block of code, typically embodied in a class. The key issue is the ability for the IDE to discover the properties and events for that component. To create a VB component, the programmer originally had to write a fairly complicated piece of code following certain conventions to expose the properties and events (it got easier as the years passed). Delphi was a second-generation visual programming tool, and the language was actively designed around visual programming, so it was much easier to create a visual component. However, Java has brought the creation of visual components to its most advanced state with JavaBeans, because a Bean is just a class. You don’t have to write any extra code or use special language extensions in order to make something a Bean. The only thing you need to do, in fact, is slightly modify the way that you name your methods. It is the method name that tells the IDE whether this is a property, an event, or just an ordinary method. 
  In the JDK documentation, this naming convention is mistakenly termed a "design pattern." This is unfortunate, since design patterns (see Thinking in Patterns at www.MindView.net) are challenging enough without this sort of confusion. It’s not a design pattern, it’s just a naming convention, and it’s fairly simple: 
  1. For a property named xxx, you typically create two methods: getXxx( ) and setXxx( ). The first letter after "get" or "set" will automatically be lowercased by any tools that look at the methods, in order to produce the property name. The type produced by the "get" method is the same as the type of the argument to the "set" method. The name of the property and the type for the "get" and "set" are not related. 
  2. For a boolean property, you can use the "get" and "set" approach above, but you can also use "is" instead of "get." 
  3. Ordinary methods of the Bean don’t conform to the above naming convention, but they’re public. 
  4. For events, you use the Swing "listener" approach. It’s exactly the same as you’ve been seeing: addBounceListener(BounceListener) and removeBounceListener(BounceListener) to handle a BounceEvent. Most of the time, the built-in events and listeners will satisfy your needs, but you can also create your own events and listener interfaces. 
  We can use these guidelines to create a simple Bean: 
  First, you can see that it’s just a class. Usually, all your fields will be private and accessible only through methods and properties. Following the naming convention, the properties are jumps, color, spots, and jumper (notice the case change of the first letter in the property name). Although the name of the internal identifier is the same as the name of the property in the first three cases, in jumper you can see that the property name does not force you to use any particular identifier for internal variables (or, indeed, to even have any internal variables for that property). 
  The events this Bean handles are ActionEvent and KeyEvent, based on the naming of the "add" and "remove" methods for the associated listener. Finally, you can see that the ordinary method croak( ) is still part of the Bean simply because it’s a public method, not because it conforms to any naming scheme. Extracting Beanlnfo with the Introspector  One of the most critical parts of the JavaBean scheme occurs when you drag a Bean off a palette and drop it onto a form. The IDE must be able to create the Bean (which it can do if there’s a default constructor) and then, without access to the Bean’s source code, extract all the necessary information to create the property sheet and event handlers. 
  Part of the solution is already evident from the Type Information chapter: Java reflection discovers all the methods of an unknown class. This is perfect for solving the JavaBean problem without requiring extra language keywords like those in other visual programming languages. In fact, one of the prime reasons that reflection was added to Java was to support JavaBeans (although reflection also supports object serialization and Remote Method Invocation, and is helpful in ordinary programming). So you might expect that the creator of the IDE would have to reflect each Bean and hunt through its methods to find the properties and events for that Bean. 
  This is certainly possible, but the Java designers wanted to provide a standard tool, not only to make Beans simpler to use, but also to provide a standard gateway to the creation of more complex Beans. This tool is the Introspector class, and the most important method in this class is the static getBeanInfo( ). You pass a Class reference to this method, and it fully    interrogates that class and returns a BeanInfo object which you can dissect to find properties, methods, and events. 
  Usually, you won’t care about any of this; you’ll probably get most of your Beans off the shelf, and you won’t need to know all the magic that’s going on underneath. You’ll simply drag Beans onto your form, then configure their properties and write handlers for the events of interest. However, it’s an educational exercise to use the Introspector to display information about a Bean. Here’s a tool that does it: 
  BeanDumper.dump( ) does all the work. First it tries to create a BeanInfo object, and if successful, calls the methods of BeanInfo that produce information about properties, methods, and events. In Introspector.getBeanInfo( ), you’ll see there is a second argument that tells the Introspector where to stop in the inheritance hierarchy. Here, it stops before it parses all the methods from Object, since we’re not interested in seeing those. 
  For properties, getPropertyDescriptors( ) returns an array of PropertyDescriptors. For each PropertyDescriptor, you can call getPropertyType( ) to find the class of object that is passed in and out via the property methods. Then, for each property, you can get its pseudonym (extracted from the method names) with getName( ), the method for reading with getReadMethod( ), and the method for writing with getWriteMethod( ). These last two methods return a Method object that can actually be used to invoke the corresponding method on the object (this is part of reflection). 
  For the public methods (including the property methods), getMethodDescriptors( ) returns an array of MethodDescriptors. For each one, you can get the associated Method object and print its name. 
  For the events, getEventSetDescriptors( ) returns an array of EventSetDescriptors. Each of these can be queried to find out the class of the listener, the methods of that listener class, and the add- and removelistener methods. The BeanDumper program displays all of this information. 
  Upon startup, the program forces the evaluation of frogbean.Frog. The output, after unnecessary details have been removed, is: 
  Property type: 
  Color Property name: color Read method: public Color getColor() Write method: public void setColor(Color) ==================== Property type: boolean Property name: jumper Read method: public boolean isJumper() Write method: public void setJumper(boolean) ==================== Property type: int Property name: jumps Read method: public int getJumps() Write method: public void setJumps(int) ==================== Property type: frogbean.Spots Property name: spots Read method: public frogbean.Spots getSpots() Write method: public void setSpots(frogbean.Spots) ==================== Public methods: public void setSpots(frogbean.Spots) public void setColor(Color) public void setJumps(int) public boolean isJumper() public frogbean.Spots getSpots() public void croak() public void addActionListener(ActionListener) public void addKeyListener(KeyListener) public Color getColor() public void setJumper(boolean) public int getJumps() public void removeActionListener(ActionListener) public void removeKeyListener(KeyListener) ===================== Event support: Listener type: KeyListener Listener method: keyPressed Listener method: keyReleased Listener method: keyTyped Method descriptor: public abstract void keyPressed(KeyEvent) Method descriptor: public abstract void keyReleased(KeyEvent)    Method descriptor: public abstract void keyTyped(KeyEvent) AddListener Method: public void addKeyListener(KeyListener) Remove Listener Method: public void removeKeyListener(KeyListener) ==================== Listener type: ActionListener Listener method: actionPerformed Method descriptor: public abstract void actionPerformed(ActionEvent) Add Listener Method: public void addActionListener(ActionListener) Remove Listener Method: public void removeActionListener(ActionListener) ==================== 
  This reveals most of what the Introspector sees as it produces a BeanInfo object from your Bean. You can see that the type of the property and its name are independent. Notice the lowercasing of the property name. (The only time this doesn’t occur is when the property name begins with more than one capital letter in a row.) And remember that the method names you’re seeing here (such as the read and write methods) are actually produced from a Method object that can be used to invoke the associated method on the object. 
  The public method list includes the methods that are not associated with a property or an event, such as croak( ), as well as those that are. These are all the methods that you can call programmatically for a Bean, and the IDE can choose to list all of these while you’re making method calls, to ease your task. 
  Finally, you can see that the events are fully parsed out into the listener, its methods, and the add- and remove-listener methods. Basically, once you have the BeanInfo, you can find out everything of importance for the Bean. You can also call the methods for that Bean, even though you don’t have any other information except the object (again, a feature of reflection). 
A more sophisticated Bean
  This next example is slightly more sophisticated, albeit frivolous. It’s a JPanel that draws a little circle around the mouse whenever the mouse is moved. When you press the mouse, the word "Bang!" appears in the middle of the screen, and an action listener is fired. 
  The properties you can change are the size of the circle as well as the color, size, and text of the word that is displayed when you press the mouse. A BangBean also has its own addActionListener( ) and removeActionListener( ), so you can attach your own listener that will be fired when the user clicks on the BangBean. You should recognize the property and event support: 
  The first thing you’ll notice is that BangBean implements the Serializable interface. This means that the IDE can "pickle" all the information for the BangBean by using serialization after the program designer has adjusted the values of the properties. When the Bean is created as part of the running application, these "pickled" properties are restored so that you get exactly what you designed. 
  When you look at the signature for addActionListener( ), you’ll see that it can throw a TooManyListenersException. This indicates that it is unicast, which means it notifies only one listener when the event occurs. Ordinarily, you’ll use multicast events so that many listeners can be notified of an event. However, that runs into threading issues, so it will be revisited in the next section, "JavaBeans and synchronization." In the meantime, a unicast event sidesteps the problem. 
  When you click the mouse, the text is put in the middle of the BangBean, and if the actionListener field is not null, its actionPerformed( ) is called, creating a new ActionEvent object in the process. Whenever the mouse is moved, its new coordinates are captured and the canvas is repainted (erasing any text that’s on the canvas, as you’ll see). 
  Here is the BangBeanTest class to test the Bean: 
  When a Bean is used in an IDE, this class will not be used, but it’s helpful to provide a rapid testing method for each of your Beans. BangBeanTest places a BangBean within the JFrame, attaching a simple ActionListener to the BangBean to print an event count to the JTextField whenever an ActionEvent occurs. Usually, of course, the IDE would create most of the code that uses the Bean. 
  When you run the BangBean through BeanDumper or put the BangBean inside a Bean- enabled development environment, you’ll notice that there are many more properties and actions than are evident from the preceding code. That’s because BangBean is inherited from JPanel, and JPanel is also a Bean, so you’re seeing its properties and events as well. 
  Exercise 35: (6) Locate and download one or more of the free GUI builder development environments available on the Internet, or use a commercial product if you own one. Discover what is necessary to add BangBean to this environment and to use it. 
JavaBeans and synchronization
  Whenever you create a Bean, you must assume that it will run in a multithreaded environment. This means that: 
  1. Whenever possible, all the public methods of a Bean should be synchronized. Of course, this incurs the synchronized runtime overhead (which has been significantly reduced in recent versions of the JDK). If that’s a problem, methods that will not cause problems in critical sections can be left unsynchronized, but keep in mind that such methods are not always obvious. Methods that qualify tend to be small (such as getCircleSize( ) in the following example) and/or "atomic"; that is, the method call executes in such a short amount of code that the object cannot be changed during execution (but review the Concurrency chapter— what you may think is atomic might not be). Making such methods unsynchronized might not have a significant effect on the execution speed of your program. You’re better off making all public methods of a Bean synchronized and removing the synchronized keyword on a method only when you know for sure that it makes a difference and that you can safely remove the keyword. 
  2. When firing a multicast event to a bunch of listeners interested in that event, you must assume that listeners might be added or removed while moving through the list. 
  The first point is fairly straightforward, but the second point requires a little more thought. BangBean.java ducked out of the concurrency question by ignoring the synchronized keyword and making the event unicast. Here is a modified version that works in a multithreaded environment and uses multicasting for events: 
  Adding synchronized to the methods is an easy change. However, notice in addActionListener( ) and removeActionListener( ) that the ActionListeners are now added to and removed from an ArrayList, so you can have as many as you want. 
  You can see that the method notifyListeners( ) is not synchronized. It can be called from more than one thread at a time. It’s also possible for addActionListener( ) or removeActionListener( ) to be called in the middle of a call to notifyListeners( ), which is a problem because it traverses the ArrayList actionListeners. To alleviate the problem, the ArrayList is duplicated inside a synchronized clause, using the ArrayList constructor which copies the elements of its argument, and the duplicate is traversed. This way, the original ArrayList can be manipulated without impact on notifyListeners( ). 
  The paintComponent( ) method is also not synchronized. Deciding whether to synchronize overridden methods is not as clear as when you’re just adding your own methods. In this example, it turns out that paintComponent( ) seems to work OK whether it’s synchronized or not. But the issues you must consider are: 
  1. Does the method modify the state of "critical" variables within the object? To discover whether the variables are "critical," you must determine whether they will be read or set by other threads in the program. (In this case, the reading or setting is virtually always accomplished via synchronized methods, so you can just examine those.) In the case of paintComponent( ), no modification takes place. 
  2. Does the method depend on the state of these "critical" variables? If a synchronized method modifies a variable that your method uses, then you might very well want to make your method synchronized as well. Based on this, you might observe that cSize is changed by synchronized methods, and therefore paintComponent( )    should be synchronized. Here, however, you can ask, "What’s the worst thing that will happen if cSize is changed during a paintComponent( )?" When you see that it’s nothing too bad, and a transient effect at that, you can decide to leave paintComponent( ) unsynchronized to prevent the extra overhead from the synchronized method call. 
  3. A third clue is to notice whether the base-class version of paintComponent( ) is synchronized, which it isn’t. This isn’t an airtight argument, just a clue. In this case, for example, a field that is changed via synchronized methods (that is, cSize) has been mixed into the paintComponent( ) formula and might have changed the situation. Notice, however, that synchronized doesn’t inherit; that is, if a method is synchronized in the base class, then it is not automatically synchronized in the derivedclass overridden version. 
  4. paint( ) and paintComponent( ) are methods that must be as fast as possible. Anything that takes processing overhead out of these methods is highly recommended, so if you think you need to synchronize these methods it may be an indicator of bad design. 
  The test code in main( ) has been modified from that seen in BangBeanTest to demonstrate the multicast ability of BangBean2 by adding extra listeners. 
Packaging a Bean
  Before you can bring a JavaBean into a Bean-enabled IDE, it must be put into a Bean container, which is a JAR file that includes all the Bean classes as well as a "manifest" file that says, "This is a Bean." A manifest file is simply a text file that follows a particular form. For the BangBean, the manifest file looks like this: 
  Manifest-Version: 1.0  Name: bangbean/BangBean.class Java-Bean: True 
  The first line indicates the version of the manifest scheme, which until further notice from Sun is 1.0. The second line (empty lines are ignored) names the BangBean.class file, and the third says, "It’s a Bean." Without the third line, the program builder tool will not recognize the class as a Bean. 
  The only tricky part is that you must make sure that you get the proper path in the "Name:" field. If you look back at BangBean.java, you’ll see it’s in package bangbean (and thus in a subdirectory called bangbean that’s off of the classpath), and the name in the manifest file must include this package information. In addition, you must place the manifest file in the directory above the root of your package path, which in this case means placing the file in the directory above the "bangbean" subdirectory. Then you must invoke jar from the same directory as the manifest file, as follows: 
  jar cfm BangBean.jar BangBean.mf bangbean  This assumes that you want the resulting JAR file to be named BangBean.jar, and that you’ve put the manifest in a file called BangBean.mf. 
  You might wonder, "What about all the other classes that were generated when I compiled BangBean.java?" Well, they all ended up inside the bangbean subdirectory, and you’ll see that the last argument for the above jar command line is the bangbean subdirectory. When you give jar the name of a subdirectory, it packages that entire subdirectory into the JAR file (including, in this case, the original BangBean.java source-code file—you might not choose    to include the source with your own Beans). In addition, if you turn around and unpack the JAR file you’ve just created, you’ll discover that your manifest file isn’t inside, but that jar has created its own manifest file (based partly on yours) called MANIFEST.MF and placed it inside the subdirectory META-INF (for "meta-information"). If you open this manifest file, you’ll also notice that digital signature information has been added by jar for each file, of the form: 
  Digest-Algorithms: SHA MD5 SHA-Digest: pDpEAG9NaeCx8aFtqPI4udSX/O0= MD5-Digest: 04NcSlhE3Smnzlp2hj6qeg==  In general, you don’t need to worry about any of this, and if you make changes, you can just modify your original manifest file and reinvoke jar to create a new JAR file for your Bean. You can also add other Beans to the JAR file simply by adding their information to your manifest. 
  One thing to notice is that you’ll probably want to put each Bean in its own subdirectory, since when you create a JAR file you hand the jar utility the name of a subdirectory, and it puts everything in that subdirectory into the JAR file. You can see that both Frog and BangBean are in their own subdirectories. 
  Once you have your Bean properly inside a JAR file, you can bring it into a Beans-enabled IDE. The way you do this varies from one tool to the next, but Sun provides a freely available test bed for JavaBeans in its "Bean Builder." (Download from http://java.sun.com/beans.) You place a Bean into the Bean Builder by simply copying the JAR file into the correct subdirectory. 
  Exercise 36: (4) Add Frog.class to the manifest file in this section and run jar to create a JAR file containing both Frog and BangBean. Now either download and install the Bean Builder from Sun, or use your own Beans-enabled program builder tool and add the JAR file to your environment so you can test the two Beans. 
  Exercise 37: (5) Create your own JavaBean called Valve that contains two properties: a boolean called "on" and an int called "level." Create a manifest file, use jar to package your Bean, then load it into the Bean Builder or into a Beans-enabled program builder tool so that you can test it. 
More complex Bean support
  You can see how remarkably simple it is to make a Bean, but you aren’t limited to what you’ve seen here. The JavaBeans architecture provides a simple point of entry but can also scale to more complex situations. These situations are beyond the scope of this book, but they will be briefly introduced here. You can find more details at http://java.sun.com/beans. 
  One place where you can add sophistication is with properties. The examples you’ve seen here have shown only single properties, but it’s also possible to represent multiple properties in an array. This is called an indexed property. You simply provide the appropriate methods (again following a naming convention for the method names), and the Introspector recognizes an indexed property so that your IDE can respond appropriately. 
  Properties can be bound, which means that they will notify other objects via a PropertyChangeEvent. The other objects can then choose to change themselves based on the change to the Bean. 
  Properties can be constrained, which means that other objects can veto a change to that property if it is unacceptable. The other objects are notified by using a    PropertyChangeEvent, and they can throw a PropertyVetoException to prevent the change from happening and to restore the old values. 
  You can also change the way your Bean is represented at design time: 
  1. You can provide a custom property sheet for your particular Bean. The ordinary property sheet will be used for all other Beans, but yours is automatically invoked when your Bean is selected. 
  2. You can create a custom editor for a particular property, so the ordinary property sheet is used, but when your special property is being edited, your editor will automatically be invoked. 
  3. You can provide a custom BeanInfo class for your Bean that produces information different from the default created by the Introspector. 
  4. It’s also possible to turn "expert" mode on and off in all FeatureDescriptors to distinguish between basic features and more complicated ones. 
More to Beans
  There are a number of books about JavaBeans; for example, JavaBeans by Elliotte Rusty Harold (IDG, 1998). 
