  The way that you place components on a form in Java is probably different from any other GUI system you’ve used. First, it’s all code; there are no "resources" that control placement of components. Second, the way components are placed on a form is controlled not by absolute positioning but by a "layout manager" that decides how the components lie based on the order that you add( ) them. The size, shape, and placement of components will be remarkably different from one layout manager to another. In addition, the layout managers adapt to the dimensions of your applet or application window, so if the window dimension is changed, the size, shape, and placement of the components can change in response. 
  JApplet, JFrame, JWindow, JDialog, JPanel, etc., can all contain and display Components. In Container, there’s a method called setLayout( ) that allows you to choose a different layout manager. In this section we’ll explore the various layout managers by placing buttons in them (since that’s the simplest thing to do). These examples won’t capture the button events because they are only intended to show how the buttons are laid out. 
BorderLayout
  Unless you tell it otherwise, a JFrame will use BorderLayout as its default layout scheme. Without any other instruction, this takes whatever you add( ) to it and places it in the center, stretching the object all the way out to the edges. 
  BorderLayout has the concept of four border regions and a center area. When you add something to a panel that’s using a BorderLayout, you can use the overloaded add( ) method that takes a constant value as its first argument. This value can be any of the following: 
  BorderLayout.NORTH Top BorderLayout.SOUTH Bottom BorderLayout.EAST Right BorderLayout.WEST Left BorderLayout.CENTER Fill the middle, up to the other components or to the edges  If you don’t specify an area to place the object, it defaults to CENTER. 
  In this example, the default layout is used, since JFrame defaults to BorderLayout: 
  For every placement but CENTER, the element that you add is compressed to fit in the smallest amount of space along one dimension while it is stretched to the maximum along the other dimension. CENTER, however, spreads out in both dimensions to occupy the middle. 
FlowLayout
  This simply "flows" the components onto the form, from left to right until the top space is full, then moves down a row and continues flowing. 
  Here’s an example that sets the layout manager to FlowLayout and then places buttons on the form. You’ll notice that with FlowLayout, the components take on their "natural" size. A JButton, for example, will be the size of its string. 
  All components will be compacted to their smallest size in a FlowLayout, so you might get a little bit of surprising behavior. For example, because a JLabel will be the size of its string, attempting to right-justify its text yields an unchanged display when using FlowLayout. 
  Notice that if you resize the window, the layout manager will reflow the components accordingly. 
GridLayout
  A GridLayout allows you to build a table of components, and as you add them, they are placed left to right and top to bottom in the grid. In the constructor, you specify the number of rows and columns that you need, and these are laid out in equal proportions. 
  In this case there are 21 slots but only 20 buttons. The last slot is left empty because no "balancing" goes on with a GridLayout. 
GridBagLayout
  The GridBagLayout provides you with tremendous control in deciding exactly how the regions of your window will lay themselves out and reformat themselves when the window is resized. However, it’s also the most complicated layout manager, and is quite difficult to understand. It is intended primarily for automatic code generation by a GUI builder (GUI builders might use GridBagLayout instead of absolute placement). If your design is so complicated that you feel you need to use GridBagLayout, then you should be using a GUI builder tool to generate that design. If you feel you must know the intricate details, I’ll refer you to one of the dedicated Swing books as a starting point. 
  As an alternative, you may want to consider TableLayout, which is not part of the Swing library but which can be downloaded from http://java.sun.com. This component is layered on top of GridBagLayout and hides most of its complexity, so it can greatly simplify this approach. 
  
Absolute positioning
  It is also possible to set the absolute position of the graphical components: 
  1. Set a null layout manager for your Container: setLayout(null). 
  2. Call setBounds( ) or reshape( ) (depending on the language version) for each component, passing a bounding rectangle in pixel coordinates. You can do this in the constructor or in paint( ), depending on what you want to achieve. 
  Some GUI builders use this approach extensively, but this is usually not the best way to generate code. 
BoxLayout
  Because people had so much trouble understanding and working with GridBagLayout, Swing also includes BoxLayout, which gives you many of the benefits of GridBagLayout without the complexity. You can often use it when you need to do hand-coded layouts (again, if your design becomes too complex, use a GUI builder that generates layouts for you). BoxLayout allows you to control the placement of components either vertically or horizontally, and to control the space between the components using something called "struts and glue." You can find some basic examples of BoxLayout in the online supplements for this book at www.MindView.net. 
The best approach?
  Swing is powerful; it can get a lot done with a few lines of code. The examples shown in this book are quite simple, and for learning purposes it makes sense to write them by hand. You can actually accomplish quite a bit by combining simple layouts. At some point, however, it stops making sense to hand-code GUI forms; it becomes too complicated and is not a good use of your programming time. The Java and Swing designers oriented the language and libraries to support GUI-building tools, which have been created for the express purpose of making your programming experience easier. As long as you understand what’s going on with layouts and how to deal with events (described next), it’s not particularly important that you actually know the details of how to lay out components by hand; let the appropriate tool do that for you (Java is, after all, designed to increase programmer productivity). 
