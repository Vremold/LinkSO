  When you program with Swing you’re using threads. You saw this at the beginning of this chapter when you learned that everything should be submitted to the Swing event dispatch thread through SwingUtilities.invokeLater( ). However, the fact that you don’t have to explicitly create a Thread object means that threading issues can catch you by surprise. You must keep in mind that there is a Swing event dispatch thread, which is always there, handling all the Swing events by pulling each one out of the event queue and executing it in turn. By remembering the event dispatch thread you’ll help ensure that your application won’t suffer from deadlocking or race conditions. 
  This section addresses threading issues that arise when working with Swing. 
Long-running tasks
  One of the most fundamental mistakes you can make when programming with a graphical user interface is to accidentally use the event dispatch thread to run a long task. Here’s a simple example: 
  When you press b1, the event dispatch thread is suddenly occupied in performing the long- running task. You’ll see that the button doesn’t even pop back out, because the event dispatch thread that would normally repaint the screen is busy. And you cannot do anything else, like press b2, because the program won’t respond until b1’s task is complete and the event dispatch thread is once again available. The code in b2 is a flawed attempt to solve the problem by interrupting the event dispatch thread. 
  The answer, of course, is to execute long-running processes in separate threads. Here, the single-thread Executor is used, which automatically queues pending tasks and executes them one at a time: 
  This is better, but when you press b2, it calls shutdownNow( ) on the ExecutorService, thereby disabling it. If you try to add more tasks, you get an exception. Thus, pressing b2 makes the program inoperable. What we’d like to do is to shut down the current task (and cancel pending tasks) without stopping everything. The Java SE5 Callable/Future mechanism described in the Concurrency chapter is just what we need. We’ll define a new class called TaskManager, which contains tuples that hold the Callable representing the task and the Future that comes back from the Callable. The reason the tuple is necessary is because it allows us to keep track of the original task, so that we may get extra information that is not available from the Future. Here it is: 
  In the java.util.concurrent library, the task is not available via the Future by default because the task would not necessarily still be around when you get the result from the Future. Here, we force the task to stay around by storing it. 
  TaskManager is placed in net.mindview.util so it is available as a general-purpose utility: 
  TaskManager is an ArrayList of Taskltem. It also contains a singlethread Executor, so when you call add( ) with a Callable, it submits the Callable and stores the resulting Future along with the original task. This way, if you need to do anything with the task, you have a reference to that task. As a simple example, in purge( ) the task’s toString( ) is used. 
  This can now be used to manage the long-running tasks in our example: 
  As you can see, CallableTask does exactly the same thing as Task except that it returns a result—in this case a String identifying the task. 
  Non-Swing utilities (not part of the standard Java distribution) called SwingWorker (from the Sun Web site) and Foxtrot (from http://foxtrot.sourceforge.net) were created to solve a similar problem, but at this writing, those utilities had not been modified to take advantage of the Java SE5 Callable/Future mechanism. 
  It’s often important to give the end user some kind of visual cue that a task is running, and of its progress. This is normally done through either a JProgressBar or a ProgressMonitor. This example uses a ProgressMonitor: 
  The MonitoredCallable constructor takes a ProgressMonitor as an argument, and its call( ) method updates the ProgressMonitor every half second. Notice that a    MonitoredCallable is a separate task and thus should not try to control the UI directly, so SwingUtilities.invokeLater( ) is used to submit the progress change information to the monitor. Sun’s Swing Tutorial (on http://java.sun.com) shows an alternate approach of using a Swing Timer, which checks the status of the task and updates the monitor. 
  If the "cancel" button is pressed on the monitor, monitor.isCanceled( ) will return true. Here, the task just calls interrupt ) on its own thread, which will land it in the catch clause where the monitor is terminated with the close( ) method. 
  The rest of the code is effectively the same as before, except for the creation of the ProgressMonitor as part of the MonitoredLongRunningCallable constructor. 
  Exercise 33: (6) Modify InterruptableLongRunningCallable.java so that it runs all the tasks in parallel rather than sequentially. 
Visual threading
  The following example makes a Runnable JPanel class that paints different colors on itself. This application is set up to take values from the command line to determine how big the grid of colors is and how long to sleep( ) between color changes. By playing with these values, you may discover some interesting and possibly inexplicable features in the threading implementation on your platform: 
  ColorBoxes configures a GridLayout so that it has grid cells in each dimension. Then it adds the appropriate number of CBox objects to fill the grid, passing the pause value to each one. In main( ) you can see how pause and grid have default values that can be changed if you pass in command-line arguments. 
  CBox is where all the work takes place. This is inherited from JPanel and it implements the Runnable interface so that each JPanel can also be an independent task. These tasks are driven by a thread pool ExecutorService. 
  The current cell color is color. Colors are created using the Color constructor that takes a  paintComponent( ) is quite simple; it just sets the color to color and fills the entire JPanel with that color. 
  In run( ), you see the infinite loop that sets the color to a new random color and then calls repaint( ) to show it. Then the thread goes to sleep( ) for the amount of time specified on the command line. 
  The call to repaint( ) in run( ) deserves examination. At first glance, it may seem like we’re creating a lot of threads, each of which is forcing a paint. It might appear that this is violating the principle that you should only submit tasks to the event queue. However, these threads are not actually modifying the shared resource. When they call repaint( ), it doesn’t force a paint at that time, but only sets a "dirty flag" indicating that the next time the event dispatch thread is ready to repaint things, this area is a candidate for repainting. Thus the program doesn’t cause Swing threading problems. 
  When the event dispatch thread actually does perform a paint( ), it first calls paintComponent( ), then paintBorder( ) and paintChildren( ). If you need to override paint( ) in a derived component, you must remember to call the base-class version of paint( ) so that the proper actions are still performed. 
  Precisely because this design is flexible and threading is tied to each JPanel element, you can experiment by making as many threads as you want. (In reality, there is a restriction imposed by the number of threads your JVM can comfortably handle.)  This program also makes an interesting benchmark, since it can show dramatic performance and behavioral differences between one JVM threading implementation and another, as well as on different platforms. 
  Exercise 34: (4) Modify ColorBoxes.java so that it begins by sprinkling points ("stars") across the canvas, then randomly changes the colors of those "stars." 
