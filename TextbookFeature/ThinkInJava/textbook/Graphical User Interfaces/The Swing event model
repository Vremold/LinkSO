  In the Swing event model, a component can initiate ("fire") an event. Each type of event is represented by a distinct class. When an event is fired, it is received by one or more "listeners," which act on that event. Thus, the source of an event and the place where the event is handled can be separate. Since you typically use Swing components as they are, but need to write custom code that is called when the components receive an event, this is an excellent example of the separation of interface from implementation. 
  Each event listener is an object of a class that implements a particular type of listener interface. So as a programmer, all you do is create a listener object and register it with the component that’s firing the event. This registration is performed by calling an addXXXListener( ) method in the event-firing component, in which "XXX" represents the type of event listened for. You can easily know what types of events can be handled by noticing the names of the "addListener" methods, and if you try to listen for the wrong events, you’ll discover your mistake at compile time. You’ll see later in the chapter that    JavaBeans also use the names of the "addListener" methods to determine what events a Bean can handle. 
  All of your event logic, then, will go inside a listener class. When you create a listener class, the sole restriction is that it must implement the appropriate interface. You can create a global listener class, but this is a situation in which inner classes tend to be quite useful, not only because they provide a logical grouping of your listener classes inside the UI or business logic classes they are serving, but also because an inner-class object keeps a reference to its parent object, which provides a nice way to call across class and subsystem boundaries. 
  All the examples so far in this chapter have been using the Swing event model, but the remainder of this section will fill out the details of that model. 
Event and listener types
  All Swing components include addXXXListener( ) and removeXXXListener( ) methods so that the appropriate types of listeners can be added and removed from each component. You’ll notice that the "XXX" in each case also represents the argument for the method, for example, addMyListener(MyListener m). The following table includes the basic associated events, listeners, and methods, along with the basic components that support those particular events by providing the addXXXListener( ) and removeXXXListener( ) methods. You should keep in mind that the event model is designed to be extensible, so you may encounter other events and listener types that are not covered in this table. 
  Event, listener interface, and Components supporting this add- and remove-methods event ActionEvent JButton, JList, JTextField, ActionListener JMenuItem and its derivatives addActionListener( ) including JCheckBoxMenuItem, removeActionListener( ) JMenu, and JRadioButtonMenuItem AdjustmentEvent JScrollbar AdjustmentListener and anything you create that addAdjustmentListener( ) implements the Adjustable removeAdjustmentListener( ) interface ComponentEvent *Component and its derivatives, ComponentListener including JButton, JCheckBox, addComponentListener( ) JComboBox, Container, JPanel, removeComponentListener( ) JApplet, JScrollPane, Window, JDialog, JFileDialog, JFrame, JLabel, JList, JScrollbar, JTextArea, and JTextField ContainerEvent Container and its derivatives, addContainerListener( ) JScrollPane, Window, JDialog, removeContainerListener( ) JFileDialog, and JFrame FocusEvent Component and derivatives* FocusListener addFocusListener( ) removeFocusListener( ) KeyEvent Component and derivatives* KeyListener addKeyListener( ) removeKeyListener( )    Event, listener interface, and Components supporting this add- and remove-methods event MouseEvent (for both clicks and Component and derivatives* motion) MouseListener addMouseListener( ) removeMouseListener( ) MouseEvent6 (for both clicks and Component and derivatives* motion) MouseMotionListener addMouseMotionListener( ) removeMouseMotionListener( ) WindowEvent Window and its derivatives, WindowListener including JDialog, JFileDialog, addWindowListener( ) and JFrame removeWindowListener( ) ItemEvent JCheckBox, ItemListener JCheckBoxMenuItem, addItemListener( ) JComboBox, JList, and anything removeItemListener( ) that implements the ItemSelectable interface TextEvent Anything derived from TextListener JTextComponent, including addTextListener( ) JTextArea and JTextField removeTextListener( ) 
  You can see that each type of component supports only certain types of events. It turns out to be rather tedious to look up all the events supported by each component. A simpler approach is to modify the ShowMethods.java program from the Type Information chapter so that it displays all the event listeners supported by any Swing component that you enter. 
  The Type Information chapter introduced reflection and used that feature to look up methods for a particular class—either the entire list of methods or a subset of those whose names match a keyword that you provide. The magic of reflection is that it can automatically show you all the methods for a class without forcing you to walk up the inheritance hierarchy, examining the base classes at each level. Thus, it provides a valuable timesaving tool for programming; because the names of most Java methods are made nicely verbose and descriptive, you can search for the method names that contain a particular word of interest. When you find what you think you’re looking for, check the JDK documentation. 
  Here is the more useful GUI version of ShowMethods.java, specialized to look for the "addListener" methods in Swing components: 
  You enter the Swing class name that you want to look up in the name JTextField. The results are extracted using regular expressions, and displayed in a JTextArea. 
  You’ll notice that there are no buttons or other components to indicate that you want the search to begin. That’s because the JTextField is monitored by an ActionListener. Whenever you make a change and press Enter, the list is immediately updated. If the text field isn’t empty, it is used inside Class.forName( ) to try to look up the class. If the name is incorrect, Class.forName( ) will fail, which means that it throws an exception. This is trapped, and the JTextArea is set to "No match." But if you type in a correct name (capitalization counts), Class.forName( ) is successful, and getMethods( ) will return an array of Method objects. 
  Two regular expressions are used here. The first, addListener, looks for "add" followed by any word characters, followed by "Listener" and the argument list in parentheses. Notice that this whole regular expression is surrounded by non-escaped parentheses, which means it will be accessible as a regular expression "group" when it matches. Inside NameL.ActionPerformed( ), a Matcher is created by passing each Method object to the Pattern.matcher( ) method. When find( ) is called for this Matcher object, it returns true only if a match occurs, and in that case you can select the first matching parenthesized group by calling group(1). This string still contains qualifiers, so to strip them off, the qualifier Pattern object is used just as it was in ShowMethods.java. 
  At the end of the constructor, an initial value is placed in name and the action event is run to provide a test with initial data. 
  This program is a convenient way to investigate the capabilities of a Swing component. Once you know which events a particular component supports, you don’t need to look anything up to react to that event. You simply: 
  1. Take the name of the event class and remove the word "Event." Add the word "Listener" to what remains. This is the listener interface you must implement in your inner class. 
  2. Implement the interface above and write out the methods for the events you want to capture. For example, you might be looking for mouse movements, so you write code for the mouseMoved( ) method of the MouseMotionListener interface. (You must implement the other methods, of course, but there’s often a shortcut for this, which you’ll see soon.)  3. Create an object of the listener class in Step 2. Register it with your component with the method produced by prefixing "add" to your listener name. For example, addMouseMotionListener( ). 
  Here are some of the listener interfaces: 
  Listener interface Methods in interface w/ adapter ActionListener actionPerformed(ActionEvent) AdjustmentListener adjustmentValueChanged( AdjustmentEvent) ComponentListener componentHidden(ComponentEvent) ComponentAdapter componentShown(ComponentEvent) componentMoved(ComponentEvent) componentResized(ComponentEvent) ContainerListener componentAdded(ContainerEvent) ContainerAdapter componentRemoved(ContainerEvent) FocusListener focusGained(FocusEvent) FocusAdapter focusLost(FocusEvent) KeyListener keyPressed(KeyEvent) KeyAdapter keyReleased(KeyEvent) keyTyped(KeyEvent) MouseListener mouseClicked(MouseEvent) MouseAdapter mouseEntered(MouseEvent) mouseExited(MouseEvent) mousePressed(MouseEvent) mouseReleased(MouseEvent)    Listener interface Methods in interface w/ adapter MouseMotionListener mouseDragged(MouseEvent) MouseMotionAdapter mouseMoved(MouseEvent) WindowListener windowOpened(WindowEvent) WindowAdapter windowClosing(WindowEvent) windowClosed(WindowEvent) windowActivated(WindowEvent) windowDeactivated(WindowEvent) windowIconified(WindowEvent) windowDeiconified(WindowEvent) ItemListener itemStateChanged(ItemEvent) 
  This is not an exhaustive listing, partly because the event model allows you to create your own event types and associated listeners. Thus, you’ll regularly come across libraries that have invented their own events, and the knowledge gained in this chapter will allow you to figure out how to use these events. 
  Using listener adapters for simplicity  In the table above, you can see that some listener interfaces have only one method. These are trivial to implement. However, the listener interfaces that have multiple methods can be less pleasant to use. For example, if you want to capture a mouse click (that isn’t already captured for you, for example, by a button), then you need to write a method for mouseClicked( ). But since MouseListener is an interface, you must implement all of the other methods even if they don’t do anything. This can be annoying. 
  To solve the problem, some (but not all) of the listener interfaces that have more than one method are provided with adapters, the names of which you can see in the table above. Each adapter provides default empty methods for each of the interface methods. When you inherit from the adapter, you override only the methods you need to change. For example, the typical MouseListener you’ll use looks like this: 
  class MyMouseListener extends MouseAdapter { public void mouseClicked(MouseEvent e) { // Respond to mouse click... } } 
  The whole point of the adapters is to make the creation of listener classes easy. 
  There is a downside to adapters, however, in the form of a pitfall. Suppose you write a MouseAdapter like the previous one: 
  class MyMouseListener extends MouseAdapter { public void MouseClicked(MouseEvent e) { // Respond to mouse click... } } 
  This doesn’t work, but it will drive you crazy trying to figure out why, since everything will compile and run fine—except that your method won’t be called for a mouse click. Can you see the problem? It’s in the name of the method: MouseClicked( ) instead of mouseClicked( ). A simple slip in capitalization results in the addition of a completely new method. However, this is not the method that’s called when the mouse is clicked, so you don’t get the    desired results. Despite the inconvenience, an interface will guarantee that the methods are properly implemented. 
  An improved alternative way to guarantee that you are in fact overriding a method is to use the built-in @Override annotation in the code above. 
  Exercise 9: (5) Starting with ShowAddListeners.java, create a program with the full functionality of typeinfo.ShowMethods.java. 
Tracking multiple events
  To prove to yourself that these events are in fact being fired, it’s worth creating a program that tracks behavior in a JButton beyond whether it has been pressed. This example also 7 shows you how to inherit your own button object from JButton. 
  In the code below, the MyButton class is an inner class of TrackEvent, so MyButton can reach into the parent window and manipulate its text fields, which is necessary in order to write the status information into the fields of the parent. Of course, this is a limited solution, since MyButton can be used only in conjunction with TrackEvent. This kind of code is sometimes called "highly coupled": 
  In the MyButton constructor, the button’s color is set with a call to SetBackground( ). The listeners are all installed with simple method calls. 
  The TrackEvent class contains a HashMap to hold the strings representing the type of event and JTextFields where information about that event is held. Of course, these could have been created statically rather than putting them in a HashMap, but I think you’ll agree that it’s a lot easier to use and change. In particular, if you need to add or remove a new type of event in TrackEvent, you simply add or remove a string in the event array— everything else happens automatically. 
  When report( ) is called, it is given the name of the event and the parameter string from the event. It uses the HashMap h in the outer class to look up the actual JTextField associated with that event name and then places the parameter string into that field. 
  This example is fun to play with because you can really see what’s going on with the events in your program. 
  Exercise 10: (6) Create an application using SwingConsole, with a JButton and a JTextField. Write and attach the appropriate listener so that if the button has the focus, characters typed into it will appear in the JTextField. 
  Exercise 11: (4) Inherit a new type of button from JButton. Each time you press this button, it should change its color to a randomly selected value. See ColorBoxes.java (later in this chapter) for an example of how to generate a random color value. 
  Exercise 12: (4) Monitor a new type of event in TrackEvent.java by adding the new event-handling code. You’ll need to discover on your own the type of event that you want to monitor. 
