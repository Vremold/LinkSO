  As previously noted, Swing took the approach of building all the UI components pixel-by- pixel, in order to provide every component desired whether the underlying OS had those components or not. SWT takes the middle ground by using native components if the OS provides them, and synthesizing components if it doesn’t. The result is an application that feels to the user like a native application, and often has noticeably faster performance than the equivalent Swing program. In addition, SWT tends to be a less complex programming 12 model than Swing, which can be desirable in a large portion of applications. 
  Because SWT uses the native OS to do as much of its work as possible, it can automatically take advantage of OS features that may not be available to Swing—for example, Windows has "subpixel rendering" that makes fonts on LCD screens clearer. 
  It’s even possible to create applets using SWT. 
  This section is not meant to be a comprehensive introduction to SWT; it’s just enough to give you a flavor of it, and to see how SWT contrasts with Swing. You’ll discover that there are lots of SWT widgets and that they are all reasonably straightforward to use. You can explore the details in the full documentation and many examples that can be found at www.eclipse.org. There are also a number of books on programming with SWT, and more on the way. 
Installing SWT
  SWT applications require downloading and installing the SWT library from the Eclipse project. Go to www.eclipse.org/downloads/ and choose a mirror. Follow the links to the current Eclipse build and locate a compressed file with a name that begins with "swt" and includes the name of your platform (for example, "win32"). Inside this file you’ll find swt.jar. The easiest way to install the swt.jar file is to put it into your jre/lib/ext directory (that way you don’t have to make any modifications to your classpath). When you decompress the SWT library, you may find additional files that you need to install in appropriate places for your platform. For example, the Win32 distribution comes with DLL files that need to be placed somewhere in your java.library.path (this is usually the same      as your PATH environment variable, but you can run object/ShowProperties.java to discover the actual value of java.library.path). Once you’ve done this, you should be able to transparently compile and execute an SWT application as if it were any other Java program. 
  The documentation for SWT is in a separate download. 
  An alternative approach is just to install the Eclipse editor, which includes both SWT and the SWT documentation that you can view through the Eclipse help system. 
Hello, SWT
  Let’s start with the simplest possible "hello world"-style application: 
  If you download the source code from this book, you’ll discover that the "Requires" comment directive ends up in the Ant build.xml as a prerequisite for building the swt subdirectory; all the files that import org.eclipse.swt require that you install the SWT library from www.eclipse.org. 
  The Display manages the connection between SWT and the underlying operating system—it is part of a Bridge between the operating system and SWT. The Shell is the top-level main window, within which all the other components are built. When you call setText( ), the argument becomes the label on the title bar of the window. 
  To display the window and thus the application, you must call open( ) on the Shell. 
  Whereas Swing hides the event-handling loop from you, SWT forces you to write it explicitly. At the top of the loop, you check to see whether the shell has been disposed—note that this gives you the option of inserting code to perform cleanup activities. But this means that the main( ) thread is the user interface thread. In Swing, a second event-dispatching thread is created behind the scenes, but in SWT your main( ) thread is what handles the UI. Since by default there’s only one thread and not two, this makes it somewhat less likely that you’ll clobber the UI with threads. 
  Notice that you don’t have to worry about submitting tasks to the user interface thread like you do in Swing. SWT not only takes care of this for you, it throws an exception if you try to manipulate a widget with the wrong thread. However, if you need to spawn other threads to perform long-running operations, you still need to submit changes in the same way that you do with Swing. For this, SWT provides three methods which can be called on the Display object: asyncExec(Runnable), syncExec(Runnable) and timerExec(int, Runnable). 
  The activity of your main( ) thread at this point is to call readAndDispatch( ) on the Display object (this means that there can only be one Display object per application). The readAndDispatch( ) method returns true if there are more events in the event queue, waiting to be processed. In that case, you want to call it again, immediately. However, if nothing is pending, you call the Display object’s sleep( ) to wait for a short time before checking the event queue again. 
  Once the program is complete, you must explicitly dispose( ) of your Display object. SWT often requires you to explicitly dispose of resources, because these are usually resources from the underlying operating system, which may otherwise become exhausted. 
  To prove that the Shell is the main window, here’s a program that makes a number of Shell objects: 
  When you run it, you’ll get ten main windows. The way the program is written, if you close any one of the windows, it will close all of them. 
  SWT also uses layout managers—different ones than Swing, but the same idea. Here’s a slightly more complex example that takes the text from System.getProperties( ) and adds it to the shell: 
  In SWT, all widgets must have a parent object of the general type Composite, and you must provide this parent as the first argument in the widget constructor. You see this in the Text constructor, where shell is the first argument. Virtually all constructors also take a flag argument that allows you to provide any number of style directives, depending on what that particular widget accepts. Multiple style directives are bitwise-ORed together as seen in this example. 
  When setting up the Text( ) object, I added style flags so that it wraps the text, and automatically adds a vertical scroll bar if it needs to. You’ll discover that SWT is very constructor-based; there are many attributes of a widget that are difficult or impossible to change except via the constructor. Always check a widget constructor’s documentation for the accepted flags. Note that some constructors require a flag argument even when they have no "accepted" flags listed in the documentation. This allows future expansion without modifying the interface. 
Eliminating redundant code
  Before going on, notice that there are certain things you do for every SWT application, just like there were duplicate actions for Swing programs. For SWT, you always create a Display, make a Shell from the Display, create a readAndDispatch( ) loop, etc. Of course, in some special cases, you may not do this, but it’s common enough that it’s worth trying to eliminate the duplicate code as we did with net.mindview.util.SwingConsole. 
  We’ll need to force each application to conform to an interface: 
  The application is handed a Composite object (Shell is a subclass) and must use this to create all of its contents inside createContents( ). SWTConsole.run( ) calls createContents( ) at the appropriate point, sets the size of the shell according to what the user passes to run( ), opens the shell and then runs the event loop, and finally disposes of the shell at program exit: 
  This also sets the title bar to the name of the SWTApplication class, and sets the width and height of the Shell. 
  We can create a variation of DisplayProperties.Java that displays the machine environment, using SWTConsole: 
  SWTConsole allows us to focus on the interesting aspects of an application rather than the repetitive code. 
  Exercise 40: (4) Modify DisplayProperties.java so that it uses SWTConsole. 
  Exercise 41: (4) Modify Display Environment.java so that it does nor use SWTConsole. 
Menus
  To demonstrate basic menus, this example reads its own source code and breaks it into words, then populates the menus with these words: 
  A Menu must be placed on a Shell, and Composite allows you to fetch its shell with getShell( ). TextFile is from net.mindview.util and has been described earlier in the book; here a TreeSet is filled with words so they will appear in sorted order. The initial elements are numbers, which are discarded. Using the stream of words, the top-level menus on the menu bar are named, then the submenus are created and filled with words until there are no more words. 
  In response to selecting one of the menu items, the Listener simply prints the event so you can see what kind of information it contains. When you run the program, you’ll see that part of the information includes the label on the menu, so you can base the menu response on that—or you can provide a different listener for each menu (which is the safer approach, for internationalization). 
Tabbed panes, buttons, and events
  SWT has a rich set of controls, which they call widgets. Look at the documentation for org.eclipse.swt.widgets to see the basic ones, and org.eclipse.swt.custom to see fancier ones. 
  To demonstrate a few of the basic widgets, this example places a number of sub-examples inside tabbed panes. You’ll also see how to create Composites (roughly the same as Swing JPanels) in order to put items within items. 
  Here, createContents( ) sets the layout and then calls the methods that each create a different tab. The text on each tab is set with setText( ) (you can also create buttons and graphics on a tab), and each one also sets its tool tip text. At the end of each method, you’ll see a call to setControl( ), which places the control that the method created into the dialog space of that particular tab. 
  labelTab( ) demonstrates a simple text label. directoryDialogTab( ) holds a button which opens a standard DirectoryDialog object so the user can select a directory. The result is set as the button’s text. 
  buttonTab( ) shows the different basic buttons. sliderTab( ) repeats the Swing example from earlier in the chapter of tying a slider to a progress bar. 
  scribbleTab( ) is a fun example of graphics. A drawing program is produced from only a few lines of code. 
  Finally, browserTab( ) shows the power of the SWT Browser component—a full-featured Web browser in a single component. 
Graphics
  Here’s the Swing SineWave.java program translated to SWT: 
  Instead of JPanel, the basic drawing surface in SWT is Canvas. 
  If you compare this version of the program with the Swing version, you’ll see that SineDraw is virtually identical. In SWT, you get the graphics context gc from the event object that’s handed to the PaintListener, and in Swing the Graphics object is handed directly to the paintComponent( ) method. But the activities performed with the graphics object are the same, and setCycles( ) is identical. 
  createContents( ) requires a bit more code than the Swing version, to lay things out and set up the slider and its listener, but again, the basic activities are roughly the same. 
Concurrency in SWT
  Although AWT/Swing is single-threaded, it’s easily possible to violate that single- threadedness in a way that produces a non-deterministic program. Basically, you don’t want to have multiple threads writing to the display because they will write over each other in surprising ways. 
  SWT doesn’t allow this—it throws an exception if you try to write to the display using more than one thread. This will prevent a novice programmer from accidentally making this mistake and introducing hard-to-find bugs into a program. 
  Here is the translation of the Swing ColorBoxes.java program in SWT: 
  As in the previous example, painting is controlled by creating a PaintListener with a paintControl( ) method that is called when the SWT thread is ready to paint your component. The PaintListener is registered in the CBox constructor. 
  What’s notably different in this version of CBox is the run( ) method, which cannot just call redraw( ) directly but must submit the redraw( ) to the asyncExec( ) method on the Display object, which is roughly the same as SwingUtilities.invokeLater( ). If you replace this with a direct call to redraw( ), you’ll see that the program just stops. 
  When running the program, you will see little visual artifacts—horizontal lines occasionally running through a box. This is because SWT is not doublebuffered by default, while Swing is. Try running the Swing version side by side with the SWT version and you’ll see it more clearly. You can write code to double-buffer SWT; you’ll find examples on the www.eclipse.org Web site. 
  Exercise 42: (4) Modify swt/ColorBoxes.java so that it begins by sprinkling points ("stars") across the canvas, then randomly changes the colors of those "stars." 
  
SWT vs. Swing?
  It’s hard to get a complete picture from such a short introduction, but you should at least start to see that SWT, in many situations, can be a more straightforward way to write code than Swing. However, GUI programming in SWT can still be complex, so your motivation for using SWT should probably be, first, to give the user a more transparent experience when using your application (because the application looks/feels like the other applications on that platform), and second, if the responsiveness provided by SWT is important. Otherwise, Swing may be an appropriate choice. 
  Exercise 43: (6) Choose any one of the Swing examples that wasn’t translated in this section, and translate it to SWT. (Note: This makes a good homework exercise for a class, since the solutions are not in the solution guide.)       
