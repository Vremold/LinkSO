  If you compile and run the preceding program, nothing happens when you press the buttons. This is where you must step in and write some code to determine what will happen. The basis of event-driven programming, which comprises a lot of what a GUI is about, is connecting events to the code that responds to those events. 
  The way this is accomplished in Swing is by cleanly separating the interface (the graphical components) from the implementation (the code that you want to run when an event happens to a component). Each Swing component can report all the events that might happen to it, and it can report each kind of event individually. So if you’re not interested in, for example, whether the mouse is being moved over your button, you don’t register your interest in that event. It’s a very straightforward and elegant way to handle event-driven programming, and once you understand the basic concepts, you can easily use Swing components that you haven’t seen before—in fact, this model extends to anything that can be classified as a JavaBean (discussed later in the chapter). 
  At first, we will just focus on the main event of interest for the components being used. In the case of a JButton, this "event of interest" is that the button is pressed. To register your interest in a button press, you call the JButton’s addActionListener( ) method. This method expects an argument that is an object that implements the ActionListener interface. That interface contains a single method called actionPerformed( ). So to attach code to a JButton, implement the ActionListener interface in a class, and register an object of that class with the JButton via addActionListener( ). The actionPerformed( ) method will then be called when the button is pressed (this is normally referred to as a callback). 
  But what should the result of pressing that button be? We’d like to see something change on the screen, so a new Swing component will be introduced: the JTextField. This is a place where text can be typed by the end user or, in this case, inserted by the program. Although there are a number of ways to create a JTextField, the simplest is just to tell the constructor how wide you want that field to be. Once the JTextField is placed on the form, you can modify its contents by using the setText( ) method (there are many other methods in JTextField, but you must look these up in the JDK documentation from http://java.sun.com). Here is what it looks like: 
  Creating a JTextField and placing it on the canvas takes the same steps as for JButtons or for any Swing component. The difference in the preceding program is in the creation of the aforementioned ActionListener class ButtonListener. The argument to actionPerformed( ) is of type ActionEvent, which contains all the information about the event and where it came from. In this case, I wanted to describe the button that was pressed; getSource( ) produces the object where the event originated, and I assumed (using a cast) that the object is a JButton. getText( ) returns the text that’s on the button, and this is placed in the JTextField to prove that the code was actually called when the button was pressed. 
  In the constructor, addActionListener( ) is used to register the ButtonListener object with both the buttons. 
  It is often more convenient to code the ActionListener as an anonymous inner class, especially since you tend to use only a single instance of each listener class. Button2.java can be modified to use an anonymous inner class as follows: 
  The approach of using an anonymous inner class will be preferred (when possible) for the examples in this book. 
  Exercise 5: (4) Create an application using the SwingConsole class. Include one text field and three buttons. When you press each button, make different text appear in the text field. 
