  Java 1.1 made significant modifications to the fundamental I/O stream library. When you see the Reader and Writer classes, your first thought (like mine) might be that these were meant to replace the InputStream and OutputStream classes. But that’s not the case. Although some aspects of the original streams library are deprecated (if you use them you will receive a warning from the compiler), the InputStream and OutputStream classes still provide valuable functionality in the form of byte-oriented I/O, whereas the Reader and Writer classes provide Unicode-compliant, character-based I/O. In addition: 
  1. Java 1.1 added new classes into the InputStream and OutputStream hierarchy, so it’s obvious those hierarchies weren’t being replaced. 
  2. There are times when you must use classes from the "byte" hierarchy in combination with classes in the "character" hierarchy. To accomplish this, there are "adapter" classes: InputStreamReader converts an InputStream to a Reader, and OutputStreamWriter converts an OutputStream to a Writer. 
  The most important reason for the Reader and Writer hierarchies is for internationalization. The old I/O stream hierarchy supports only 8-bit byte streams and doesn’t handle the 16-bit Unicode characters well. Since Unicode is used for internationalization (and Java’s native char is 16-bit Unicode), the Reader and Writer hierarchies were added to support Unicode in all I/O operations. In addition, the new libraries are designed for faster operations than the old. 
Sources and sinks of data
  Almost all of the original Java I/O stream classes have corresponding Reader and Writer classes to provide native Unicode manipulation. However, there are some places where the byte-oriented InputStreams and OutputStreams are the correct solution; in particular, thejava.util.zip libraries are byte-oriented rather than char-oriented. So the most sensible approach to take is to try to use the Reader and Writer classes whenever you can. You’ll discover the situations when you have to use the byte-oriented libraries because your code won’t compile. 
  Here is a table that shows the correspondence between the sources and sinks of information (that is, where the data physically comes from or goes to) in the two hierarchies. 
  Sources & sinks: Corresponding Java 1.1 class Java 1.0 class InputStream Reader adapter: InputStreamReader OutputStream Writer adapter: OutputStreamWriter FilelnputStream FileReader FileOutputStream FileWriter StringBufferlnputStream StringReader (deprecated) (no corresponding class) StringWriter ByteArrayInputStream CharArrayReader ByteArrayOutputStream CharArrayWriter PipedInputStream PipedReader PipedOutputStream PipedWriter  In general, you’ll find that the interfaces for the two different hierarchies are similar, if not identical. 
Modifying stream behavior
  For InputStreams and OutputStreams, streams were adapted for particular needs using "decorator" subclasses of FilterInputStream and FilterOutputStream. The Reader and Writer class hierarchies continue the use of this idea—but not exactly. 
  In the following table, the correspondence is a rougher approximation than in the previous table. The difference is because of the class organization; although BufferedOutputStream is a subclass of FilterOutputStream, BufferedWriter is not a subclass of FilterWriter (which, even though it is abstract, has no subclasses and so appears to have been put in either as a placeholder or simply so you don’t wonder where it is). However, the interfaces to the classes are quite a close match. 
  Filters: Corresponding Java 1.1 class Java 1.0 class FilterInputStream FilterReader FilterOutputStream FilterWriter (abstract class with no subclasses) BufferedInputStream BufferedReader (also has readLine( )) BufferedOutputStream BufferedWriter DataInputStream Use DataInputStream (except when you need to use readLine( ), when you should use a    Filters: Corresponding Java 1.1 class Java 1.0 class BufferedReader) PrintStream PrintWriter LineNumberInputStream LineNumberReader (deprecated) StreamTokenizer StreamTokenizer (Use the constructor that takes a Reader instead) PushbacklnputStream PushbackReader 
  There’s one direction that’s quite clear: Whenever you want to use readLine( ), you shouldn’t do it with a DataInputStream (this is met with a deprecation message at compile time), but instead use a BufferedReader. Other than this, DataInputStream is still a "preferred" member of the I/O library. 
  To make the transition to using a PrintWriter easier, it has constructors that take any OutputStream object as well as Writer objects. PrintWriter’s formatting interface is virtually the same as PrintStream. 
  In Java SE5, PrintWriter constructors were added to simplify the creation of files when writing output, as you shall see shortly. 
  One PrintWriter constructor also has an option to perform automatic flushing, which happens after every println( ) if the constructor flag is set. 
Unchanged classes
  Some classes were left unchanged between Java 1.0 and Java 1.1: 
  Java 1.0 classes without corresponding Java 1.1 classes DataOutputStream File RandomAccessFile SequenceInputStream  DataOutputStream, in particular, is used without change, so for storing and retrieving data in a transportable format, you use the InputStream and OutputStream hierarchies. 
