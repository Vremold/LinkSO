  and useful interfaces  Decorators were introduced in the Generics chapter, on page 717. The Java I/O library requires many different combinations of features, and this is the justification for using the 1 Decorator design pattern. The reason for the existence of the "filter" classes in the Java I/O library is that the abstract "filter" class is the base class for all the decorators. A decorator must have the same interface as the object it decorates, but the decorator can also extend the interface, which occurs in several of the "filter" classes. 
  There is a drawback to Decorator, however. Decorators give you much more flexibility while you’re writing a program (since you can easily mix and match attributes), but they add complexity to your code. The reason that the Java I/O library is awkward to use is that you must create many classes—the "core" I/O type plus all the decorators—in order to get the single I/O object that you want. 
  The classes that provide the decorator interface to control a particular InputStream or OutputStream are the FilterlnputStream and FilterOutputStream, which don’t have very intuitive names. FilterlnputStream and FilterOutputStream are derived from the base classes of the I/O library, InputStream and OutputStream, which is a key requirement of the decorator (so that it provides the common interface to all the objects that are being decorated). 
  languages. But it’s the justification for the decision. 
  Reading from an InputStream with FilterlnputStream  The FilterlnputStream classes accomplish two significantly different things. DatalnputStream allows you to read different types of primitive data as well as String objects. (All the methods start with "read," such as readByte( ), readFloat( ), etc.) This, along with its companion DataOutputStream, allows you to move primitive data from one place to another via a stream. These "places" are determined by the classes in Table I/O-1. 
  The remaining FilterlnputStream classes modify the way an InputStream behaves internally: whether it’s buffered or unbuffered, whether it keeps track of the lines it’s reading (allowing you to ask for line numbers or set the line number), and whether you can push back a single character. The last two classes look a lot like support for building a compiler (they were probably added to support the experiment of "building a Java compiler in Java"), so you probably won’t use them in general programming. 
  You’ll need to buffer your input almost every time, regardless of the I/O device you’re connecting to, so it would have made more sense for the I/O library to have a special case (or simply a method call) for unbuffered input rather than buffered input. 
  Table I/O-3. Types of FilterlnputStream  Class Function Constructor arguments How to use it 
  Data- Used in concert with InputStream InputStream DataOutputStream, so you can read primitives  (int, char, long, etc.) from a stream in a Contains a full interface portable fashion. to allow you to read primitive types. Buffered- Use this to prevent a InputStream, with InputStream physical read every time optional buffer size. you want more data. You’re saying, "Use a This doesn’t provide an buffer." interface per se. It just adds buffering to the process. Attach an interface object. LineNumber- Keeps track of line InputStream InputStream numbers in the input stream; you can call 
  getLineNumber( ) and setLineNumber (int). This just adds line numbering, so you’ll probably attach an interface object. Pushback- Has a one-byte pushback InputStream InputStream buffer so that you can push back the last  character read. Generally used in the 
  Class Function Constructor arguments How to use it  scanner for a compiler. You probably won’t use this. Writing to an OutputStream with FilterOutputStream 
  The complement to DatalnputStream is DataOutputStream, which formats each of the primitive types and String objects onto a stream in such a way that any DatalnputStream, on any machine, can read them. All the methods start with "write," such as writeByte( ), writeFloat( ), etc. 
  The original intent of PrintStream was to print all of the primitive data types and String objects in a viewable format. This is different from DataOutputStream, whose goal is to put data elements on a stream in a way that DatalnputStream can portably reconstruct them. 
  The two important methods in PrintStream are print( ) and println( ), which are overloaded to print all the various types. The difference between print( ) and println( ) is that the latter adds a newline when it’s done. 
  PrintStream can be problematic because it traps all IOExceptions (you must explicitly test the error status with checkError( ), which returns true if an error has occurred). Also, PrintStream doesn’t internationalize properly and doesn’t handle line breaks in a platform- independent way. These problems are solved with PrintWriter, described later. 
  BufferedOutputStream is a modifier and tells the stream to use buffering so you don’t get a physical write every time you write to the stream. You’ll probably always want to use this when doing output. 
  Table I/O-4. Types of FilterOutputStream  Class Function Constructor arguments How to use it 
  Data- Used in concert with OutputStream OutputStream DataInputStream so you can write primitives  (int, char, long, etc.) to a stream in a portable Contains a full fashion. interface to allow you to write primitive types. PrintStream For producing formatted OutputStream, with output. While optional boolean DataOutputStream indicating that the handles the storage of buffer is flushed with data, PrintStream every newline. handles display. Should be the "final" 
  Class Function Constructor arguments How to use it  wrapping for your OutputStream object. You’ll probably use this a lot. Buffered- Use this to prevent a OutputStream, with OutputStream physical write every time optional buffer size. you send a piece of data. You’re saying, "Use a buffer." You can call This doesn’t provide an flush( ) to flush the interface per se. It just buffer. adds buffering to the process. Attach an interface object. 
