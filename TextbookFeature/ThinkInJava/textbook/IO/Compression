  The Java I/O library contains classes to support reading and writing streams in a compressed format. You wrap these around other I/O classes to provide compression functionality. 
  These classes are not derived from the Reader and Writer classes, but instead are part of the InputStream and OutputStream hierarchies. This is because the compression library works with bytes, not characters. However, you might sometimes be forced to mix the two types of streams. (Remember that you can use InputStreamReader and OutputStream Writer to provide easy conversion between one type and another.)  Compression class Function CheckedInputStream GetCheckSum( ) produces checksum for any InputStream (not just decompression). CheckedOutputStream GetCheckSum( ) produces checksum for any OutputStream (not just compression). DeflaterOutputStream Base class for compression classes. ZipOutputStream A DeflaterOutputStream that compresses data into the Zip file format. GZIPOutputStream A DeflaterOutputStream that compresses data into the GZIP file format. InflaterInputStream Base class for decompression classes. ZipInputStream An InflaterInputStream that decompresses data that has been stored in the Zip file format. GZIPInputStream An InflaterInputStream that decompresses data that has been stored in the GZIP file format. 
  Although there are many compression algorithms, Zip and GZIP are possibly the most commonly used. Thus you can easily manipulate your compressed data with the many tools available for reading and writing these formats. 
Simple compression with GZIP
  The GZIP interface is simple and thus is probably more appropriate when you have a single stream of data that you want to compress (rather than a container of dissimilar pieces of data). Here’s an example that compresses a single file: 
  The use of the compression classes is straightforward; you simply wrap your output stream in a GZIPOutputStream or ZipOutputStream, and your input stream in a GZIPInputStream or ZipInputStream. All else is ordinary I/O reading and writing. This is an example of mixing the char-oriented streams with the byte-oriented streams; in uses the Reader classes, whereas GZIPOutputStream’s constructor can accept only an OutputStream object, not a Writer object. When the file is opened, the GZIPInputStream is converted to a Reader. 
Multifile storage with Zip
  The library that supports the Zip format is more extensive. With it you can easily store multiple files, and there’s even a separate class to make the process of reading a Zip file easy. The library uses the standard Zip format so that it works seamlessly with all the Zip tools currently downloadable on the Internet. The following example has the same form as the previous example, but it handles as many command-line arguments as you want. In addition, it shows the use of the Checksum classes to calculate and verify the checksum for the file. There are two Checksum types: Adler32 (which is faster) and CRC32 (which is slower but slightly more accurate). 
  For each file to add to the archive, you must call putNextEntry( ) and pass it a ZipEntry object. The ZipEntry object contains an extensive interface that allows you to get and set all the data available on that particular entry in your Zip file: name, compressed and uncompressed sizes, date, CRC checksum, extra field data, comment, compression method, and whether it’s a directory entry. However, even though the Zip format has a way to set a password, this is not supported in Java’s Zip library. And although CheckedInputStream and CheckedOutputStream support both Adler32 and CRC32 checksums, the ZipEntry class supports only an interface for CRC. This is a restriction of the underlying Zip format, but it might limit you from using the faster Adler32. 
  To extract files, ZipInputStream has a getNextEntry( ) method that returns the next ZipEntry if there is one. As a more succinct alternative, you can read the file using a    ZipFile object, which has a method entries( ) to return an Enumeration to the ZipEntries. 
  In order to read the checksum, you must somehow have access to the associated Checksum object. Here, a reference to the CheckedOutputStream and CheckedInputStream objects is retained, but you could also just hold on to a reference to the Checksum object. 
  A baffling method in Zip streams is setComment( ). As shown in ZipCompress.java, you can set a comment when you’re writing a file, but there’s no way to recover the comment in the ZipInputStream. Comments appear to be supported fully on an entry-by-entry basis only via ZipEntry. Of course, you are not limited to files when using the GZIP or Zip libraries— you can compress anything, including data to be sent through a network connection. 
Java ARchives (JARs)
  The Zip format is also used in the JAR (Java ARchive) file format, which is a way to collect a group of files into a single compressed file, just like Zip. However, like everything else in Java, JAR files are cross-platform, so you don’t need to worry about platform issues. You can also include audio and image files as well as class files. 
  JAR files are particularly helpful when you deal with the Internet. Before JAR files, your Web browser would have to make repeated requests of a Web server in order to download all the files that made up an applet. In addition, each of these files was uncompressed. By combining all of the files for a particular applet into a single JAR file, only one server request is necessary and the transfer is faster because of compression. And each entry in a JAR file can be digitally signed for security. 
  A JAR file consists of a single file containing a collection of zipped files along with a "manifest" that describes them. (You can create your own manifest file; otherwise, the jar program will do it for you.) You can find out more about JAR manifests in the JDK documentation. 
  The jar utility that comes with Sun’s JDK automatically compresses the files of your choice. You invoke it on the command line: 
  jar [options] destination [manifest] inputfile(s)  The options are simply a collection of letters (no hyphen or any other indicator is necessary). Unix/Linux users will note the similarity to the tar options. These are: 
  c Creates a new or empty archive. t Lists the table of contents. x Extracts all files. x file Extracts the named file. f Says, "I’m going to give you the name of the file." If you don’t use this, jar assumes that its input will come from standard input, or, if it is creating a file, its output will go to standard output. m Says that the first argument will be the name of the user- created manifest file. v Generates verbose output describing what jar is doing. 
  o Only stores the files; doesn’t compress the files (use to create a JAR file that you can put in your classpath). M Doesn’t automatically create a manifest file. 
  If a subdirectory is included in the files to be put into the JAR file, that subdirectory is automatically added, including all of its subdirectories, etc. Path information is also preserved. 
  Here are some typical ways to invoke jar. The following command creates a JAR file called myJarFile.jar that contains all of the class files in the current directory, along with an automatically generated manifest file: 
  jar cf myJarFile.jar *.class  The next command is like the previous example, but it adds a user-created manifest file called myManifestFile.mf: 
  jar cmf myJarFile.jar myManifestFile.mf *.class  This produces a table of contents of the files in myJarFile.jar: 
  jar tf myJarFile.jar  This adds the "verbose" flag to give more detailed information about the files in myJarFile.jar: 
  jar tvf myJarFile.jar  Assuming audio, classes, and image are subdirectories, this combines all of the subdirectories into the file myApp.jar. The "verbose" flag is also included to give extra feedback while the jar program is working: 
  jar cvf myApp.jar audio classes image  If you create a JAR file using the o (zero) option, that file can be placed in your CLASSPATH: 
  CLASSPATH="libl.jar;lib2.jar;" 
  Then Java can search lib1.jar and lib2.jar for class files. 
  The jar tool isn’t as general-purpose as a Zip utility. For example, you can’t add or update files to an existing JAR file; you can create JAR files only from scratch. Also, you can’t move files into a JAR file, erasing them as they are moved. However, a JAR file created on one platform will be transparently readable by the jar tool on any other platform (a problem that sometimes plagues Zip utilities). 
  As you will see in the Graphical User Interfaces chapter, JAR files are also used to package JavaBeans. 
