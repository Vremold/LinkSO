  Although you can combine the I/O stream classes in many different ways, you’ll probably just use a few combinations. The following examples can be used as a basic reference for typical I/O usage. 
  In these examples, exception handing will be simplified by passing exceptions out to the console, but this is appropriate only in small examples and utilities. In your code you’ll want to consider more sophisticated error-handling approaches. 
Buffered input file
  To open a file for character input, you use a FileInputReader with a String or a File object as the file name. For speed, you’ll want that file to be buffered so you give the resulting reference to the constructor for a BufferedReader. Since BufferedReader also provides the readLine( ) method, this is your final object and the interface you read from. When readLine( ) returns null, you’re at the end of the file. 
  The StringBuilder sb is used to accumulate the entire contents of the file (including newlines that must be added since readLine( ) strips them off). Finally, close( ) is called to 2 close the file. 
  Exercise 7: (2) Open a text file so that you can read the file one line at a time. Read each line as a String and place that String object into a LinkedList. Print all of the lines in the LinkedList in reverse order. 
  Exercise 8: (1) Modify Exercise 7 so that the name of the file you read is provided as a command-line argument. 
  Exercise 9: (1) Modify Exercise 8 to force all the lines in the LinkedList to uppercase and send the results to System.out. 
  Exercise 10: (2) Modify Exercise 8 to take additional command-line arguments of words to find in the file. Print all lines in which any of the words match. 
  Exercise 11: (2) In the innerclasses/GreenhouseController.java example, GreenhouseController contains a hard-coded set of events. Change the program so that it reads the events and their relative times from a text file, ((difficulty level 8): Use a Factory Method design pattern to build the events—see Thinking in Patterns (with Java) at www.MindView.net.) 
Input from memory
  Here, the String result from BufferedInputFile.read( ) is used to create a StringReader. Then read( ) is used to read each character one at a time and send it out to the console: 
  Note that read( ) returns the next character as an int and thus it must be cast to a char to print properly. 
Formatted memory input
  To read "formatted" data, you use a DataInputStream, which is a byteoriented I/O class (rather than char-oriented). Thus you must use all InputStream classes rather than Reader classes. Of course, you can read anything (such as a file) as bytes using InputStream classes, but here a String is used: 
  A ByteArrayInputStream must be given an array of bytes. To produce this, String has a getBytes( ) method. The resulting ByteArrayInputStream is an appropriate InputStream to hand to DataInputStream. 
  If you read the characters from a DataInputStream one byte at a time using readByte( ), any byte value is a legitimate result, so the return value cannot be used to detect the end of input. Instead, you can use the available( ) method to find out how many more characters are available. Here’s an example that shows how to read a file one byte at a time: 
  Note that available( ) works differently depending on what sort of medium you’re reading from; it’s literally "the number of bytes that can be read without blocking." With a file, this means the whole file, but with a different kind of stream this might not be true, so use it thoughtfully. 
  You could also detect the end of input in cases like these by catching an exception. However, the use of exceptions for control flow is considered a misuse of that feature. 
Basic file output
  A FileWriter object writes data to a file. You’ll virtually always want to buffer the output by wrapping it in a BufferedWriter (try removing this wrapping to see the impact on the performance—buffering tends to dramatically increase performance of I/O operations). In this example, it’s decorated as a PrintWriter to provide formatting. The data file created this way is readable as an ordinary text file: 
  As the lines are written to the file, line numbers are added. Note that LineNumberReader is not used, because it’s a silly class and you don’t need it. You can see from this example that it’s trivial to keep track of your own line numbers. 
  When the input stream is exhausted, readLine( ) returns null. You’ll see an explicit close( ) for out, because if you don’t call close( ) for all your output files, you might discover that the buffers don’t get flushed, so the file will be incomplete. 
  Text file output shortcut  Java SE5 added a helper constructor to PrintWriter so that you don’t have to do all the decoration by hand every time you want to create a text file and write to it. Here’s BasicFileOutput.java rewritten to use this shortcut: 
  You still get buffering, you just don’t have to do it yourself. Unfortunately, other commonly written tasks were not given shortcuts, so typical I/O will still involve a lot of redundant text. However, the TextFile utility that is used in this book, and which will be defined a little later in this chapter, does simplify these common tasks. 
  Exercise 12: (3) Modify Exercise 8 to also open a text file so you can write text into it. Write the lines in the LinkedList, along with line numbers (do not attempt to use the "LineNumber" classes), out to the file. 
  Exercise 13: (3) Modify BasicFileOutput.java so that it uses LineNumberReader to keep track of the line count. Note that it’s much easier to just keep track programmatically. 
  Exercise 14: (2) Starting with BasicFileOutput.java, write a program that compares the performance of writing to a file when using buffered and unbuffered I/O. 
Storing and recovering data
  A PrintWriter formats data so that it’s readable by a human. However, to output data for recovery by another stream, you use a DataOutputStream to write the data and a DataInputStream to recover the data. Of course, these streams can be anything, but the following example uses a file, buffered for both reading and writing. DataOutputStream and DataInputStream are byte-oriented and thus require InputStreams and OutputStreams: 
  If you use a DataOutputStream to write the data, then Java guarantees that you can accurately recover the data using a DataInputStream— regardless of what different platforms write and read the data. This is incredibly valuable, as anyone knows who has spent time worrying about platform-specific data issues. That problem vanishes if you have Java on both platforms.3  When you are using a DataOutputStream, the only reliable way to write a String so that it can be recovered by a DataInputStream is to use UTF-8 encoding, accomplished in this example using writeUTF( ) and readUTF( ). UTF-8 is a multi-byte format, and the length of encoding varies according to the actual character set in use. If you’re working with ASCII or mostly ASCII characters (which occupy only seven bits), Unicode is a tremendous waste of space and/or bandwidth, so UTF-8 encodes ASCII characters in a single byte, and non-ASCII characters in two or three bytes. In addition, the length of the string is stored in the first two bytes of the UTF-8 string. However, writeUTF( ) and readUTF( ) use a special variation of UTF-8 for Java (which is completely described in the JDK documentation for those methods), so if you read a string written with writeUTF( ) using a non-Java program, you must write special code in order to read the string properly. 
  With writeUTF( ) and readUTF( ), you can intermingle Strings and other types of data using a DataOutputStream, with the knowledge that the Strings will be properly stored as Unicode and will be easily recoverable with a DataInputStream. 
  The writeDouble( ) method stores the double number to the stream, and the complementary readDouble( ) method recovers it (there are similar methods for reading and writing the other types). But for any of the reading methods to work correctly, you must know the exact placement of the data item in the stream, since it would be equally possible to read the stored double as a simple sequence of bytes, or as a char, etc. So you must either have a fixed format for the data in the file, or extra information must be stored in the file that you parse to determine where the data is located. Note that object serialization or XML (both described later in this chapter) may be easier ways to store and retrieve complex data structures. 
  Exercise 15: (4) Look up DataOutputStream and DataInputStream in the JDK documentation. Starting with StoringAndRecoveringData.java, create a program that stores and then retrieves all the different possible types provided by the DataOutputStream and DataInputStream classes. Verify that the values are stored and retrieved accurately. Reading and writing   having Java on all platforms. XML is introduced later in this chapter. 
  random-access files  Using a RandomAccessFile is like using a combined DataInputStream and DataOutputStream (because it implements the same interfaces: DataInput and DataOutput). In addition, you can use seek( ) to move about in the file and change the values. 
  When using RandomAccessFile, you must know the layout of the file so that you can manipulate it properly. RandomAccessFile has specific methods to read and write primitives and UTF-8 strings. Here’s an example: 
  The display( ) method opens a file and displays seven elements within as double values. In main( ), the file is created, then opened and modified. Since a double is always eight bytes long, to seek( ) to double number 5 you just multiply 5*8 to produce the seek value. 
  As previously noted, RandomAccessFile is effectively separate from the rest of the I/O hierarchy, save for the fact that it implements the DataInput and DataOutput interfaces. It doesn’t support decoration, so you cannot combine it with any of the aspects of the InputStream and OutputStream subclasses. You must assume that a RandomAccessFile is properly buffered since you cannot add that. 
  The one option you have is in the second constructor argument: You can open a RandomAccessFile to read ("r") or read and write ("rw"). 
  You may want to consider using nio memory-mapped files instead of RandomAccessFile. 
  Exercise 16: (2) Look up RandomAccessFile in the JDK documentation. Starting with UsingRandomAccessFile.java, create a program that stores and then retrieves all the different possible types provided by the RandomAccessFile class. Verify that the values are stored and retrieved accurately. 
Piped streams
  The PipedInputStream, PipedOutputStream, PipedReader and PipedWriter have been mentioned only briefly in this chapter. This is not to suggest that they aren’t useful, but their value is not apparent until you begin to understand concurrency, since the piped streams are used to communicate between tasks. This is covered along with an example in the Concurrency chapter. 
