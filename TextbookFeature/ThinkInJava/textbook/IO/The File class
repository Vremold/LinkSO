  Before getting into the classes that actually read and write data to streams, we’ll look at a library utility that assists you with file directory issues. The File class has a deceiving name; you might think it refers to a file, but it doesn’t. In fact, "FilePath" would have been a better name for the class. It can represent either the name of a particular file or the names of a set of files in a directory. If it’s a set of files, you can ask for that set using the list( ) method, which returns an array of String. It makes sense to return an array rather than one of the flexible container classes, because the number of elements is fixed, and if you want a different directory listing, you just create a different File object. This section shows an example of the use of this class, including the associated FilenameFilter interface. 
A directory lister
  Suppose you’d like to see a directory listing. The File object can be used in two ways. If you call list( ) with no arguments, you’ll get the full list that the File object contains. However, if you want a restricted list—for example, if you want all of the files with an extension of .Java— then you use a "directory filter," which is a class that tells how to select the File objects for display. Here’s the example. Note that the result has been effortlessly sorted (alphabetically) using the java.util.Arrays.sort( ) method and the String.CASE_INSENSITIVE_ORDER Comparator: 
  The DirFilter class implements the interface FilenameFilter. Notice how simple the FilenameFilter interface is: 
  public interface FilenameFilter { boolean accept(File dir, String name); } 
  DirFilter’s sole reason for existence is to provide the accept( ) method to the list( ) method so that list( ) can "call back" accept( ) to determine which file names should be included in the list. Thus, this structure is often referred to as a callback. More specifically, this is an example of the Strategy design pattern, because list( ) implements basic functionality, and you provide the Strategy in the form of a FilenameFilter in order to complete the algorithm necessary for list( ) to provide its service. Because list( ) takes a FilenameFilter object as its argument, it means that you can pass an object of any class that implements FilenameFilter to choose (even at run time) how the list( ) method will behave. The purpose of a Strategy is to provide flexibility in the behavior of code. 
  The accept( ) method must accept a File object representing the directory that a particular file is found in, and a String containing the name of that file. Remember that the list( ) method is calling accept( ) for each of the file names in the directory object to see which one should be included; this is indicated by the boolean result returned by accept( ). 
  accept( ) uses a regular expression matcher object to see if the regular expression regex matches the name of the file. Using accept( ), the list( ) method returns an array. 
  Anonymous inner classes  This example is ideal for rewriting using an anonymous inner class (described in Inner Classes). As a first cut, a method filter( ) is created that returns a reference to a FilenameFilter: 
  Note that the argument to filter( ) must be final. This is required by the anonymous inner class so that it can use an object from outside its scope. This design is an improvement because the FilenameFilter class is now tightly bound to DirList2. However, you can take this approach one step further and define the anonymous inner class as an argument to list(), in which case it’s even smaller: 
  The argument to main( ) is now final, since the anonymous inner class uses args[0] directly. 
  This shows you how anonymous inner classes allow the creation of specific, one-off classes to solve problems. One benefit of this approach is that it keeps the code that solves a particular problem isolated in one spot. On the other hand, it is not always as easy to read, so you must use it judiciously. 
  Exercise 1: (3) Modify DirList.java (or one of its variants) so that the FilenameFilter opens and reads each file (using the net.mindview.util.TextFile utility) and accepts the file based on whether any of the trailing arguments on the command line exist in that file. 
  Exercise 2: (2) Create a class called SortedDirList with a constructor that takes a File object and builds a sorted directory list from the files at that File. Add to this class two overloaded list( ) methods: the first produces the whole list, and the second produces the subset of the list that matches its argument (which is a regular expression). 
  Exercise 3: (3) Modify DirList.java (or one of its variants) so that it sums up the file sizes of the selected files. 
Directory utilities
  A common task in programming is to perform operations on sets of files, either in the local directory or by walking the entire directory tree. It is useful to have a tool that will produce the set of files for you. The following utility class produces either an array of File objects in the local directory using the local( ) method, or a List<File> of the entire directory tree starting at the given directory using walk( ) (File objects are more useful than file names because File objects contain more information). The files are chosen based on the regular expression that you provide: 
  The local( ) method uses a variant of File.list( ) called listFiles( ) that produces an array of File. You can see that it also uses a FilenameFilter. If you need a List instead of an array, you can convert the result yourself using Arrays.asList( ). 
  The walk( ) method converts the name of the starting directory into a File object and calls recurseDirs( ), which performs a recursive directory walk, collecting more information with each recursion. To distinguish ordinary files from directories, the return value is effectively a "tuple" of objects—a List holding ordinary files, and another holding directories. The fields are intentionally made public here, because the point of Treelnfo is simply to collect the objects together—if you were just returning a List, you wouldn’t make it private, so just because you are returning a pair of objects, it doesn’t mean you need to make them private. Note that Treelnfo implements Iterable<File>, which produces the files, so that you have a "default iteration" over the file list, whereas you can specify directories by saying ".dirs". 
  The Treelnfo.toString( ) method uses a "pretty printer" class so that the output is easer to view. The default toString( ) methods for containers print all the elements for a container on a single line. For large collections this can become difficult to read, so you may want to use an alternate formatting. Here’s a tool that adds newlines and indents each element: 
  The pformat( ) method produces a formatted String from a Collection, and the pprint( ) method uses pformat( ) to do its job. Note that the special cases of no elements and a single element are handled differently. There’s also a version of pprint( ) for arrays. 
  The Directory utility is placed in the net.mindview.util package so that it is easily available. Here’s a sample of how you can use it: 
  You may need to refresh your knowledge of regular expressions from the Strings chapter in order to understand the second arguments in local( ) and walk( ). 
  We can take this a step further and create a tool that will walk directories and process the files within them according to a Strategy object (this is another example of the Strategy design pattern): 
  The Strategy interface is nested within ProcessFiles, so that if you want to implement it you must implement ProcessFiles.Strategy, which provides more context for the reader. ProcessFiles does all the work of finding the files that have a particular extension (the ext argument to the constructor), and when it finds a matching file, it simply hands it to the Strategy object (which is also an argument to the constructor). 
  If you don’t give it any arguments, ProcessFiles assumes that you want to traverse all the directories off of the current directory. You can also specify a particular file, with or without the extension (it will add the extension if necessary), or one or more directories. 
  In main( ) you see a basic example of how to use the tool; it prints the names of all the Java source files according to the command line that you provide. 
  Exercise 4: (2) Use Directory.walk( ) to sum the sizes of all files in a directory tree whose names match a particular regular expression. 
  Exercise 5: (1) Modify ProcessFiles.java so that it matches a regular expression rather than a fixed extension. 
Checking for and creating directories
  The File class is more than just a representation for an existing file or directory. You can also use a File object to create a new directory or an entire directory path if it doesn’t exist. You can also look at the characteristics of files (size, last modification date, read/write), see whether a File object represents a file or a directory, and delete a file. The following example shows some of the other methods available with the File class (see the JDK documentation from http://java.sun.com for the full set): 
  In fileData( ) you can see various file investigation methods used to display information about the file or directory path. 
  The first method that’s exercised by main( ) is renameTo( ), which allows you to rename (or move) a file to an entirely new path represented by the argument, which is another File object. This also works with directories of any length. 
  If you experiment with the preceding program, you’ll find that you can make a directory path of any complexity, because mkdirs( ) will do all the work for you. 
  Exercise 6: (5) Use ProcessFiles to find all the Java source-code files in a particular directory subtree that have been modified after a particular date. 
