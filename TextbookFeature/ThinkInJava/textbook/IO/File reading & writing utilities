  A very common programming task is to read a file into memory, modify it, and then write it out again. One of the problems with the Java I/O library is that it requires you to write quite a bit of code in order to perform these common operations—there are no basic helper functions to do them for you. What’s worse, the decorators make it rather hard to remember how to open files. Thus, it makes sense to add helper classes to your library that will easily perform these basic tasks for you. Java SE5 has added a convenience constructor to PrintWriter so you can easily open a text file for writing. However, there are many other common tasks that you will want to do over and over, and it makes sense to eliminate the redundant code associated with those tasks. 
  Here’s the TextFile class that has been used in previous examples in this book to simplify reading and writing files. It contains static methods to read and write text files as a single string, and you can create a TextFile object that holds the lines of the file in an ArrayList (so you have all the ArrayList functionality while manipulating the file contents): 
  read( ) appends each line to a StringBuilder, followed by a newline, because that is stripped out during reading. Then it returns a String containing the whole file. write( ) opens and writes the text String to the file. 
  Notice that any code that opens a file guards the file’s close( ) call in a finally clause to guarantee that the file will be properly closed. 
  The constructor uses the read( ) method to turn the file into a String, then uses String.split( ) to divide the result into lines along newline boundaries (if you use this class a lot, you may want to rewrite this constructor to improve efficiency). Alas, there is no corresponding "join" method, so the non-static write( ) method must write the lines out by hand. 
  Because this class is intended to trivialize the process of reading and writing files, all IOExceptions are converted to RuntimeExceptions, so the user doesn’t have to use try- catch blocks. However, you may need to create another version that passes IOExceptions out to the caller. 
  In main( ), a basic test is performed to ensure that the methods work. 
  Although this utility did not require much code to create, using it can save a lot of time and make your life easier, as you’ll see in some of the examples later in this chapter. 
  Another way to solve the problem of reading text files is to use the java.util.Scanner class introduced in Java SE5. However, this is only for reading files, not writing them, and that tool (which you’ll notice is nor in java.io) is primarily designed for creating programming- language scanners or "little languages." 
  Exercise 17: (4) Using TextFile and a Map<Character,Integer>, create a program that counts the occurrence of all the different characters in a file. (So if there are 12 occurrences of the letter ‘a’ in the file, the Integer associated with the Character containing ‘a’ in the Map contains ‘12’). 
  Exercise 18: (1) Modify TextFile.java so that it passes IOExceptions out to the caller. 
Reading binary files
  This utility is similar to TextFile.java in that it simplifies the process of reading binary files: 
  One overloaded method takes a File argument; the second takes a String argument, which is the file name. Both return the resulting byte array. 
  The available( ) method is used to produce the appropriate array size, and this particular version of the overloaded read( ) method fills the array. 
  Exercise 19: (2) Using BinaryFile and a Map<Byte,Integer>, create a program that counts the occurrence of all the different bytes in a file. 
  Exercise 20: (4) Using Directory.walk( ) and BinaryFile, verify that all .class files in a directory tree begin with the hex characters ‘CAFEBABE’. 
