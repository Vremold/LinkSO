  Programming language I/O libraries often use the abstraction of a stream, which represents any data source or sink as an object capable of producing or receiving pieces of data. The stream hides the details of what happens to the data inside the actual I/O device. 
  The Java library classes for I/O are divided by input and output, as you can see by looking at the class hierarchy in the JDK documentation. Through inheritance, everything derived from the InputStream or Reader classes has basic methods called read( ) for reading a single byte or an array of bytes. Likewise, everything derived from OutputStream or Writer classes has basic methods called write( ) for writing a single byte or an array of bytes. However, you won’t generally use these methods; they exist so that other classes can use them—these other classes provide a more useful interface. Thus, you’ll rarely create your stream object by using a single class, but instead will layer multiple objects together to provide your desired functionality (this is the Decorator design pattern, as you shall see in this section). The fact that you create more than one object to produce a single stream is the primary reason that Java’s I/O library is confusing. 
  It’s helpful to categorize the classes by their functionality. In Java l.o, the library designers started by deciding that all classes that had anything to do with input would be inherited from InputStream, and all classes that were associated with output would be inherited from OutputStream. 
  As is the practice in this book, I will attempt to provide an overview of the classes, but assume that you will use the JDK documentation to determine all the details, such as the exhaustive list of methods of a particular class. 
Types of InputStream
  InputStream’s job is to represent classes that produce input from different sources. These sources can be: 
  1. An array of bytes. 
  2. A String obj ect. 
  3. A file. 
  4. A "pipe," which works like a physical pipe: You put things in at one end and they come out the other. 
  5. A sequence of other streams, so you can collect them together into a single stream. 
  6. Other sources, such as an Internet connection. (This is covered in Thinking in Enterprise Java, available at www.MindView.net.)  Each of these has an associated subclass of InputStream. In addition, the FilterInputStream is also a type of InputStream, to provide a base class for "decorator" classes that attach attributes or useful interfaces to input streams. This is discussed later. 
  Table I/O-1. Types of InputStream  Class Function Constructor arguments How to use it 
  ByteArray- Allows a buffer in The buffer from which to InputStream memory to be used extract the bytes. as an InputStream. As a source of data: Connect it to a FilterlnputStream object to provide a useful interface. StringBuffer- Converts a String A String. The underlying InputStream into an implementation actually InputStream. uses a StringBuffer. As a source of data: Connect it to a FilterlnputStream object to provide a useful interface. File- For reading A String representing the InputStream information from a file name, or a File or file. FileDescriptor object. As a source of data: Connect it to a FilterlnputStream object to provide a useful interface. 
  Class Function Constructor arguments How to use it  Piped- Produces the data PipedOutputStream InputStream that’s being written to the associated As a source of data in PipedOutput- multithreading: Connect it Stream. to a FilterlnputStream Implements the object to provide a useful "piping" concept. interface. Sequence- Converts two or Two InputStream objects InputStream more or an Enumeration for a InputStream container of InputStream objects into a single objects. InputStream. As a source of data: Connect it to a FilterlnputStream object to provide a useful interface. Filter- Abstract class that is See Table I/O-3. InputStream an interface for decorators that See Table I/O-3. provide useful functionality to the other InputStream classes. See Table I/O-3. 
Types of OutputStream
  This category includes the classes that decide where your output will go: an array of bytes (but not a String—presumably, you can create one using the array of bytes), a file, or a "pipe." 
  In addition, the FilterOutputStream provides a base class for "decorator" classes that attach attributes or useful interfaces to output streams. This is discussed later. 
  Table I/O-2. Types of OutputStream  Class Function Constructor arguments How to use it 
  ByteArray- Creates a buffer in Optional initial size of the OutputStream memory. All the data buffer. that you send to the stream is placed in this buffer. To designate the destination of your data: Connect it to a FilterOutputStream object to provide a useful interface. File- For sending A String representing the OutputStream information to a file. file name, or a File or FileDescriptor object. 
  Class Function Constructor arguments How to use it  To designate the destination of your data: Connect it to a FilterOutputStream object to provide a useful interface. Piped- Any information you PipedlnputStream OutputStream write to this automatically ends 
  up as input for the associated To designate the destination Pipedlnput- of your data for Stream. Implements multithreading: Connect it to the "piping" concept. a FilterOutputStream object to provide a useful interface. Filter- Abstract class that is See Table I/O-4. OutputStream an interface for decorators that See Table I/O-4. provide useful functionality to the other OutputStream classes. See Table 1/O-4-  
