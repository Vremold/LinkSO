  If you don’t need a connection between the inner-class object and the outerclass object, then 2 you can make the inner class static. This is commonly called a nested class. To understand the meaning of static when applied to inner classes, you must remember that the object of an ordinary inner class implicitly keeps a reference to the object of the enclosing class that created it. This is not true, however, when you say an inner class is static. A nested class means: 
  1. You don’t need an outer-class object in order to create an object of a nested class. 
  2. You can’t access a non-static outer-class object from an object of a nested class. 
  Nested classes are different from ordinary inner classes in another way, as well. Fields and methods in ordinary inner classes can only be at the outer level of a class, so ordinary inner classes cannot have static data, static fields, or nested classes. However, nested classes can have all of these: 
  In main( ), no object of Parcel11 is necessary; instead, you use the normal syntax for selecting a static member to call the methods that return references to Contents and Destination. 
  As you’ve seen earlier in this chapter, in an ordinary (non-static) inner class, the link to the outer-class object is achieved with a special this reference. A nested class does not have a special this reference, which makes it analogous to a static method. 
  Exercise 18: (1) Create a class containing a nested class. In main( ), create an instance of the nested class. 
  Exercise 19: (2) Create a class containing an inner class that itself contains an inner class. Repeat this using nested classes. Note the names of the .class files produced by the compiler. 
Classes inside interfaces
  Normally, you can’t put any code inside an interface, but a nested class can be part of an interface. Any class you put inside an interface is automatically public and static. Since the class is static, it doesn’t violate the rules for interfaces—the nested class is only placed inside the namespace of the interface. You can even implement the surrounding interface in the inner class, like this: 
  It’s convenient to nest a class inside an interface when you want to create some common code to be used with all different implementations of that interface. 
  Earlier in this book I suggested putting a main( ) in every class to act as a test bed for that class. One drawback to this is the amount of extra compiled code you must carry around. If this is a problem, you can use a nested class to hold your test code: 
  This generates a separate class called TestBed$Tester (to run the program, you say Java TestBed$Tester, but you must escape the ‘$’ under Unix/Linux systems). You can use this class for testing, but you don’t need to include it in your shipping product; you can simply delete TestBed$Tester.class before packaging things up. 
  Exercise 20: (1) Create an interface containing a nested class. Implement this interface and create an instance of the nested class. 
  Exercise 21: (2) Create an interface that contains a nested class that has a static method that calls the methods of your interface and displays the results. Implement your interface and pass an instance of your implementation to the method. 
  Reaching outward from a multiply nested class  It doesn’t matter how deeply an inner class may be nested—it can transparently access all of the members of all the classes it is nested within, as seen here: 3 
  You can see that in MNAAB, the methods g( ) and f( ) are callable without any qualification (despite the fact that they are private). This example also demonstrates the syntax necessary to create objects of multiply nested inner classes when you create the objects in a different class. The ".new" syntax produces the correct scope, so you do not have to qualify the class name in the constructor call. 
