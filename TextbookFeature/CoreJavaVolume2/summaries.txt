Internationalization	A Complete Example	  413   java.util.ResourceBundle 1.1 (Continued)   • Enumeration<String> getKeys() returns an enumeration object to enumerate the keys of this resource bundle. It enumerates the keys in the parent bundles as well. 
Internationalization	Locales	  When you look at an application that is adapted to an international market, the most obvious difference you notice is the language. This observation is actually a bit too limiting for true internationalization, since countries can share a common language, but you might still need to do some work to make computer users of both countries happy. As Oscar Wilde famously said: “We have really everything in common with America nowadays, except, of course, language.” In all cases, menus, button labels, and program messages will need to be translated to the local language. They might also need to be rendered in a different script. 
Internationalization	Text Input and Output2	  As you know, the Java programming language itself is fully Unicode-based. 
Internationalization	Date and Time	  385   java.util.Currency 1.4   • static Currency getInstance(String currencyCode) • static Currency getInstance(Locale locale) returns the Currency instance for the given ISO 4217 currency code or the country of the given locale. 
Internationalization	Collation and Normalization	  393   java.time.LocalDate 8 java.time.LocalTime 8 java.time.LocalDateTime 8 java.time.ZonedDateTime 8   • static Xxx parse(CharSequence text, DateTimeFormatter formatter) parses the given string and returns the LocalDate, LocalTime, LocalDateTime, or ZonedDateTime described in it. Throws a DateTimeParseException if parsing was not successful. 
Internationalization	Currencies	  To format a currency value, you can use the NumberFormat.getCurrencyInstance method. 
Internationalization	Number Formats	  We already mentioned how number and currency formatting is highly localedependent. The Java library supplies a collection of formatter objects that can format and parse numeric values in the java.text package. Go through the following steps to format a number for a particular locale: 1. 
Internationalization	Message Formatting	  The Java library has a MessageFormat class that formats text with variable parts. It is similar to formatting with the printf method, but it supports locales and formats for numbers and dates. We will examine that mechanism in the following sections. 
Internationalization	Resource Bundles	  When localizing an application, you’ll probably have a dauntingly large number of message strings, button labels, and so on, that all need to be translated. To make this task feasible, you’ll want to define the message strings in an external location, usually called a resource. The person carrying out the translation can then simply edit the resource files without having to touch the source code of the program. 
Input and Output	Input#Output Streams	  In the Java API, an object from which we can read a sequence of bytes is called an input stream. An object to which we can write a sequence of bytes is called an output stream. These sources and destinations of byte sequences can be—and often are—files, but they can also be network connections and even blocks of memory. 
Input and Output	Object Input#Output Streams and Serialization	  Using a fixed-length record format is a good choice if you need to store data of the same type. However, objects that you create in an object-oriented program are rarely all of the same type. For example, you might have an array called staff that is nominally an array of Employee records but contains objects that are actually instances of a subclass such as Manager. 
Input and Output	Regular Expressions	  Regular expressions are used to specify string patterns. You can use regular expressions whenever you need to locate strings that match a particular pattern. 
Input and Output	Text Input and Output1	  When saving data, you have the choice between binary and text formats. For example, if the integer 1234 is saved in binary, it is written as the sequence of bytes 00 00 04 D2 (in hexadecimal notation). In text format, it is saved as the string "1234". 
Input and Output	Memory-Mapped Files	  Most operating systems can take advantage of a virtual memory implementation to “map” a file, or a region of a file, into memory. Then the file can be accessed as if it were an in-memory array, which is much faster than the traditional file operations. 
Input and Output	Working with Files	  You have learned how to read and write data from a file. However, there is more to file management than reading and writing. The Path interface and Files class   From the Library of Hristo Dimov Hristov   2.5 Working with Files   101   encapsulate the functionality required to work with the file system on the user’s machine. For example, the Files class can be used to remove or rename the file, or to find out when a file was last modified. In other words, the input/output stream classes are concerned with the contents of files, whereas the classes that we discuss here are concerned with the storage of files on a disk. 
Input and Output	Reading and Writing Binary Data	  69   The StandardCharsets class has static variables of type Charset for the character encodings that every Java virtual machine must support: StandardCharsets.UTF_8 StandardCharsets.UTF_16 StandardCharsets.UTF_16BE StandardCharsets.UTF_16LE StandardCharsets.ISO_8859_1 StandardCharsets.US_ASCII   To obtain the Charset for another encoding, use the static forName method: Charset shiftJIS = Charset.forName("Shift-JIS"); 
The Date and Time API	Local Dates	  public static void runAlgorithm2() { int size = 10; 
The Date and Time API	Local Time	  A LocalTime represents a time of day, such as 15:30:00. You can create an instance with the now or of methods: LocalTime rightNow = LocalTime.now(); 
The Date and Time API	Formatting and Parsing	  // Caution! Won’t work with daylight savings time System.out.println("nextMeeting: " + nextMeeting); 
The Date and Time API	Interoperating with Legacy Code	  369   6.7 Interoperating with Legacy Code As a brand-new creation, the Java Date and Time API will have to interoperate with existing classes—in particular, the ubiquitous java.util.Date, java.util. 
The Date and Time API	The Time Line	  Historically, the fundamental time unit—the second—was derived from Earth’s rotation around its axis. There are 24 hours or 24 × 60 × 60 = 86400 seconds in a full revolution, so it seems just a question of astronomical measurements to precisely define a second. Unfortunately, Earth wobbles slightly, and a more precise definition was needed. In 1967, a new precise definition of a second, matching the historical definition, was derived from an intrinsic property of atoms of caesium-133. Since then, a network of atomic clocks keeps the official time. 
The Date and Time API	Zoned Time	  361   There is a LocalDateTime class representing a date and time. That class is suitable for storing points in time in a fixed time zone—for example, for a schedule of classes or events. However, if you need to make calculations that span the daylight savings time, or if you need to deal with users in different time zones, you should use the ZonedDateTime class that we discuss next. 
The Date and Time API	Date Adjusters	  For scheduling applications, you often need to compute dates such as “the first Tuesday of every month.” The TemporalAdjusters class provides a number of static methods for common adjustments. You pass the result of an adjustment method to the with method. For example, the first Tuesday of a month can be computed like this:   From the Library of Hristo Dimov Hristov   6.3 Date Adjusters   359   LocalDate firstTuesday = LocalDate.of(year, month, 1).with( TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY)); 
Database Programming	Advanced SQL Types	  347   java.sql.Savepoint 1.4   • int getSavepointId() gets the ID of this unnamed save point, or throws a SQLException if this is a named save point. 
Database Programming	Connection Management in Web and Enterprise Applications	  349   Some databases provide native storage for XML data. JDBC 4 introduced a SQLXML interface that can mediate between the internal XML representation and the DOM Source/Result interfaces, as well as binary streams. See the API documentation for the SQLXML class for details. 
Database Programming	JDBC Configuration	  291   Table 5.5 Common SQL Data Types Data Types   Description   INTEGER or INT   Typically, a 32-bit integer   SMALLINT   Typically, a 16-bit integer   NUMERIC(m,n), DECIMAL(m,n) or DEC(m,n)   Fixed-point decimal number with m total digits and n digits after the decimal point   FLOAT(n)   A floating-point number with n binary digits of precision   REAL   Typically, a 32-bit floating-point number   DOUBLE   Typically, a 64-bit floating-point number   CHARACTER(n) or CHAR(n)   Fixed-length string of length n   VARCHAR(n)   Variable-length strings of maximum length n   BOOLEAN   A Boolean value   DATE   Calendar date, implementation-dependent   TIME   Time of day, implementation-dependent   TIMESTAMP   Date and time of day, implementation-dependent   BLOB   A binary large object   CLOB   A character large object   5.3 JDBC Configuration Of course, you need a database program for which a JDBC driver is available. 
Database Programming	The Design of JDBC	  From the start, the developers of the Java technology were aware of the potential that Java showed for working with databases. In 1995, they began working on extending the standard Java library to deal with SQL access to databases. What they first hoped to do was to extend Java so that a program could talk to any random database using only “pure” Java. It didn’t take them long to realize that this is an impossible task: There are simply too many databases out there, using too many protocols. Moreover, although database vendors were all in favor of Java providing a standard network protocol for database access, they were only in favor of it if Java used their network protocol. 
Database Programming	Query Execution	  309   for (int i = 1; i <= columnCount; i++) { if (i > 1) System.out.print(", "); 
Database Programming	Scrollable and Updatable Result Sets	  321   vendor-independent solution for generating keys, it does provide an efficient way of retrieving them. When you insert a new row into a table and a key is automatically generated, you can retrieve it with the following code: stat.executeUpdate(insertStatement, Statement.RETURN_GENERATED_KEYS); 
Database Programming	Transactions	  You can group a set of statements to form a transaction. The transaction can be committed when all has gone well. Or, if an error has occurred in one of them, it can be rolled back as if none of the statements had been issued. 
Database Programming	The Structured Query Language	  285   business logic (in the middle tier) and the raw data (in the database). Therefore, it becomes possible to access the same data and the same business rules from multiple clients, such as a Java desktop application, a web browser, or a mobile app. 
Database Programming	Working with JDBC Statements	  297   try (Connection conn = getConnection(); 
Database Programming	Metadata	  333   javax.sql.rowset.RowSetFactory 7   • • • • •   CachedRowSet createCachedRowSet() FilteredRowSet createFilteredRowSet() JdbcRowSet createJdbcRowSet() JoinRowSet createJoinRowSet() WebRowSet createWebRowSet()   creates a row set of the specified type. 
Database Programming	Row Sets	  Scrollable result sets are powerful, but they have a major drawback. You need to keep the database connection open during the entire user interaction. However, a user can walk away from the computer for a long time, leaving the connection occupied. That is not good—database connections are scarce resources. In this   From the Library of Hristo Dimov Hristov   5.7 Row Sets   329   situation, use a row set. The RowSet interface extends the ResultSet interface, but row sets don’t have to be tied to a database connection. 
The Java SE 8 Stream Library	Stream Creation	  5   java.util.Collection<E> 1.2   • default Stream<E> stream() • default Stream<E> parallelStream() yields a sequential or parallel stream of the elements in this collection. 
The Java SE 8 Stream Library	Simple Reductions	  Now that you have seen how to create and transform streams, we will finally get to the most important point—getting answers from the stream data. The methods that we cover in this section are called reductions. Reductions are terminal operations. 
The Java SE 8 Stream Library	Collecting into Maps	  Suppose you have a Stream<Person> and want to collect the elements into a map so that later you can look up people by their IDs. The Collectors.toMap method has two function arguments that produce the map’s keys and values. For example, Map<Integer, String> idToName = people.collect( Collectors.toMap(Person::getId, Person::getName)); 
The Java SE 8 Stream Library	Primitive Type Streams	  So far, we have collected integers in a Stream<Integer>, even though it is clearly inefficient to wrap each integer into a wrapper object. The same is true for the other primitive types: double, float, long, short, char, byte, and boolean. The stream library has specialized types IntStream, LongStream, and DoubleStream that store primitive values directly, without using wrappers. If you want to store short, char, byte, and boolean, use an IntStream, and for float, use a DoubleStream. 
The Java SE 8 Stream Library	The Optional Type	  13   The findFirst returns the first value in a nonempty collection. It is often useful when combined with filter. For example, here we find the first word that starts with the letter Q, if it exists: Optional<String> startsWithQ = words.filter(s -> s.startsWith("Q")).findFirst(); 
The Java SE 8 Stream Library	From Iterating to Stream Operations	  When you process a collection, you usually iterate over its elements and do some work with each of them. For example, suppose we want to count all long words in a book. First, let’s put them into a list: String contents = new String(Files.readAllBytes( Paths.get("alice.txt")), StandardCharsets.UTF_8); // Read file into string List<String> words = Arrays.asList(contents.split("\\PL+")); 
The Java SE 8 Stream Library	Parallel Streams	  41   java.util.Optional(Int|Long|Double) 8   • static Optional(Int|Long|Double) of((int|long|double) value) yields an optional object with the supplied primitive type value. 
The Java SE 8 Stream Library	The filter, map, and flatMap Methods	  9   1.3 The filter, map, and flatMap Methods A stream transformation produces a stream whose elements are derived from those of another stream. You have already seen the filter transformation that yields a stream with those elements that match a certain condition. Here, we transform a stream of strings into another stream containing only long words: List<String> wordList = . . .; 
The Java SE 8 Stream Library	Grouping and Partitioning	  In the preceding section, you saw how to collect all languages in a given country. 
The Java SE 8 Stream Library	Other Stream Transformations	  11   You can concatenate two streams with the static concat method of the Stream class: Stream<String> combined = Stream.concat( letters("Hello"), letters("World")); 
The Java SE 8 Stream Library	Downstream Collectors	  29   java.util.stream.Collectors 8   • static <T,K> Collector<T,?,Map<K,List<T>>> groupingBy(Function<? super T,? extends K> classifier) • static <T,K> Collector<T,?,ConcurrentMap<K,List<T>>> groupingByConcurrent(Function<? super T,? 
The Java SE 8 Stream Library	Collecting Results	  19   public static Optional<Double> squareRoot(Double x) { return x < 0 ? Optional.empty() : Optional.of(Math.sqrt(x)); 
The Java SE 8 Stream Library	Reduction Operations	  33   Map<String, String> stateToCityNames = cities.collect(groupingBy( City::getState, reducing("", City::getName, (s, t) -> s.length() == 0 ? t : s + ", " + t))); 
The Java SE 8 Stream Library	Extracting Substreams and Concatenating Streams	  The call stream.limit(n) returns a new stream that ends after n elements (or when the original stream ends, if it is shorter). This method is particularly useful for cutting infinite streams down to size. For example, Stream<Double> randoms = Stream.generate(Math::random).limit(100); 
Scripting, Compiling, and Annotation Processing	Annotation Syntax	  In the following sections, we cover everything you need to know about the annotation syntax. 
Scripting, Compiling, and Annotation Processing	Source-Level Annotation Processing	  475   @Inherited @interface Persistent { } 
Scripting, Compiling, and Annotation Processing	Standard Annotations	  Java SE defines a number of annotation interfaces in the java.lang, java.lang.annotation, and javax.annotation packages. Four of them are meta-annotations that describe the behavior of annotation interfaces. The others are regular annotations that you can use to annotate items in your source code. Table 8.2 shows these annotations. 
Scripting, Compiling, and Annotation Processing	The Compiler API	  443   8.2 The Compiler API In the preceding sections, you saw how to interact with code in a scripting language. Now we turn to a different scenario: Java programs that compile Java code. There are quite a few tools that need to invoke the Java compiler, such as: • • • •   Development environments Java teaching and tutoring programs Build and test automation tools Templating tools that process snippets of Java code, such as JavaServer Pages (JSP)   In the past, applications invoked the Java compiler by calling undocumented classes in the jdk/lib/tools.jar library. Nowadays, a public API for compilation is a part of the Java platform, and it is no longer necessary to use tools.jar. This section explains the compiler API. 
Scripting, Compiling, and Annotation Processing	Using Annotations	  455   8.3 Using Annotations Annotations are tags that you insert into your source code so that some tool can process them. The tools can operate on the source level, or they can process class files into which the compiler has placed annotations. 
Scripting, Compiling, and Annotation Processing	Bytecode Engineering	  481   8.7 Bytecode Engineering You have seen how annotations can be processed at runtime or at the source code level. There is a third possibility: processing at the bytecode level. Unless annotations are removed at the source level, they are present in the class files. The class file format is documented (see http://docs.oracle.com/javase/specs/jvms/se8/html). The format is rather complex, and it would be challenging to process class files without special libraries. One such library is the ASM library, available at http://asm.ow2.org. 
Scripting, Compiling, and Annotation Processing	Scripting for the Java Platform	  A scripting language is a language that avoids the usual edit/compile/link/run cycle by interpreting the program text at runtime. Scripting languages have a number of advantages: • Rapid turnaround, encouraging experimentation • Changing the behavior of a running program • Enabling customization by program users On the other hand, most scripting languages lack features that are beneficial for programming complex applications, such as strong typing, encapsulation, and modularity. 
XML	Streaming Parsers	  199   org.w3c.dom.Node 1.4   • String getLocalName() returns the local name (without prefix), or null if the parser is not namespace-aware. 
XML	Introducing XML	  In Chapter 13 of Volume I, you have seen the use of property files to describe the configuration of a program. A property file contains a set of name/value pairs, such as fontname=Times Roman fontsize=12 windowsize=400 200 color=0 50 100   You can use the Properties class to read in such a file with a single method call. 
XML	Parsing an XML Document	  149   have predefined meanings: the less-than, greater-than, ampersand, quotation mark, and apostrophe characters. You can define other entity references in a DTD. 
XML	Locating Information with XPath	  If you want to locate a specific piece of information in an XML document, it can be a bit of a hassle to navigate the nodes of the DOM tree. The XPath language makes it simple to access tree nodes. For example, suppose you have this XML document: <configuration> ... 
XML	Validating XML Documents	  In the previous section, you saw how to traverse the tree structure of a DOM document. However, if you simply follow that approach, you’ll have to do quite a bit of tedious programming and error checking. Not only will you have to deal with whitespace between elements, but you will also need to check whether the document contains the nodes that you expect. For example, suppose you are reading an element: <font> <name>Helvetica</name> <size>36</size> </font>   You get the first child. Oops . . . it is a text node containing whitespace "\n ". You skip text nodes and find the first element node. Then, you need to check that its tag name is "name" and that it has one child node of type Text. You move on to the next nonwhitespace child and make the same check. What if the author of the document switched the order of the children or added another child element? It is tedious to code all this error checking—but reckless to skip the checks. 
XML	Generating XML Documents	  You now know how to write Java programs that read XML. Let us now turn to the opposite process: producing XML output. Of course, you could write an XML file simply by making a sequence of print calls, printing the elements, attributes, and text content, but that would not be a good idea. The code is rather tedious, and you can easily make mistakes if you don’t pay attention to special symbols (such as " or <) in the attribute values and text content. 
XML	Using Namespaces	  The Java language uses packages to avoid name clashes. Programmers can use the same name for different classes as long as they aren’t in the same package. 
XML	XSL Transformations	  The XSL Transformations (XSLT) mechanism allows you to specify rules for transforming XML documents into other formats, such as plain text, XHTML, or any other XML format. XSLT is commonly used to translate from one machinereadable XML format to another, or to translate XML into a presentation format for human consumption. 
Native Methods	Calling Java Methods	  963   static {}; 
Native Methods	Accessing Fields	  All the native methods you saw so far were static methods with number and string parameters. We’ll now consider native methods that operate on objects. 
Native Methods	Using the Invocation API	  Up to now, we have considered programs in the Java programming language that made a few C calls, presumably because C was faster or allowed access to functionality inaccessible from the Java platform. Suppose you are in the opposite situation. You have a C or C++ program and would like to make calls to Java code. The invocation API enables you to embed the Java virtual machine into a C or C++ program. Here is the minimal code that you need to initialize a virtual machine: JavaVMOption options[1]; 
Native Methods	A Complete Example: Accessing the Windows Registry	  985   gcc -D_WINDOWS -mno-cygwin -I jdk\include -I jdk\include\win32 -D__int64="long long" 
Native Methods	Numeric Parameters and Return Values	  947   NOTE: Some shared libraries for native code must execute certain initializations. 
Native Methods	Calling a C Function from a Java Program	  Suppose you have a C function that does something you like and, for one reason or another, you don’t want to bother reimplementing it in Java. For the sake of illustration, we’ll start with a simple C function that prints a greeting. 
Native Methods	String Parameters	  949   The function simply assembles a format string "%w.pf" in the variable fmt, then calls printf. It returns the number of characters printed. 
Native Methods	Accessing Array Elements	  All array types of the Java programming language have corresponding C types, as shown in Table 12.2. 
Native Methods	Encoding Signatures	  961   Accessing Fields (Continued)   • void SetXxxField(JNIEnv *env, jobject obj, jfieldID id, Xxx value) sets a field to a new value.The field type Xxx is one of Object, Boolean, Byte, Char, Short, Int, Long, Float, or Double. 
Native Methods	Handling Errors	  Native methods are a significant security risk to Java programs. The C runtime system has no protection against array bounds errors, indirection through bad pointers, and so on. It is particularly important that programmers of native methods handle all error conditions to preserve the integrity of the Java platform. 
Advanced Swing	Lists	  If you want to present a set of choices to a user, and a radio button or checkbox set consumes too much space, you can use a combo box or a list. Combo boxes were covered in Volume I because they are relatively simple. The JList component has many more features, and its design is similar to that of the tree and table components. For that reason, it is our starting point for the discussion of complex Swing components. 
Advanced Swing	Text Components	  681   10.4 Text Components Figure 10.35 shows all text components that are included in the Swing library. 
Advanced Swing	Progress Indicators	  719   javax.swing.event.HyperlinkEvent 1.2   • URL getURL() returns the URL of the selected hyperlink. 
Advanced Swing	Trees	  639   10.3 Trees Every computer user who has worked with a hierarchical file system has seen tree displays. Of course, directories and files form only one of the many examples of tree-like organizations. Many tree structures arise in everyday life, such as the hierarchy of countries, states, and cities shown in Figure 10.15. 
Advanced Swing	Component Organizers and Decorators	  731   javax.swing.ProgressMonitor 1.2   • ProgressMonitor(Component parent, Object message, String note, int min, int max) constructs a progress monitor dialog box. 
Advanced Swing	Tables	  599   javax.swing.JList<E> 1.2   • Color getBackground() returns the background color for unselected cells. 
Security	Encryption	  public void loadFile(String filename) { fileText.setText(""); 
Security	Digital Signatures	  As we said earlier, applets were what started the Java craze. In practice, people discovered that although they could write animated applets (like the famous   From the Library of Hristo Dimov Hristov   9.4 Digital Signatures   547   “nervous text”), applets could not do a whole lot of useful stuff in the JDK 1.0 security model. For example, since applets under JDK 1.0 were so closely supervised, they couldn’t do much good on a corporate intranet, even though relatively little risk attaches to executing an applet from your company’s secure intranet. 
Security	User Authentication	  The Java API provides a framework, called the Java Authentication and Authorization Service (JAAS), that integrates platform-provided authentication with permission management. We’ll discuss the JAAS framework in the following sections. 
Security	Class Loaders	  A Java compiler converts source instructions into code for the Java virtual machine. 
Security	Security Managers and Permissions	  509   9.2 Security Managers and Permissions Once a class has been loaded into the virtual machine and checked by the verifier, the second security mechanism of the Java platform springs into action: the security manager. This is the topic of the following sections. 
Networking	Sending E-Mail	  277   java.net.HttpURLConnection 1.0   • InputStream getErrorStream() returns a stream from which you can read web server error messages. 
Networking	Getting Web Data	  257   java.nio.channels.Channels 1.4 (Continued)   • static OutputStream newOutputStream(WritableByteChannel channel) constructs an output stream that writes to the given channel. 
Networking	Implementing Servers	  public static void main(String[] args) throws IOException { if (args.length > 0) { String host = args[0]; 
Networking	Connecting to a Server	  In the following sections, you will connect to a server, first by hand and with telnet, and then with a Java program. 
Networking	Interruptible Sockets	  When you connect to a socket, the current thread blocks until the connection has been established or a timeout has elapsed. Similarly, when you read or write data through a socket, the current thread blocks until the operation is successful or has timed out. 
Advanced AWT	Platform Integration	  921   javax.swing.text.JTextComponent.DropLocation 6   • int getIndex() the index at which to insert the data. 
Advanced AWT	The Rendering Pipeline	  The original JDK 1.0 had a very simple mechanism for drawing shapes. You selected color and paint mode, and called methods of the Graphics class such as drawRect or fillOval. The Java 2D API supports many more options. 
Advanced AWT	Readers and Writers for Images	  823   113   /** * Sets the hints and repaints. 
Advanced AWT	Shapes	  769   11.2 Shapes Here are some of the methods in the Graphics class to draw shapes: drawLine drawRectangle drawRoundRect draw3DRect drawPolygon drawPolyline drawOval drawArc   There are also corresponding fill methods. These methods have been in the Graphics class ever since JDK 1.0. The Java 2D API uses a completely different, object-oriented approach. Instead of methods, there are classes: Line2D Rectangle2D RoundRectangle2D Ellipse2D Arc2D QuadCurve2D CubicCurve2D GeneralPath   These classes all implement the Shape interface, which we will examine in the following sections. 
Advanced AWT	Clipping	  805   11.7 Clipping By setting a clipping shape in the graphics context, you constrain all drawing operations to the interior of that clipping shape. 
Advanced AWT	Rendering Hints	  817   java.awt.AlphaComposite 1.2   • static AlphaComposite getInstance(int rule) • static AlphaComposite getInstance(int rule, float sourceAlpha) constructs an alpha composite object. The rule is one of CLEAR, SRC, SRC_OVER, DST_OVER, SRC_IN, SRC_OUT, DST_IN, DST_OUT, DST, DST_ATOP, SRC_ATOP, XOR. 
Advanced AWT	The Clipboard	  887   This concludes our discussion of printing. You now know how to print 2D graphics and other document types, how to enumerate printers and stream print services, and how to set and retrieve attributes. Next, we turn to two important user interface issues: the clipboard and the drag-and-drop mechanism. 
Advanced AWT	Drag and Drop	  903   java.awt.datatransfer.Clipboard 1.1   • Clipboard(String name) constructs a local clipboard with the given name. 
Advanced AWT	Coordinate Transformations	  799   java.awt.TexturePaint 1.2   • TexturePaint(BufferedImage texture, Rectangle2D anchor) creates a texture paint object. The anchor rectangle defines the tiling of the space to be painted; it is repeated indefinitely in x and y directions, and the texture image is scaled to fill each tile. 
Advanced AWT	Image Manipulation	  Suppose you have an image and you would like to improve its appearance. You then need to access the individual pixels of the image and replace them with other pixels. Or perhaps you want to compute the pixels of an image from scratch—for example, to show the result of physical measurements or a mathematical computation. The BufferedImage class gives you control over the pixels in an image, and the classes that implement the BufferedImageOp interface let you transform images. 
Advanced AWT	Printing	  851   java.awt.image.ShortLookupTable 1.2   • ShortLookupTable(int offset, short[] data) • ShortLookupTable(int offset, short[][] data) constructs a lookup table for converting short values. The offset is subtracted from the input before the lookup. The values in the first constructor are applied to all color components but not the alpha component.When using the second constructor, you supply either the values for each color component, in which case the alpha component is unaffected, or the values for both alpha and color components. 
Advanced AWT	Paint	  797   11.5 Paint When you fill a shape, its inside is covered with paint. Use the setPaint method to set the paint style to an object whose class implements the Paint interface. The Java 2D API provides three such classes: • The Color class implements the Paint interface. To fill shapes with a solid color, simply call setPaint with a Color object, such as g2.setPaint(Color.red); 
Advanced AWT	Strokes	  The draw operation of the Graphics2D class draws the boundary of a shape by using the currently selected stroke. By default, the stroke is a solid line that is 1 pixel wide. You can select a different stroke by calling the setStroke method and supplying an object of a class that implements the Stroke interface. The Java 2D API defines only one such class, called BasicStroke. In this section, we’ll look at the capabilities of the BasicStroke class. 
Advanced AWT	Areas	  In the preceding section, you saw how you can specify complex shapes by constructing general paths composed of lines and curves. By using a sufficient number of lines and curves, you can draw essentially any shape. For example, the shapes of characters in the fonts that you see on the screen and on your printouts are all made up of lines and cubic curves. 
Advanced AWT	Transparency and Composition	  807   java.awt.Graphics2D 1.2   • void clip(Shape s) intersects the current clipping shape with the shape s. 
