  The Java language uses packages to avoid name clashes. Programmers can use the same name for different classes as long as they aren’t in the same package. 
  XML has a similar namespace mechanism for element and attribute names. 
  A namespace is identified by a Uniform Resource Identifier (URI), such as http://www.w3.org/2001/XMLSchema uuid:1c759aed-b748-475c-ab68-10679700c4f2 urn:com:books-r-us   The HTTP URL form is the most common. Note that the URL is just used as an identifier string, not as a locator for a document. For example, the namespace identifiers http://www.horstmann.com/corejava http://www.horstmann.com/corejava/index.html   denote different namespaces, even though a web server would serve the same document for both URLs. 
  There need not be any document at a namespace URL—the XML parser doesn’t attempt to find anything at that location. However, as a help to programmers who encounter a possibly unfamiliar namespace, it is customary to place a document explaining the purpose of the namespace at the URL location. For example, if you point your browser to the namespace URL for the XML Schema namespace (http://www.w3.org/2001/XMLSchema), you will find a document describing the XML Schema standard. 
  From the Library of Hristo Dimov Hristov   3.5 Using Namespaces   197   Why use HTTP URLs for namespace identifiers? It is easy to ensure that they are unique. If you choose a real URL, the host part’s uniqueness is guaranteed by the domain name system. Your organization can then arrange for the uniqueness of the remainder of the URL. This is the same rationale that underlies the use of reversed domain names in Java package names. 
  Of course, although long namespace identifiers are good for uniqueness, you don’t want to deal with long identifiers any more than you have to. In the Java programming language, you use the import mechanism to specify the long names of packages, and then use just the short class names. In XML, there is a similar mechanism: <element xmlns="namespaceURI"> children </element>   The element and its children are now part of the given namespace. 
  A child can provide its own namespace, for example: <element xmlns="namespaceURI1"> <child xmlns="namespaceURI2"> grandchildren </child> more children </element>   Then the first child and the grandchildren are part of the second namespace. 
  This simple mechanism works well if you need only a single namespace or if the namespaces are naturally nested. Otherwise, you will want to use a second mechanism that has no analog in Java. You can have a prefix for a namespace—a short identifier that you choose for a particular document. Here is a typical example—the xsd prefix in an XML Schema file: <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema"> <xsd:element name="gridbag" type="GridBagType"/> ... 
  </xsd:schema>   The attribute xmlns:prefix="namespaceURI" 
  defines a namespace and a prefix. In our example, the prefix is the string xsd. Thus, xsd:schema really means schema in the namespace http://www.w3.org/2001/XMLSchema. 
  From the Library of Hristo Dimov Hristov   198   Chapter 3   XML   NOTE: Only child elements inherit the namespace of their parent. Attributes without an explicit prefix are never part of a namespace. Consider this contrived example: <configuration xmlns="http://www.horstmann.com/corejava" 
  xmlns:si="http://www.bipm.fr/enus/3_SI/si.html"> <size value="210" si:unit="mm"/> ... 
  </configuration>   In this example, the elements configuration and size are part of the namespace with URI http://www.horstmann.com/corejava. The attribute si:unit is part of the namespace with URI http://www.bipm.fr/enus/3_SI/si.html. However, the attribute value is not part of any namespace. 
  You can control how the parser deals with namespaces. By default, the DOM parser of the Java XML library is not namespace-aware. 
  To turn on namespace handling, call the setNamespaceAware method of the DocumentBuilderFactory: factory.setNamespaceAware(true); 
  Now, all builders the factory produces support namespaces. Each node has three properties: • The qualified name, with a prefix, returned by getNodeName, getTagName, and so on • The namespace URI, returned by the getNamespaceURI method • The local name, without a prefix or a namespace, returned by the getLocalName method Here is an example. Suppose the parser sees the following element: <xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">   It then reports the following: • Qualified name = xsd:schema • Namespace URI = http://www.w3.org/2001/XMLSchema • Local name = schema NOTE: If namespace awareness is turned off, getNamespaceURI and getLocalName return null. 
