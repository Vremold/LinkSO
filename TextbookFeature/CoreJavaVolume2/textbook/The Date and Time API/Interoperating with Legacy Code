  369   6.7 Interoperating with Legacy Code As a brand-new creation, the Java Date and Time API will have to interoperate with existing classes—in particular, the ubiquitous java.util.Date, java.util. 
  GregorianCalendar, and java.sql.Date/Time/Timestamp. 
  The Instant class is a close analog to java.util.Date. In Java SE 8, that class has two added methods: the toInstant method that converts a Date to an Instant, and the static from method that converts in the other direction. 
  Similarly, ZonedDateTime is a close analog to java.util.GregorianCalendar, and that class has gained conversion methods in Java SE 8. The toZonedDateTime method converts a GregorianCalendar to a ZonedDateTime, and the static from method does the opposite conversion. 
  Another set of conversions is available for the date and time classes in the java.sql package. You can also pass a DateTimeFormatter to legacy code that uses java.text.Format. 
  Table 6.9 summarizes these conversions. 
  Table 6.9 Conversions between java.time Classes and Legacy Classes Classes   To Legacy Class   From Legacy Class   Instant ↔ java.util.Date   Date.from(instant)   date.toInstant()   ZonedDateTime ↔ java.util.GregorianCalendar   GregorianCalendar. 
  from(zonedDateTime)   cal.toZonedDateTime()   Instant ↔ java.sql.Timestamp   TimeStamp.from(instant)   timestamp.toInstant()   LocalDateTime ↔ java.sql.Timestamp   Timestamp.valueOf(localDateTime)   timeStamp.toLocalDateTime()   LocalDate ↔ java.sql.Date   Date.valueOf(localDate)   date.toLocalDate()   LocalTime ↔ java.sql.Time   Time.valueOf(localTime)   time.toLocalTime()   DateTimeFormatter → java.text.DateFormat   formatter.toFormat()   None   java.util.TimeZone → ZoneId   Timezone.getTimeZone(id)   timeZone.toZoneId()   java.nio.file.attribute.FileTime → Instant   FileTime.from(instant)   fileTime.toInstant()   From the Library of Hristo Dimov Hristov   370   Chapter 6   The Date and Time API   You now know how to use the Java 8 date and time library to work with date and time values around the world. The next chapter takes the discussion of programming for an international audience further. You will see how to format program messages, numbers, and currencies in the way that makes sense for your customers, wherever they may be. 
