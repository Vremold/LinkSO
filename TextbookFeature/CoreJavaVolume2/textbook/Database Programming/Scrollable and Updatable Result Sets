  321   vendor-independent solution for generating keys, it does provide an efficient way of retrieving them. When you insert a new row into a table and a key is automatically generated, you can retrieve it with the following code: stat.executeUpdate(insertStatement, Statement.RETURN_GENERATED_KEYS); 
  ResultSet rs = stat.getGeneratedKeys(); 
  if (rs.next()) { int key = rs.getInt(1); 
  ... 
  } 
  java.sql.Statement 1.1   • boolean execute(String statement, int autogenerated) 1.4 • int executeUpdate(String statement, int autogenerated) 1.4 executes the given SQL statement, as previously described. If autogenerated is set to Statement.RETURN_GENERATED_KEYS and the statement is an INSERT statement, the first column contains the autogenerated key. 
  5.6 Scrollable and Updatable Result Sets As you have seen, the next method of the ResultSet interface iterates over the rows in a result set. That is certainly adequate for a program that needs to analyze the data. However, consider a visual data display that shows a table or query results (such as Figure 5.4 on p. 288). You usually want the user to be able to move both forward and backward in the result set. In a scrollable result, you can move forward and backward through a result set and even jump to any position. 
  Furthermore, once users see the contents of a result set displayed, they may be tempted to edit it. In an updatable result set, you can programmatically update entries so that the database is automatically updated. We discuss these capabilities in the following sections. 
5.6.1 Scrollable Result Sets
  By default, result sets are not scrollable or updatable. To obtain scrollable result sets from your queries, you must obtain a different Statement object with the method Statement stat = conn.createStatement(type, concurrency); 
  From the Library of Hristo Dimov Hristov   322   Chapter 5   Database Programming   For a prepared statement, use the call PreparedStatement stat = conn.prepareStatement(command, type, concurrency); 
  The possible values of type and concurrency are listed in Tables 5.6 and 5.7. You have the following choices: • Do you want the result set to be scrollable? If not, use ResultSet.TYPE_FORWARD_ONLY. 
  • If the result set is scrollable, do you want it to reflect changes in the database that occurred after the query that yielded it? (In our discussion, we assume the ResultSet.TYPE_SCROLL_INSENSITIVE setting for scrollable result sets. This assumes that the result set does not “sense” database changes that occurred after execution of the query.) • Do you want to be able to update the database by editing the result set? (See the next section for details.)   Table 5.6   ResultSet Type Values   Value   Explanation   TYPE_FORWARD_ONLY   The result set is not scrollable (default). 
  TYPE_SCROLL_INSENSITIVE   The result set is scrollable but not sensitive to database changes. 
  TYPE_SCROLL_SENSITIVE   The result set is scrollable and sensitive to database changes. 
  Table 5.7   ResultSet Concurrency Values   Value   Explanation   CONCUR_READ_ONLY   The result set cannot be used to update the database (default). 
  CONCUR_UPDATABLE   The result set can be used to update the database. 
  For example, if you simply want to be able to scroll through a result set but don’t want to edit its data, use Statement stat = conn.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY); 
  All result sets that are returned by method calls ResultSet rs = stat.executeQuery(query); 
  are now scrollable. A scrollable result set has a cursor that indicates the current position. 
  From the Library of Hristo Dimov Hristov   5.6 Scrollable and Updatable Result Sets   323   NOTE: Not all database drivers support scrollable or updatable result sets. (The supportsResultSetType and supportsResultSetConcurrency methods of the DatabaseMetaData interface will tell you which types and concurrency modes are supported by a particular database using a particular driver.) Even if a database supports all result set modes, a particular query might not be able to yield a result set with all the properties that you requested. (For example, the result set of a complex query might not be updatable.) In that case, the executeQuery method returns a ResultSet of lesser capabilities and adds a SQLWarning to the connection object. 
  (Section 5.4.3, “Analyzing SQL Exceptions,” on p. 302 shows how to retrieve the warning.) Alternatively, you can use the getType and getConcurrency methods of the ResultSet interface to find out what mode a result set actually has. If you do not check the result set capabilities and issue an unsupported operation, such as previous on a result set that is not scrollable, the operation will throw a SQLException. 
  Scrolling is very simple. Use if (rs.previous()) . . . 
  to scroll backward. The method returns true if the cursor is positioned on an actual row, or false if it is now positioned before the first row. 
  You can move the cursor backward or forward by a number of rows with the call rs.relative(n); 
  If n is positive, the cursor moves forward. If n is negative, it moves backward. If n is zero, the call has no effect. If you attempt to move the cursor outside the current set of rows, it is set to point either after the last row or before the first row, depending on the sign of n . Then, the method returns false and the cursor does not move. The method returns true if the cursor is positioned on an actual row. 
  Alternatively, you can set the cursor to a particular row number: rs.absolute(n); 
  To get the current row number, call int currentRow = rs.getRow(); 
  The first row in the result set has number 1. If the return value is 0, the cursor is not currently on a row—it is either before the first row or after the last row. 
  The convenience methods first, last, beforeFirst, and afterLast move the cursor to the first, to the last, before the first, or after the last position. 
  From the Library of Hristo Dimov Hristov   324   Chapter 5   Database Programming   Finally, the methods isFirst, isLast, isBeforeFirst, and isAfterLast test whether the cursor is at one of these special positions. 
  Using a scrollable result set is very simple. The hard work of caching the query data is carried out behind the scenes by the database driver. 
5.6.2 Updatable Result Sets
  If you want to edit the data in the result set and have the changes automatically reflected in the database, create an updatable result set. Updatable result sets don’t have to be scrollable, but if you present data to a user for editing, you usually want to allow scrolling as well. 
  To obtain updatable result sets, create a statement as follows: Statement stat = conn.createStatement( ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_UPDATABLE); 
  The result sets returned by a call to executeQuery are then updatable. 
  NOTE: Not all queries return updatable result sets. If your query is a join that involves multiple tables, the result might not be updatable. However, if your query involves only a single table or if it joins multiple tables by their primary keys, you should expect the result set to be updatable. Call the getConcurrency method of the ResultSet interface to find out for sure. 
  For example, suppose you want to raise the prices of some books, but you don’t have a simple criterion for issuing an UPDATE statement. Then, you can iterate through all books and update prices based on arbitrary conditions. 
  String query = "SELECT * FROM Books"; 
  ResultSet rs = stat.executeQuery(query); 
  while (rs.next()) { if (. . .) { double increase = . . . 
  double price = rs.getDouble("Price"); 
  rs.updateDouble("Price", price + increase); 
  rs.updateRow(); // make sure to call updateRow after updating fields } 
  } 
  There are updateXxx methods for all data types that correspond to SQL types, such as updateDouble, updateString, and so on; specify the name or the number of the column (as with the getXxx methods), then the new value for the field. 
  From the Library of Hristo Dimov Hristov   5.6 Scrollable and Updatable Result Sets   325   NOTE: If you use the updateXxx method whose first parameter is the column number, be aware that this is the column number in the result set. It could well be different from the column number in the database. 
  The updateXxx method changes only the row values, not the database. When you are done with the field updates in a row, you must call the updateRow method. That method sends all updates in the current row to the database. If you move the cursor to another row without calling updateRow, this row’s updates are discarded from the row set and never communicated to the database. You can also call the cancelRowUpdates method to cancel the updates to the current row. 
  The preceding example shows how to modify an existing row. If you want to add a new row to the database, first use the moveToInsertRow method to move the cursor to a special position, called the insert row. Then, build up a new row in the insert row position by issuing updateXxx instructions. When you are done, call the insertRow method to deliver the new row to the database. When you are done inserting, call moveToCurrentRow to move the cursor back to the position before the call to moveToInsertRow. Here is an example: rs.moveToInsertRow(); 
  rs.updateString("Title", title); 
  rs.updateString("ISBN", isbn); 
  rs.updateString("Publisher_Id", pubid); 
  rs.updateDouble("Price", price); 
  rs.insertRow(); 
  rs.moveToCurrentRow(); 
  Note that you cannot influence where the new data is added in the result set or the database. 
  If you don’t specify a column value in the insert row, it is set to a SQL NULL. 
  However, if the column has a NOT NULL constraint, an exception is thrown and the row is not inserted. 
  Finally, you can delete the row under the cursor: rs.deleteRow(); 
  The deleteRow method immediately removes the row from both the result set and the database. 
  The updateRow, insertRow, and deleteRow methods of the ResultSet interface give you the same power as executing UPDATE, INSERT, and DELETE SQL statements. However, Java programmers might find it more natural to manipulate the database contents through result sets than by constructing SQL statements. 
  From the Library of Hristo Dimov Hristov   326   Chapter 5   Database Programming   CAUTION: If you are not careful, you can write staggeringly inefficient code with updatable result sets. It is much more efficient to execute an UPDATE statement than to make a query and iterate through the result, changing data along the way. Updatable result sets make sense for interactive programs in which a user can make arbitrary changes, but for most programmatic changes, a SQL UPDATE is more appropriate. 
  NOTE: JDBC 2 delivered further enhancements to result sets, such as the capability to update a result set with the most recent data if the data have been modified by another concurrent database connection. JDBC 3 added yet another refinement, specifying the behavior of result sets when a transaction is committed. 
  However, these advanced features are outside the scope of this introductory chapter. We refer you to the JDBC™ API Tutorial and Reference,Third Edition, by Maydene Fisher, Jon Ellis, and Jonathan Bruce (Addison-Wesley, 2003) and the JDBC specification for more information. 
  java.sql.Connection 1.1   • Statement createStatement(int type, int concurrency) 1.2 • PreparedStatement prepareStatement(String command, int type, int concurrency) 1.2 creates a statement or prepared statement that yields result sets with the given type and concurrency. 
  Parameters:   command   The command to prepare   type   One of the constants TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, or TYPE_SCROLL_SENSITIVE of the ResultSet interface   concurrency   One of the constants CONCUR_READ_ONLY or CONCUR_UPDATABLE of the ResultSet interface   java.sql.ResultSet 1.1   • int getType() 1.2 returns the type of this result set—one of TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, or TYPE_SCROLL_SENSITIVE. 
  (Continues)   From the Library of Hristo Dimov Hristov   5.6 Scrollable and Updatable Result Sets   327   java.sql.ResultSet 1.1 (Continued)   • int getConcurrency() 1.2 returns the concurrency setting of this result set—one of CONCUR_READ_ONLY or CONCUR_UPDATABLE. 
  • boolean previous() 1.2 moves the cursor to the preceding row. Returns true if the cursor is positioned on a row, or false if the cursor is positioned before the first row. 
  • int getRow() 1.2 gets the number of the current row. Rows are numbered starting with 1. 
  • boolean absolute(int r) 1.2 moves the cursor to row r. Returns true if the cursor is positioned on a row. 
  • boolean relative(int d) 1.2 moves the cursor by d rows. If d is negative, the cursor is moved backward. Returns true if the cursor is positioned on a row. 
  • boolean first() 1.2 • boolean last() 1.2 moves the cursor to the first or last row. Returns true if the cursor is positioned on a row. 
  • void beforeFirst() 1.2 • void afterLast() 1.2 moves the cursor before the first or after the last row. 
  • boolean isFirst() 1.2 • boolean isLast() 1.2 tests whether the cursor is at the first or last row. 
  • boolean isBeforeFirst() 1.2 • boolean isAfterLast() 1.2 tests whether the cursor is before the first or after the last row. 
  • void moveToInsertRow() 1.2 moves the cursor to the insert row. The insert row is a special row for inserting new data with the updateXxx and insertRow methods. 
  • void moveToCurrentRow() 1.2 moves the cursor back from the insert row to the row that it occupied when the moveToInsertRow method was called. 
  (Continues)   From the Library of Hristo Dimov Hristov   328   Chapter 5   Database Programming   java.sql.ResultSet 1.1 (Continued)   • void insertRow() 1.2 inserts the contents of the insert row into the database and the result set. 
  • void deleteRow() 1.2 deletes the current row from the database and the result set. 
  • void updateXxx(int column, Xxx data) 1.2 • void updateXxx(String columnName, Xxx data) 1.2 (Xxx is a type such as int, double, String, Date, etc.) updates a field in the current row of the result set. 
  • void updateRow() 1.2 sends the current row updates to the database. 
  • void cancelRowUpdates() 1.2 cancels the current row updates. 
  java.sql.DatabaseMetaData 1.1   • boolean supportsResultSetType(int type) 1.2 returns true if the database can support result sets of the given type; type is one of the constants TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, or TYPE_SCROLL_SENSITIVE of the ResultSet interface. 
  • boolean supportsResultSetConcurrency(int type, int concurrency) 1.2 returns true if the database can support result sets of the given combination of type and concurrency. 
