  As mentioned in Items 85 and 86 and discussed throughout this chapter, the decision to implement Serializable increases the likelihood of bugs and security problems as it allows instances to be created using an extralinguistic mechanism in place of ordinary constructors. There is, however, a technique that greatly reduces these risks. This technique is known as the serialization proxy pattern. 
  The serialization proxy pattern is reasonably straightforward. First, design a private static nested class that concisely represents the logical state of an instance of the enclosing class. This nested class is known as the serialization proxy of the enclosing class. It should have a single constructor, whose parameter type is the enclosing class. This constructor merely copies the data from its argument: it need not do any consistency checking or defensive copying. By design, the default serialized form of the serialization proxy is the perfect serialized form of the enclosing class. Both the enclosing class and its serialization proxy must be declared to implement Serializable. 
  For example, consider the immutable Period class written in Item 50 and made serializable in Item 88. Here is a serialization proxy for this class. Period is so simple that its serialization proxy has exactly the same fields as the class: // Serialization proxy for Period class private static class SerializationProxy implements Serializable { private final Date start; 
  private final Date end; 
  SerializationProxy(Period p) { this.start = p.start; 
  this.end = p.end; 
  } 
  private static final long serialVersionUID = 234098243823485285L; // Any number will do (Item 87) } 
  Next, add the following writeReplace method to the enclosing class. This method can be copied verbatim into any class with a serialization proxy: // writeReplace method for the serialization proxy pattern private Object writeReplace() { return new SerializationProxy(this); 
  } 
  The presence of this method on the enclosing class causes the serialization system to emit a SerializationProxy instance instead of an instance of the enclosing class. In other words, the writeReplace method translates an instance of the enclosing class to its serialization proxy prior to serialization. 
  With this writeReplace method in place, the serialization system will never generate a serialized instance of the enclosing class, but an attacker might fabricate one in an attempt to violate the class’s invariants. To guarantee that such an attack would fail, merely add this readObject method to the enclosing class: // readObject method for the serialization proxy pattern private void readObject(ObjectInputStream stream) throws InvalidObjectException { throw new InvalidObjectException("Proxy required"); 
  } 
  Finally, provide a readResolve method on the SerializationProxy class that returns a logically equivalent instance of the enclosing class. The presence of this method causes the serialization system to translate the serialization proxy back into an instance of the enclosing class upon deserialization. 
  This readResolve method creates an instance of the enclosing class using only its public API and therein lies the beauty of the pattern. It largely eliminates the extralinguistic character of serialization, because the deserialized instance is created using the same constructors, static factories, and methods as any other instance. This frees you from having to separately ensure that deserialized instances obey the class’s invariants. If the class’s static factories or constructors establish these invariants and its instance methods maintain them, you’ve ensured that the invariants will be maintained by serialization as well. 
  Here is the readResolve method for Period.SerializationProxy above: // readResolve method for Period.SerializationProxy private Object readResolve() { return new Period(start, end); // Uses public constructor } 
  Like the defensive copying approach (page 357), the serialization proxy approach stops the bogus byte-stream attack (page 354) and the internal field theft attack (page 356) dead in their tracks. Unlike the two previous approaches, this one allows the fields of Period to be final, which is required in order for the Period class to be truly immutable (Item 17). And unlike the two previous approaches, this one doesn’t involve a great deal of thought. You don’t have to figure out which fields might be compromised by devious serialization attacks, nor do you have to explicitly perform validity checking as part of deserialization. 
  There is another way in which the serialization proxy pattern is more powerful than defensive copying in readObject. The serialization proxy pattern allows the deserialized instance to have a different class from the originally serialized instance. You might not think that this would be useful in practice, but it is. 
  Consider the case of EnumSet (Item 36). This class has no public constructors, only static factories. From the client’s perspective, they return EnumSet instances, but in the current OpenJDK implementation, they return one of two subclasses, depending on the size of the underlying enum type. If the underlying enum type has sixty-four or fewer elements, the static factories return a RegularEnumSet; 
  otherwise, they return a JumboEnumSet. 
  Now consider what happens if you serialize an enum set whose enum type has sixty elements, then add five more elements to the enum type, and then deserialize the enum set. It was a RegularEnumSet instance when it was serialized, but it had better be a JumboEnumSet instance once it is deserialized. In fact that’s exactly what happens, because EnumSet uses the serialization proxy pattern. In case you’re curious, here is EnumSet’s serialization proxy. It really is this simple: // EnumSet's serialization proxy private static class SerializationProxy <E extends Enum<E>> implements Serializable { // The element type of this enum set. 
  private final Class<E> elementType; 
  // The elements contained in this enum set. 
  private final Enum<?>[] elements; 
  SerializationProxy(EnumSet<E> set) { elementType = set.elementType; 
  elements = set.toArray(new Enum<?>[0]); 
  } 
  private Object readResolve() { EnumSet<E> result = EnumSet.noneOf(elementType); 
  for (Enum<?> e : elements) result.add((E)e); 
  return result; 
  } 
  private static final long serialVersionUID = 362491234563181265L; 
  } 
  The serialization proxy pattern has two limitations. It is not compatible with classes that are extendable by their users (Item 19). Also, it is not compatible with some classes whose object graphs contain circularities: if you attempt to invoke a method on such an object from within its serialization proxy’s readResolve method, you’ll get a ClassCastException because you don’t have the object yet, only its serialization proxy. 
  Finally, the added power and safety of the serialization proxy pattern are not free. On my machine, it is 14 percent more expensive to serialize and deserialize Period instances with serialization proxies than it is with defensive copying. 
  In summary, consider the serialization proxy pattern whenever you find yourself having to write a readObject or writeObject method on a class that is not extendable by its clients. This pattern is perhaps the easiest way to robustly serialize objects with nontrivial invariants. 
  A P P E N D I X Items Corresponding to Second Edition Second Edition Item Number Third Edition Item Number, Title 1, Consider static factory methods instead of constructors 2, Consider a builder when faced with many constructor parameters 3, Enforce the singleton property with a private constructor or an enum type 4, Enforce noninstantiability with a private constructor 6, Avoid creating unnecessary objects 7, Eliminate obsolete object references 8, Avoid finalizers and cleaners 10, Obey the general contract when overriding equals 11, Always override hashCode when you override equals 12, Always override toString 13, Override clone judiciously 14, Consider implementing Comparable 15, Minimize the accessibility of classes and members 16, In public classes, use accessor methods, not public fields 17, Minimize mutability 18, Favor composition over inheritance 19, Design and document for inheritance or else prohibit it APPENDIX Second Edition Item Number Third Edition Item Number, Title 20, Prefer interfaces to abstract classes 22, Use interfaces only to define types 23, Prefer class hierarchies to tagged classes 42, Prefer lambdas to anonymous classes 24, Favor static member classes over nonstatic 26, Don’t use raw types 27, Eliminate unchecked warnings 28, Prefer lists to arrays 29, Favor generic types 30, Favor generic methods 31, Use bounded wildcards to increase API flexibility 33, Consider typesafe heterogeneous containers 34, Use enums instead of int constants 35, Use instance fields instead of ordinals 36, Use EnumSet instead of bit fields 37, Use EnumMap instead of ordinal indexing 38, Emulate extensible enums with interfaces 39, Prefer annotations to naming patterns 40, Consistently use the Override annotation 41, Use marker interfaces to define types 49, Check parameters for validity 50, Make defensive copies when needed 51, Design method signatures carefully 52, Use overloading judiciously ITEMS CORRESPONDING TO SECOND EDITION Second Edition Item Number Third Edition Item Number, Title 53, Use varargs judiciously 54, Return empty collections or arrays, not nulls 56, Write doc comments for all exposed API elements 57, Minimize the scope of local variables 58, Prefer for-each loops to traditional for loops 59, Know and use the libraries 60, Avoid float and double if exact answers are required 61, Prefer primitive types to boxed primitives 62, Avoid strings where other types are more appropriate 63, Beware the performance of string concatenation 64, Refer to objects by their interfaces 65, Prefer interfaces to reflection 66, Use native methods judiciously 67, Optimize judiciously 68, Adhere to generally accepted naming conventions 69, Use exceptions only for exceptional conditions 70, Use checked exceptions for recoverable conditions and runtime exceptions for programming errors 71, Avoid unnecessary use of checked exceptions 72, Favor the use of standard exceptions 73, Throw exceptions appropriate to the abstraction 74, Document all exceptions thrown by each method 75, Include failure-capture information in detail messages 76, Strive for failure atomicity 77, Don’t ignore exceptions APPENDIX Second Edition Item Number Third Edition Item Number, Title 78, Synchronize access to shared mutable data 79, Avoid excessive synchronization 80, Prefer executors, tasks, and streams to threads 81, 81, Prefer concurrency utilities to wait and notify 82, Document thread safety 83, Use lazy initialization judiciously 84, Don’t depend on the thread scheduler (Retired) 85, Prefer alternatives to Java serialization 86, 86, Implement Serializable with great caution 85, Prefer alternatives to Java serialization 87, Consider using a custom serialized form 85, Prefer alternatives to Java serialization 88, Write readObject methods defensively 85, Prefer alternatives to Java serialization 89, For instance control, prefer enum types to readResolve 85, Prefer alternatives to Java serialization 90, Consider serialization proxies instead of serialized instances References [Asserts] Programming with Assertions. 2002. Sun Microsystems. 
  http://docs.oracle.com/javase/8/docs/technotes/guides/language /assert.html [Beck04] Beck, Kent. 2004. JUnit Pocket Guide. Sebastopol, CA: O’Reilly Media, Inc. ISBN: 0596007434. 
  [Bloch01] Bloch, Joshua. 2001. Effective Java Programming Language Guide. Boston: Addison-Wesley. ISBN: 0201310058. 
  [Bloch05] Bloch, Joshua, and Neal Gafter. 2005. Java Puzzlers: Traps, Pitfalls, and Corner Cases. Boston: Addison-Wesley. 
  ISBN: 032133678X. 
  [Blum14] Blum, Scott. 2014. “Faster RSA in Java with GMP.” The Square Corner (blog). Feb. 14, 2014. https://medium.com/square-corner -blog/faster-rsa-in-java-with-gmp-8b13c51c6ec4 [Bracha04] Bracha, Gilad. 2004. “Lesson: Generics” online supplement to The Java Tutorial: A Short Course on the Basics, 6th ed. Upper Saddle River, NJ: Addison-Wesley, 2014. https://docs.oracle.com/javase /tutorial/extra/generics/ [Burn01] Burn, Oliver. 2001–2017. Checkstyle. 
  http://checkstyle.sourceforge.net REFERENCES [Coekaerts15] Coekaerts, Wouter (@WouterCoekaerts). 2015. “Billion-laughsstyle DoS for Java serialization https://gist.github.com/coekie/ a27cc406fc9f3dc7a70d … WONTFIX,” Twitter, November 9, 2015, 9:46 a.m. https://twitter.com/woutercoekaerts/status /663774695381078016 [CompSci17] Brief of Computer Scientists as Amici Curiae for the United States Court of Appeals for the Federal Circuit, Case No. 17-1118, Oracle America, Inc. v. Google, Inc. in Support of Defendant-Appellee. 
  (2017) [Dagger] Dagger. 2013. Square, Inc. http://square.github.io/dagger/ [Gallagher16] Gallagher, Sean. 2016. “Muni system hacker hit others by scanning for year-old Java vulnerability.” Ars Technica, November 29, 2016. 
  https://arstechnica.com/information-technology/2016/11/san -francisco-transit-ransomware-attacker-likely-used-year-old-java -exploit/ [Gamma95] Gamma, Erich, Richard Helm, Ralph Johnson, and John Vlissides. 
  1995. Design Patterns: Elements of Reusable Object-Oriented Software. Reading, MA: Addison-Wesley. ISBN: 0201633612. 
  [Goetz06] Goetz, Brian. 2006. Java Concurrency in Practice. With Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug Lea. Boston: Addison-Wesley. ISBN: 0321349601. 
  [Gosling97] Gosling, James. 1997. “The Feel of Java.” Computer 30 no. 6 (June 1997): 53-57. http://dx.doi.org/10.1109/2.587548 [Guava] Guava. 2017. Google Inc. https://github.com/google/guava [Guice] Guice. 2006. Google Inc. https://github.com/google/guice [Herlihy12] Herlihy, Maurice, and Nir Shavit. 2012. The Art of Multiprocessor Programming, Revised Reprint. Waltham, MA: Morgan Kaufmann Publishers. ISBN: 0123973376. 
  REFERENCES [Jackson75] Jackson, M. A. 1975. Principles of Program Design. London: Academic Press. ISBN: 0123790506. 
  [Java-secure] Secure Coding Guidelines for Java SE. 2017. Oracle. http:// www.oracle.com/technetwork/java/seccodeguide-139067.html [Java8-feat] What’s New in JDK 8. 2014. Oracle. http://www.oracle.com /technetwork/java/javase/8-whats-new-2157071.html [Java9-feat] Java Platform, Standard Edition What’s New in Oracle JDK 9. 
  2017. Oracle. https://docs.oracle.com/javase/9/whatsnew/toc.htm [Java9-api] Java Platform, Standard Edition & Java Development Kit Version 9 API Specification. 2017. Oracle. https://docs.oracle.com /javase/9/docs/api/overview-summary.html [Javadoc-guide] How to Write Doc Comments for the Javadoc Tool. 2000–2004. 
  Sun Microsystems. http://www.oracle.com/technetwork/java /javase/documentation/index-137868.html [Javadoc-ref] Javadoc Reference Guide. 2014-2017. Oracle. 
  https://docs.oracle.com/javase/9/javadoc/javadoc.htm [JLS] Gosling, James, Bill Joy, Guy Steele, and Gilad Bracha. 2014. The Java Language Specification, Java SE 8 Edition. Boston: AddisonWesley. ISBN: 013390069X. 
  [JMH] Code Tools: jmh. 2014. Oracle. 
  http://openjdk.java.net/projects/code-tools/jmh/ [JSON] Introducing JSON. 2013. Ecma International. https://www.json.org [Kahan91] Kahan, William, and J. W. Thomas. 1991. Augmenting a Programming Language with Complex Arithmetic. 
  UCB/CSD-91-667, University of California, Berkeley. 
  REFERENCES [Knuth74] Knuth, Donald. 1974. Structured Programming with go to Statements. In Computing Surveys 6: 261–301. 
  [Lea14] Lea, Doug. 2014. When to use parallel streams. 
  http://gee.cs.oswego.edu/dl/html/StreamParallelGuidance.html [Lieberman86] Lieberman, Henry. 1986. Using Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems. In Proceedings of the First ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, pages 214–223, Portland, September 1986. ACM Press. 
  [Liskov87] Liskov, B. 1988. Data Abstraction and Hierarchy. In Addendum to the Proceedings of OOPSLA ’87 and SIGPLAN Notices, Vol. 23, No. 5: 17–34, May 1988. 
  [Naftalin07] Naftalin, Maurice, and Philip Wadler. 2007. Java Generics and Collections. Sebastopol, CA: O’Reilly Media, Inc. 
  ISBN: 0596527756. 
  [Parnas72] Parnas, D. L. 1972. On the Criteria to Be Used in Decomposing Systems into Modules. In Communications of the ACM 15: 1053– 1058. 
  [POSIX] 9945-1:1996 (ISO/IEC) [IEEE/ANSI Std. 1003.1 1995 Edition] Information Technology—Portable Operating System Interface (POSIX)—Part 1: System Application: Program Interface (API) C Language] (ANSI), IEEE Standards Press, ISBN: 1559375736. 
  [Protobuf] Protocol Buffers. 2017. Google Inc. 
  https://developers.google.com/protocol-buffers [Schneider16] Schneider, Christian. 2016. SWAT (Serial Whitelist Application Trainer). https://github.com/cschneider4711/SWAT/ REFERENCES [Seacord17] Seacord, Robert. 2017. Combating Java Deserialization Vulnerabilities with Look-Ahead Object Input Streams (LAOIS). 
  San Francisco: NCC Group Whitepaper. 
  https://www.nccgroup.trust/globalassets/our-research/us/ whitepapers/2017/june/ncc_group_combating_java_deserialization _vulnerabilities_with_look-ahead_object_input_streams1.pdf [Serialization] Java Object Serialization Specification. March 2005. Sun Microsystems. http://docs.oracle.com/javase/9/docs/specs /serialization/index.html [Sestoft16] Sestoft, Peter. 2016. Java Precisely, 3rd ed. Cambridge, MA: The MIT Press. ISBN: 0262529076. 
  [Shipilëv16] Aleksey Shipilëv. 2016. Arrays of Wisdom of the Ancients. 
  https://shipilev.net/blog/2016/arrays-wisdom-ancients/ [Smith62] Smith, Robert. 1962. Algorithm 116 Complex Division. 
  In Communications of the ACM 5, no. 8 (August 1962): 435. 
  [Snyder86] Snyder, Alan. 1986. “Encapsulation and Inheritance in ObjectOriented Programming Languages.” In Object-Oriented Programming Systems, Languages, and Applications Conference Proceedings, 38–45. New York, NY: ACM Press. 
  [Spring] Spring Framework. Pivotal Software, Inc. 2017. 
  https://projects.spring.io/spring-framework/ [Stroustrup] Stroustrup, Bjarne. [ca. 2000]. “Is Java the language you would have designed if you didn’t have to be compatible with C?” Bjarne Stroustrup’s FAQ. Updated Ocober 1, 2017. 
  http://www.stroustrup.com/bs_faq.html#Java REFERENCES [Stroustrup95] Stroustrup, Bjarne. 1995. “Why C++ is not just an object-oriented programming language.” In Addendum to the proceedings of the 10th annual conference on Object-oriented programming systems, languages, and applications, edited by Steven Craig Bilow and Patricia S. Bilow New York, NY: ACM. 
  http://dx.doi.org/10.1145/260094.260207 [Svoboda16] Svoboda, David. 2016. Exploiting Java Serialization for Fun and Profit. Software Engineering Institute, Carnegie Mellon University. 
  https://resources.sei.cmu.edu/library/asset-view.cfm?assetid=484347 [Thomas94] Thomas, Jim, and Jerome T. Coonen. 1994. “Issues Regarding Imaginary Types for C and C++.” In The Journal of C Language Translation 5, no. 3 (March 1994): 134–138. 
  [ThreadStop] Why Are Thread.stop, Thread.suspend, Thread.resume and Runtime.runFinalizersOnExit Deprecated? 1999. Sun Microsystems. https://docs.oracle.com/javase/8/docs/technotes /guides/concurrency/threadPrimitiveDeprecation.html [Viega01] Viega, John, and Gary McGraw. 2001. Building Secure Software: How to Avoid Security Problems the Right Way. Boston: AddisonWesley. ISBN: 020172152X. 
  [W3C-validator]W3C Markup Validation Service. 2007. World Wide Web Consortium. http://validator.w3.org/ [Wulf72] Wulf, W. A Case Against the GOTO. 1972. In Proceedings of the 25th ACM National Conference 2: 791–797. New York, NY: ACM Press. 
