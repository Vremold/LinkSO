  In most practical multithreaded applications, two or more threads need to share access to the same data. What happens if two threads have access to the same object and each calls a method that modifies the state of the object? As you might imagine, the threads can step on each other’s toes. Depending on the order in which the data were accessed, corrupted objects can result. Such a situation is often called a race condition. 
12.4.1 An Example of a Race Condition
  To avoid corruption of shared data by multiple threads, you must learn how to synchronize the access. In this section, you’ll see what happens if you do not use synchronization. In the next section, you’ll see how to synchronize data access. 
  In the next test program, we continue working with our simulated bank. 
  Unlike the example in Section 12.1, "What Are Threads?," on p. 734, we randomly select the source and destination of the transfer. Since this will cause problems, let us look more carefully at the code for the transfer method of the Bank class. 
  public void transfer(int from, int to, double amount) // CAUTION: unsafe when called from multiple threads { System.out.print(Thread.currentThread()); 
  accounts[from] -= amount; 
  System.out.printf(" %10.2f from %d to %d", amount, from, to); 
  accounts[to] += amount; 
  System.out.printf(" Total Balance: %10.2f%n", getTotalBalance()); 
  } 
  Here is the code for the Runnable instances. The run method keeps moving money out of a given bank account. In each iteration, the run method picks a random target account and a random amount, calls transfer on the bank object, and then sleeps. 
  Runnable r = () -> { try { while (true) { int toAccount = (int) (bank.size() * Math.random()); 
  double amount = MAX_AMOUNT * Math.random(); 
  bank.transfer(fromAccount, toAccount, amount); 
  Thread.sleep((int) (DELAY * Math.random())); 
  } 
  } 
  catch (InterruptedException e) { } 
  }; 
  When this simulation runs, we do not know how much money is in any one bank account at any time. But we do know that the total amount of money in all the accounts should remain unchanged because all we do is move money from one account to another. 
  At the end of each transaction, the transfer method recomputes the total and prints it. 
  This program never finishes. Just press Ctrl+C to kill the program. 
  Here is a typical printout: . . . 
  Thread[Thread11,5,main] 588.48 from 11 to 44 Total Balance: Thread[Thread12,5,main] 976.11 from 12 to 22 Total Balance: Thread[Thread14,5,main] 521.51 from 14 to 22 Total Balance: Thread[Thread-   100000.00 100000.00 100000.00   13,5,main] 359.89 from 13 to 81 Total Balance: . . . 
  Thread[Thread36,5,main] 401.71 from 36 to 73 Total Balance: Thread[Thread35,5,main] 691.46 from 35 to 77 Total Balance: Thread[Thread37,5,main] 78.64 from 37 to 3 Total Balance: Thread[Thread34,5,main] 197.11 from 34 to 69 Total Balance: Thread[Thread36,5,main] 85.96 from 36 to 4 Total Balance: . . . 
  Thread[Thread-4,5,main]Thread[Thread33,5,main] 7.31 from 31 to 32 Total Balance: 99979.24 627.50 from 4 to 5 Total Balance: 99979.24 . . . 
  100000.00   99291.06 99291.06 99291.06 99291.06 99291.06   As you can see, something is very wrong. For a few transactions, the bank balance remains at $100,000, which is the correct total for 100 accounts of $1,000 each. But after some time, the balance changes slightly. When you run this program, errors may happen quickly, or it may take a very long time for the balance to become corrupted. This situation does not inspire confidence, and you would probably not want to deposit your hard-earned money in such a bank. 
  See if you can spot the problems with the code in Listing 12.3 and the Bank class in Listing 12.2. We will unravel the mystery in the next section. 
12.4.2 The Race Condition Explained
  In the previous section, we ran a program in which several threads updated bank account balances. After a while, errors crept in and some amount of money was either lost or spontaneously created. This problem occurs when two threads are simultaneously trying to update an account. Suppose two threads simultaneously carry out the instruction accounts[to] += amount; 
  The problem is that these are not atomic operations. The instruction might be processed as follows: 1. Load accounts[to] into a register. 
  2. Add amount. 
  3. Move the result back to accounts[to]. 
  Now, suppose the first thread executes Steps 1 and 2, and then it is preempted. Suppose the second thread awakens and updates the same entry in the account array. Then, the first thread awakens and completes its Step 3. 
  That action wipes out the modification of the other thread. As a result, the total is no longer correct (see Figure 12.2). 
  Figure 12.2 Simultaneous access by two threads Our test program detects this corruption. (Of course, there is a slight chance of false alarms if the thread is interrupted as it is performing the tests!)   Note You can actually peek at the virtual machine bytecodes that execute   each statement in our class. Run the command javap -c -v Bank   to decompile the Bank.class file. For example, the line accounts[to] += amount; 
  is translated into the following bytecodes: aload_0 getfield iload_2 dup2 daload dload_3 dadd dastore   #2; //Field accounts:[D   What these codes mean does not matter. The point is that the increment command is made up of several instructions, and the thread executing them can be interrupted at any instruction. 
  What is the chance of this corruption occurring? On a modern processor with multiple cores, the risk of corruption is quite high. We boosted the chance of observing the problem on a single-core processor by interleaving the print statements with the statements that update the balance. 
  If you omit the print statements, the risk of corruption is lower because each thread does so little work before going to sleep again, and it is unlikely that the scheduler will preempt it in the middle of the computation. However, the risk of corruption does not go away completely. If you run lots of threads on a heavily loaded machine, the program will still fail even after you have eliminated the print statements. The failure may take a few minutes or hours or days to occur. Frankly, there are few things worse in the life of a programmer than an error that only manifests itself irregularly. 
  The real problem is that the work of the transfer method can be interrupted in the middle. If we could ensure that the method runs to completion before the thread loses control, the state of the bank account object would never be corrupted. 
12.4.3 Lock Objects
  There are two mechanisms for protecting a code block from concurrent access. The Java language provides a synchronized keyword for this purpose, and Java 5 introduced the ReentrantLock class. The synchronized keyword automatically provides a lock as well as an associated "condition," which makes it powerful and convenient for most cases that require explicit locking. However, we believe that it is easier to understand the synchronized keyword after you have seen locks and conditions in isolation. The java.util.concurrent framework provides separate classes for these fundamental mechanisms, which we explain here and in Section 12.4.4, "Condition Objects," on p. 758. Once you have understood these building blocks, we present the synchronized keyword in Section 12.4.5, "The synchronized Keyword," on p. 764. 
  The basic outline for protecting a code block with a ReentrantLock is: myLock.lock(); // a ReentrantLock object try { critical section } 
  finally { myLock.unlock(); // make sure the lock is unlocked even if an exception is } 
  This construct guarantees that only one thread at a time can enter the critical section. As soon as one thread locks the lock object, no other thread can get past the lock statement. When other threads call lock, they are deactivated until the first thread unlocks the lock object. 
  Caution It is critically important that the unlock operation is enclosed in a finally clause. If the code in the critical section throws an exception, the lock must be unlocked. Otherwise, the other threads will be blocked forever. 
  Note When you use locks, you cannot use the try-with-resources statement. First off, the unlock method isn’t called close. But even if it was renamed, the try-with-resources statement wouldn’t work. 
  Its header expects the declaration of a new variable. But when you use a lock, you want to keep using the same variable that is shared among threads. 
  Let us use a lock to protect the transfer method of the Bank class. 
  public class Bank { private var bankLock = new ReentrantLock(); 
  . . . 
  public void transfer(int from, int to, int amount) { bankLock.lock(); 
  try { System.out.print(Thread.currentThread()); 
  accounts[from] -= amount; 
  System.out.printf(" %10.2f from %d to %d", amount, from, to); 
  accounts[to] += amount; 
  System.out.printf(" Total Balance: %10.2f%n", getTotalBalance()); 
  } 
  finally { bankLock.unlock(); 
  } 
  } 
  } 
  Suppose one thread calls transfer and gets preempted before it is done. 
  Suppose a second thread also calls transfer. The second thread cannot acquire the lock and is blocked in the call to the lock method. It is deactivated and must wait for the first thread to finish executing the transfer method. When the first thread unlocks the lock, then the second thread can proceed (see Figure 12.3). 
  Figure 12.3 Comparison of unsynchronized and synchronized threads Try it out. Add the locking code to the transfer method and run the program again. You can run it forever, and the bank balance will not become corrupted. 
  Note that each Bank object has its own ReentrantLock object. If two threads try to access the same Bank object, then the lock serves to serialize the access. However, if two threads access different Bank objects, each thread acquires a different lock and neither thread is blocked. This is as it should be, because the threads cannot interfere with one another when they manipulate different Bank instances. 
  The lock is called reentrant because a thread can repeatedly acquire a lock that it already owns. The lock has a hold count that keeps track of the nested calls to the lock method. The thread has to call unlock for every call to lock in order to relinquish the lock. Because of this feature, code protected by a lock can call another method that uses the same locks. 
  For example, the transfer method calls the getTotalBalance method, which also locks the bankLock object, which now has a hold count of 2. When the getTotalBalance method exits, the hold count is back to 1. When the transfer method exits, the hold count is 0, and the thread relinquishes the lock. 
  In general, you will want to protect blocks of code that update or inspect a shared object, so you can be assured that these operations run to completion before another thread can use the same object. 
  Caution Be careful to ensure that the code in a critical section is not bypassed by throwing an exception. If an exception is thrown before the end of the section, the finally clause will relinquish the lock, but the object may be in a damaged state. 
  java.util.concurrent.locks.Lock 5 void lock() acquires this lock; blocks if the lock is currently owned by another thread. 
  void unlock() releases this lock. 
  java.util.concurrent.locks.ReentrantLock 5   ReentrantLock() constructs a reentrant lock that can be used to protect a critical section. 
  ReentrantLock(boolean fair) constructs a lock with the given fairness policy. A fair lock favors the thread that has been waiting for the longest time. However, this fairness guarantee can be a significant drag on performance. Therefore, by default, locks are not required to be fair. 
  Caution It sounds nice to be fair, but fair locks are a lot slower than regular locks. You should only enable fair locking if you truly know what you are doing and have a specific reason to consider fairness essential for your program. Even if you use a fair lock, you have no guarantee that the thread scheduler is fair. If the thread scheduler chooses to neglect a thread that has been waiting a long time for the lock, it doesn’t get the chance to be treated fairly by the lock. 
12.4.4 Condition Objects
  Often, a thread enters a critical section only to discover that it can’t proceed until a condition is fulfilled. Use a condition object to manage threads that have acquired a lock but cannot do useful work. In this section, we introduce the implementation of condition objects in the Java library. (For historical reasons, condition objects are often called condition variables.) Let us refine our simulation of the bank. We do not want to transfer money out of an account that does not have the funds to cover the transfer. Note that we cannot use code like if (bank.getBalance(from) >= amount) bank.transfer(from, to, amount); 
  It is entirely possible that the current thread will be deactivated between the   successful outcome of the test and the call to transfer. 
  if (bank.getBalance(from) >= amount) // thread might be deactivated at this point bank.transfer(from, to, amount); 
  By the time the thread is running again, the account balance may have fallen below the withdrawal amount. You must make sure that no other thread can modify the balance between the test and the transfer action. You do so by protecting both the test and the transfer action with a lock: public void transfer(int from, int to, int amount) { bankLock.lock(); 
  try { while (accounts[from] < amount) { // wait . . . 
  } 
  // transfer funds . . . 
  } 
  finally { bankLock.unlock(); 
  } 
  } 
  Now, what do we do when there is not enough money in the account? We wait until some other thread has added funds. But this thread has just gained exclusive access to the bankLock, so no other thread has a chance to make a deposit. This is where condition objects come in. 
  A lock object can have one or more associated condition objects. You obtain a condition object with the newCondition method. It is customary to give each condition object a name that evokes the condition that it represents. For example, here we set up a condition object to represent the "sufficient funds" 
  condition. 
  class Bank   { private Condition sufficientFunds; 
  . . . 
  public Bank() { . . . 
  sufficientFunds = bankLock.newCondition(); 
  } 
  } 
  If the transfer method finds that sufficient funds are not available, it calls sufficientFunds.await(); 
  The current thread is now deactivated and gives up the lock. This lets in another thread that can, we hope, increase the account balance. 
  There is an essential difference between a thread that is waiting to acquire a lock and a thread that has called await. Once a thread calls the await method, it enters a wait set for that condition. The thread is not made runnable when the lock is available. Instead, it stays deactivated until another thread has called the signalAll method on the same condition. 
  When another thread has transferred money, it should call sufficientFunds.signalAll(); 
  This call reactivates all threads waiting for the condition. When the threads are removed from the wait set, they are again runnable and the scheduler will eventually activate them again. At that time, they will attempt to reenter the object. As soon as the lock is available, one of them will acquire the lock and continue where it left off, returning from the call to await. 
  At this time, the thread should test the condition again. There is no guarantee that the condition is now fulfilled—the signalAll method merely signals to the waiting threads that it may be fulfilled at this time and that it is worth checking for the condition again. 
  Note In general, a call to await should be inside a loop of the form while (!(OK to proceed))   condition.await(); 
  It is crucially important that some other thread calls the signalAll method eventually. When a thread calls await, it has no way of reactivating itself. It puts its faith in the other threads. If none of them bother to reactivate the waiting thread, it will never run again. This can lead to unpleasant deadlock situations. If all other threads are blocked and the last active thread calls await without unblocking one of the others, it also blocks. No thread is left to unblock the others, and the program hangs. 
  When should you call signalAll? The rule of thumb is to call signalAll whenever the state of an object changes in a way that might be advantageous to waiting threads. For example, whenever an account balance changes, the waiting threads should be given another chance to inspect the balance. In our example, we call signalAll when we have finished the funds transfer. 
  public void transfer(int from, int to, int amount) { bankLock.lock(); 
  try { while (accounts[from] < amount) sufficientFunds.await(); 
  // transfer funds . . . 
  sufficientFunds.signalAll(); 
  } 
  finally { bankLock.unlock(); 
  } 
  } 
  Note that the call to signalAll does not immediately activate a waiting thread. It only unblocks the waiting threads so that they can compete for entry into the object after the current thread has relinquished the lock. 
  Another method, signal, unblocks only a single thread from the wait set, chosen at random. That is more efficient than unblocking all threads, but there is a danger. If the randomly chosen thread finds that it still cannot   proceed, it becomes blocked again. If no other thread calls signal again, the system deadlocks. 
  Caution A thread can only call await, signalAll, or signal on a condition if it owns the lock of the condition. 
  If you run the sample program in Listing 12.4, you will notice that nothing ever goes wrong. The total balance stays at $100,000 forever. No account ever has a negative balance. (Again, press Ctrl+C to terminate the program.) You may also notice that the program runs a bit slower—that is the price you pay for the added bookkeeping involved in the synchronization mechanism. 
  In practice, using conditions correctly can be quite challenging. Before you start implementing your own condition objects, you should consider using one of the constructs described in Section 12.5, "Thread-Safe Collections," 
  on p. 781. 
  java.util.concurrent.locks.Lock 5 Condition newCondition() returns a condition object associated with this lock. 
  java.util.concurrent.locks.Condition 5 void await() puts this thread on the wait set for this condition. 
  void signalAll() unblocks all threads in the wait set for this condition. 
  void signal() unblocks one randomly selected thread in the wait set for this condition. 
12.4.5 The synchronized Keyword
  In the preceding sections, you saw how to use Lock and Condition objects. Before going any further, let us summarize the key points about locks and conditions: A lock protects sections of code, allowing only one thread to execute the   code at a time. 
  A lock manages threads that are trying to enter a protected code segment. 
  A lock can have one or more associated condition objects. 
  Each condition object manages threads that have entered a protected code section but that cannot proceed. 
  The Lock and Condition interfaces give programmers a high degree of control over locking. However, in most situations, you don’t need that control —you can use a mechanism that is built into the Java language. Ever since version 1.0, every object in Java has an intrinsic lock. If a method is declared with the synchronized keyword, the object’s lock protects the entire method. That is, to call the method, a thread must acquire the intrinsic object lock. 
  In other words, public synchronized void method() { method body } 
  is the equivalent of public void method() { this.intrinsicLock.lock(); 
  try { method body } 
  finally { this.intrinsicLock.unlock(); } 
  } 
  For example, instead of using an explicit lock, we can simply declare the transfer method of the Bank class as synchronized. 
  The intrinsic object lock has a single associated condition. The wait method adds a thread to the wait set, and the notifyAll/notify methods unblock waiting threads. In other words, calling wait or notifyAll is the   equivalent of intrinsicCondition.await(); 
  intrinsicCondition.signalAll(); 
  Note The wait, notifyAll, and notify methods are final methods of the Object class. The Condition methods had to be named await, signalAll, and signal so that they don’t conflict with those methods. 
  For example, you can implement the Bank class in Java like this: class Bank { private double[] accounts; 
  public synchronized void transfer(int from, int to, int amount) throws InterruptedException { while (accounts[from] < amount) wait(); // wait on intrinsic object lock's single condition accounts[from] -= amount; 
  accounts[to] += amount; 
  notifyAll(); // notify all threads waiting on the condition } 
  public synchronized double getTotalBalance() { . . . } 
  } 
  As you can see, using the synchronized keyword yields code that is much more concise. Of course, to understand this code, you have to know that each object has an intrinsic lock, and that the lock has an intrinsic condition. The lock manages the threads that try to enter a synchronized method. The condition manages the threads that have called wait. 
  Tip   Synchronized methods are relatively straightforward. However, beginners often struggle with conditions. Before you use wait/notifyAll, you should consider using one of the constructs described in Section 12.5, "Thread-Safe Collections," on p. 781. 
  It is also legal to declare static methods as synchronized. If such a method is called, it acquires the intrinsic lock of the associated class object. For example, if the Bank class has a static synchronized method, then the lock of the Bank.class object is locked when it is called. As a result, no other thread can call this or any other synchronized static method of the same class. 
  The intrinsic locks and conditions have some limitations. Among them: You cannot interrupt a thread that is trying to acquire a lock. 
  You cannot specify a timeout when trying to acquire a lock. 
  Having a single condition per lock can be inefficient. 
  What should you use in your code—Lock and Condition objects or synchronized methods? Here is our recommendation: It is best to use neither Lock/Condition nor the synchronized keyword. In many situations, you can use one of the mechanisms of the java.util.concurrent package that do all the locking for you. 
  For example, in Section 12.5.1, "Blocking Queues," on p. 781, you will see how to use a blocking queue to synchronize threads that work on a common task. You should also explore parallel streams—see Chapter 1 of Volume II. 
  If the synchronized keyword works for your situation, by all means, use it. You’ll write less code and have less room for error. Listing 12.5 shows the bank example, implemented with synchronized methods. 
  Use Lock/Condition if you really need the additional power that these constructs give you. 
  Listing 12.5 synch2/Bank.java 1
  2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50   package synch2; 
  import java.util.*; 
  /** * A bank with a number of bank accounts that uses synchronization primitiv */ public class Bank { private final double[] accounts; 
  /** * Constructs the bank. 
  * @param n the number of accounts * @param initialBalance the initial balance for each account */ public Bank(int n, double initialBalance) { accounts = new double[n]; 
  Arrays.fill(accounts, initialBalance); 
  } 
  /** * Transfers money from one account to another. 
  * @param from the account to transfer from * @param to the account to transfer to * @param amount the amount to transfer */ public synchronized void transfer(int from, int to, double amount) throws InterruptedException { while (accounts[from] < amount) wait(); 
  System.out.print(Thread.currentThread()); 
  accounts[from] -= amount; 
  System.out.printf(" %10.2f from %d to %d", amount, from, to); 
  accounts[to] += amount; 
  System.out.printf(" Total Balance: %10.2f%n", getTotalBalance()); 
  notifyAll(); 
  } 
  /** * Gets the sum of all account balances. 
  * @return the total balance */ public synchronized double getTotalBalance() { double sum = 0; 
  for (double a : accounts)   51 52 53 54 55 56 57 58 59 60 61 62 63 64   sum += a; 
  return sum; 
  } 
  /** * Gets the number of accounts in the bank. 
  * @return the number of accounts */ public int size() { return accounts.length; 
  } 
  } 
  java.lang.Object 1.0 void notifyAll() unblocks the threads that called wait on this object. This method can only be called from within a synchronized method or block. The method throws an IllegalMonitorStateException if the current thread is not the owner of the object’s lock. 
  void notify() unblocks one randomly selected thread among the threads that called wait on this object. This method can only be called from within a synchronized method or block. The method throws an IllegalMonitorStateException if the current thread is not the owner of the object’s lock. 
  void wait() causes a thread to wait until it is notified. This method can only be called from within a synchronized method or block. It throws an IllegalMonitorStateException if the current thread is not the owner of the object’s lock. 
  void wait(long millis) void wait(long millis, int nanos) causes a thread to wait until it is notified or until the specified amount   of time has passed. These methods can only be called from within a synchronized method or block. They throw an IllegalMonitorStateException if the current thread is not the owner of the object’s lock. The number of nanoseconds may not exceed 1,000,000. 
  12.4.6 Synchronized Blocks As we just discussed, every Java object has a lock. A thread can acquire the lock by calling a synchronized method. There is a second mechanism for acquiring the lock: by entering a synchronized block. When a thread enters a block of the form synchronized (obj) // this is the syntax for a synchronized block { critical section } 
  then it acquires the lock for obj. 
  You will sometimes find "ad hoc" locks, such as public class Bank { private double[] accounts; 
  private var lock = new Object(); 
  . . . 
  public void transfer(int from, int to, int amount) { synchronized (lock) // an ad-hoc lock { accounts[from] -= amount; 
  accounts[to] += amount; 
  } 
  System.out.println(. . .); 
  } 
  } 
  Here, the lock object is created only to use the lock that every Java object possesses. 
  Sometimes, programmers use the lock of an object to implement additional   atomic operations—a practice known as client-side locking. Consider, for example, the Vector class, which is a list whose methods are synchronized. 
  Now suppose we stored our bank balances in a Vector<Double>. Here is a naive implementation of a transfer method:   public void transfer(Vector<Double> accounts, int from, int to, int amount) // { accounts.set(from, accounts.get(from) - amount); 
  accounts.set(to, accounts.get(to) + amount); 
  System.out.println(. . .); 
  } 
  The get and set methods of the Vector class are synchronized, but that doesn’t help us. It is entirely possible for a thread to be preempted in the transfer method after the first call to get has been completed. Another thread may then store a different value into the same position. However, we can hijack the lock: public void transfer(Vector<Double> accounts, int from, int to, int amount) { synchronized (accounts) { accounts.set(from, accounts.get(from) - amount); 
  accounts.set(to, accounts.get(to) + amount); 
  } 
  System.out.println(. . .); 
  } 
  This approach works, but it is entirely dependent on the fact that the Vector class uses the intrinsic lock for all of its mutator methods. However, is this really a fact? The documentation of the Vector class makes no such promise. You have to carefully study the source code and hope that future versions do not introduce unsynchronized mutators. As you can see, clientside locking is very fragile and not generally recommended. 
  Note The Java virtual machine has built-in support for synchronized methods. However, synchronized blocks are compiled into a lengthy   sequence of bytecodes to manage the intrinsic lock. 
12.4.7 The Monitor Concept
  Locks and conditions are powerful tools for thread synchronization, but they are not very object-oriented. For many years, researchers have looked for ways to make multithreading safe without forcing programmers to think about explicit locks. One of the most successful solutions is the monitor concept that was pioneered by Per Brinch Hansen and Tony Hoare in the 1970s. In the terminology of Java, a monitor has these properties: A monitor is a class with only private fields. 
  Each object of that class has an associated lock. 
  All methods are locked by that lock. In other words, if a client calls obj.method(), then the lock for obj is automatically acquired at the beginning of the method call and relinquished when the method returns. 
  Since all fields are private, this arrangement ensures that no thread can access the fields while another thread manipulates them. 
  The lock can have any number of associated conditions. 
  Earlier versions of monitors had a single condition, with a rather elegant syntax. You can simply call await accounts[from] >= amount without using an explicit condition variable. However, research showed that indiscriminate retesting of conditions can be inefficient. This problem is solved with explicit condition variables, each managing a separate set of threads. 
  The Java designers loosely adapted the monitor concept. Every object in Java has an intrinsic lock and an intrinsic condition. If a method is declared with the synchronized keyword, it acts like a monitor method. The condition variable is accessed by calling wait/notifyAll/notify. 
  However, a Java object differs from a monitor in three important ways, compromising thread safety: Fields are not required to be private. 
  Methods are not required to be synchronized. 
  The intrinsic lock is available to clients. 
  This disrespect for security enraged Per Brinch Hansen. In a scathing review of the multithreading primitives in Java, he wrote: "It is astounding to me that Java’s insecure parallelism is taken seriously by the programming community, a quarter of a century after the invention of monitors and Concurrent Pascal. It has no merit" [Java’s Insecure Parallelism, ACM SIGPLAN Notices 34:38–45, April 1999]. 
12.4.8 Volatile Fields
  Sometimes, it seems excessive to pay the cost of synchronization just to read or write an instance field or two. After all, what can go wrong? 
  Unfortunately, with modern processors and compilers, there is plenty of room for error. 
  Computers with multiple processors can temporarily hold memory values in registers or local memory caches. As a consequence, threads running in different processors may see different values for the same memory location! 
  Compilers can reorder instructions for maximum throughput. Compilers won’t choose an ordering that changes the meaning of the code, but they make the assumption that memory values are only changed when there are explicit instructions in the code. However, a memory value can be changed by another thread! 
  If you use locks to protect code that can be accessed by multiple threads, you won’t have these problems. Compilers are required to respect locks by flushing local caches as necessary and not inappropriately reordering instructions. The details are explained in the Java Memory Model and Thread Specification developed by JSR 133 (see www.jcp.org/en/jsr/detail?id=133). Much of the specification is highly complex and technical, but the document also contains a number of clearly explained examples. A more accessible overview article by Brian Goetz is available at www.ibm.com/developerworks/library/jjtp02244. 
  Note Brian Goetz coined the following "synchronization motto": "If you write a variable which may next be read by another thread, or you read a variable which may have last been written by another thread, you must use synchronization." 
  The volatile keyword offers a lock-free mechanism for synchronizing access to an instance field. If you declare a field as volatile, then the compiler and the virtual machine take into account that the field may be concurrently updated by another thread. 
  For example, suppose an object has a boolean flag done that is set by one thread and queried by another thread. As we already discussed, you can use a lock: private boolean done; 
  public synchronized boolean isDone() { return done; } 
  public synchronized void setDone() { done = true; } 
  Perhaps it is not a good idea to use the intrinsic object lock. The isDone and setDone methods can block if another thread has locked the object. If that is a concern, one can use a separate lock just for this variable. But this is getting to be a lot of trouble. 
  In this case, it is reasonable to declare the field as volatile: private volatile boolean done; 
  public boolean isDone() { return done; } 
  public void setDone() { done = true; } 
  The compiler will insert the appropriate code to ensure that a change to the done variable in one thread is visible from any other thread that reads the variable. 
  Caution   Volatile variables do not provide any atomicity. For example, the method public void flipDone() { done = !done; } // not atomic   is not guaranteed to flip the value of the field. There is no guarantee that the reading, flipping, and writing is uninterrupted. 
12.4.9 Final Variables
  As you saw in the preceding section, you cannot safely read a field from multiple threads unless you use locks or the volatile modifier. 
  There is one other situation in which it is safe to access a shared field—when it is declared final. Consider final var accounts = new HashMap<String, Double>(); 
  Other threads get to see the accounts variable after the constructor has finished. 
  Without using final, there would be no guarantee that other threads would see the updated value of accounts—they might all see null, not the constructed HashMap. 
  Of course, the operations on the map are not thread-safe. If multiple threads mutate and read the map, you still need synchronization. 
12.4.10 Atomics
  You can declare shared variables as volatile provided you perform no operations other than assignment. 
  There are a number of classes in the java.util.concurrent.atomic package that use efficient machine-level instructions to guarantee atomicity of other operations without using locks. For example, the AtomicInteger class has methods incrementAndGet and decrementAndGet that atomically increment or decrement an integer. For example, you can safely   generate a sequence of numbers like this: public static AtomicLong nextNumber = new AtomicLong(); 
  // in some thread. . . 
  long id = nextNumber.incrementAndGet(); 
  The incrementAndGet method atomically increments the AtomicLong and returns the post-increment value. That is, the operations of getting the value, adding 1, setting it, and producing the new value cannot be interrupted. 
  It is guaranteed that the correct value is computed and returned, even if multiple threads access the same instance concurrently. 
  There are methods for atomically setting, adding, and subtracting values, but if you want to make a more complex update, you have to use the compareAndSet method. For example, suppose you want to keep track of the largest value that is observed by different threads. The following won’t work: public static AtomicLong largest = new AtomicLong(); 
  // in some thread. . . 
  largest.set(Math.max(largest.get(), observed)); // ERROR-race condition! 
  This update is not atomic. Instead, provide a lambda expression for updating the variable, and the update is done for you. In our example, we can call largest.updateAndGet(x -> Math.max(x, observed)); 
  or largest.accumulateAndGet(observed, Math::max); 
  The accumulateAndGet method takes a binary operator that is used to combine the atomic value and the supplied argument. 
  There are also methods getAndUpdate and getAndAccumulate that return the old value. 
  Note These methods are also provided for the classes AtomicInteger, AtomicIntegerArray, AtomicIntegerFieldUpdater, AtomicLongArray, AtomicLongFieldUpdater, AtomicReference, AtomicReferenceArray, and AtomicReferenceFieldUpdater. 
  When you have a very large number of threads accessing the same atomic values, performance suffers because the optimistic updates require too many retries. The LongAdder and LongAccumulator classes solve this problem. A LongAdder is composed of multiple variables whose collective sum is the current value. Multiple threads can update different summands, and new summands are automatically provided when the number of threads increases. This is efficient in the common situation where the value of the sum is not needed until after all work has been done. The performance improvement can be substantial. 
  If you anticipate high contention, you should simply use a LongAdder instead of an AtomicLong. The method names are slightly different. Call increment to increment a counter or add to add a quantity, and sum to retrieve the total. 
  var adder = new LongAdder(); 
  for (. . .) pool.submit(() -> { while (. . .) { . . . 
  if (. . .) adder.increment(); 
  } 
  }); 
  . . . 
  long total = adder.sum(); 
  Note Of course, the increment method does not return the old value. 
  Doing that would undo the efficiency gain of splitting the sum into multiple summands. 
  The LongAccumulator generalizes this idea to an arbitrary accumulation operation. In the constructor, you provide the operation, as well as its neutral element. To incorporate new values, call accumulate. Call get to obtain the current value. The following has the same effect as a LongAdder: var adder = new LongAccumulator(Long::sum, 0); 
  // in some thread. . . 
  adder.accumulate(value); 
  Internally, the accumulator has variables a1, a2, . . ., an. Each variable is initialized with the neutral element (0 in our example). 
  When accumulate is called with value v, then one of them is atomically updated as ai = ai op v, where op is the accumulation operation written in infix form. In our example, a call to accumulate computes ai = ai + v for some i. 
  The result of get is a1 op a2 op . . . op an. In our example, that is the sum of the accumulators, a1 + a2 + . . . + an. 
  If you choose a different operation, you can compute maximum or minimum. 
  In general, the operation must be associative and commutative. That means that the final result must be independent of the order in which the intermediate values were combined. 
  There are also DoubleAdder and DoubleAccumulator that work in the same way, except with double values. 
12.4.11 Deadlocks
  Locks and conditions cannot solve all problems that might arise in multithreading. Consider the following situation: 1. Account 1: $200 2. Account 2: $300   3. Thread 1: Transfer $300 from Account 1 to Account 2 4. Thread 2: Transfer $400 from Account 2 to Account 1 As Figure 12.4 indicates, Threads 1 and 2 are clearly blocked. Neither can proceed because the balances in Accounts 1 and 2 are insufficient. 
  Figure 12.4 A deadlock situation It is possible that all threads get blocked because each is waiting for more money. Such a situation is called a deadlock. 
  In our program, a deadlock cannot occur for a simple reason. Each transfer amount is for, at most, $1,000. Since there are 100 accounts and a total of $100,000 in them, at least one of the accounts must have at least $1,000 at any time. The thread moving money out of that account can therefore proceed. 
  But if you change the run method of the threads to remove the $1,000 transaction limit, deadlocks can occur quickly. Try it out. Set NACCOUNTS to 10. Construct each transfer runnable with a max value of 2 * INITIAL_BALANCE and run the program. The program will run for a while and then hang. 
  Tip When the program hangs, press Ctrl+\. You will get a thread dump that lists all threads. Each thread has a stack trace, telling you where it is currently blocked. Alternatively, run jconsole, as described in Chapter 7, and consult the Threads panel (see Figure 12.5). 
  Figure 12.5 The Threads panel in jconsole   Another way to create a deadlock is to make the ith thread responsible for putting money into the ith account, rather than for taking it out of the ith account. In this case, there is a chance that all threads will gang up on one account, each trying to remove more money from it than it contains. Try it out. In the SynchBankTest program, turn to the run method of the TransferRunnable class. In the call to transfer, flip fromAccount and toAccount. Run the program and see how it deadlocks almost immediately. 
  Here is another situation in which a deadlock can occur easily. Change the signalAll method to signal in the SynchBankTest program. You will find that the program eventually hangs. (Again, set NACCOUNTS to 10 to observe the effect more quickly.) Unlike signalAll, which notifies all   threads that are waiting for added funds, the signal method unblocks only one thread. If that thread can’t proceed, all threads can be blocked. Consider the following sample scenario of a developing deadlock: 1. Account 1: $1,990 2. All other accounts: $990 each 3. Thread 1: Transfer $995 from Account 1 to Account 2 4. All other threads: Transfer $995 from their account to another account Clearly, all threads but Thread 1 are blocked, because there isn’t enough money in their accounts. 
  Thread 1 proceeds. Afterward, we have the following situation: 1. Account 1: $995 2. Account 2: $1,985 3. All other accounts: $990 each Then, Thread 1 calls signal. The signal method picks a thread at random to unblock. Suppose it picks Thread 3. That thread is awakened, finds that there isn’t enough money in its account, and calls await again. But Thread 1 is still running. A new random transaction is generated, say, 1. Thread 1: Transfer $997 from Account 1 to Account 2 Now, Thread 1 also calls await, and all threads are blocked. The system has deadlocked. 
  The culprit here is the call to signal. It only unblocks one thread, and it may not pick the thread that is essential to make progress. (In our scenario, Thread 2 must proceed to take money out of Account 2.) Unfortunately, there is nothing in the Java programming language to avoid or break these deadlocks. You must design your program to ensure that a deadlock situation cannot occur. 
12.4.12 Thread-Local Variables
  In the preceding sections, we discussed the risks of sharing variables between threads. Sometimes, you can avoid sharing by giving each thread its own instance, using the ThreadLocal helper class. For example, the SimpleDateFormat class is not thread-safe. Suppose we have a static variable public static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); 
  If two threads execute an operation such as String dateStamp = dateFormat.format(new Date()); 
  then the result can be garbage since the internal data structures used by the dateFormat can be corrupted by concurrent access. You could use synchronization, which is expensive, or you could construct a local SimpleDateFormat object whenever you need it, but that is also wasteful. 
  To construct one instance per thread, use the following code: public static final ThreadLocal<SimpleDateFormat> dateFormat = ThreadLocal.withInitial(() -> new SimpleDateFormat("yyyy-MMdd")); 
  To access the actual formatter, call String dateStamp = dateFormat.get().format(new Date()); 
  The first time you call get in a given thread, the lambda in the constructor is called. From then on, the get method returns the instance belonging to the current thread. 
  A similar problem is the generation of random numbers in multiple threads. 
  The java.util.Random class is thread-safe. But it is still inefficient if multiple threads need to wait for a single shared generator. 
  You could use the ThreadLocal helper to give each thread a separate generator, but Java 7 provides a convenience class for you. Simply make a call such as int random = ThreadLocalRandom.current().nextInt(upperBound); 
  The call ThreadLocalRandom.current() returns an instance of the Random class that is unique to the current thread. 
  java.lang.ThreadLocal<T> 1.2 T get() gets the current value of this thread. If get is called for the first time, the value is obtained by calling initialize. 
  void set(T t) sets a new value for this thread. 
  void remove() removes the value for this thread. 
  static <S> ThreadLocal<S> withInitial(Supplier<? 
  extends S> supplier) 8 creates a thread local variable whose initial value is produced by invoking the given supplier. 
  java.util.concurrent.ThreadLocalRandom 7 static ThreadLocalRandom current() returns an instance of the Random class that is unique to the current thread. 
12.4.13 Why the stop and suspend Methods Are Deprecated
     The initial release of Java defined a stop method that simply terminates a thread, and a suspend method that blocks a thread until another thread calls resume. The stop and suspend methods have something in common: Both attempt to control the behavior of a given thread without the thread’s cooperation. 
  The stop, suspend, and resume methods have been deprecated. The stop method is inherently unsafe, and experience has shown that the suspend method frequently leads to deadlocks. In this section, you will see why these methods are problematic and what you can do to avoid problems. 
  Let us turn to the stop method first. This method terminates all pending methods, including the run method. When a thread is stopped, it immediately gives up the locks on all objects that it has locked. This can leave objects in an inconsistent state. For example, suppose a TransferRunnable is stopped in the middle of moving money from one account to another, after the withdrawal and before the deposit. Now the bank object is damaged. Since the lock has been relinquished, the damage is observable from the other threads that have not been stopped. 
  When a thread wants to stop another thread, it has no way of knowing when the stop method is safe and when it leads to damaged objects. Therefore, the method has been deprecated. You should interrupt a thread when you want it to stop. The interrupted thread can then stop when it is safe to do so. 
  Note Some authors claim that the stop method has been deprecated because it can cause objects to be permanently locked by a stopped thread. However, that claim is not valid. A stopped thread exits all synchronized methods it has called—technically, by throwing a ThreadDeath exception. As a consequence, the thread relinquishes the intrinsic object locks that it holds. 
  Next, let us see what is wrong with the suspend method. Unlike stop, suspend won’t damage objects. However, if you suspend a thread that   owns a lock, then the lock is unavailable until the thread is resumed. If the thread that calls the suspend method tries to acquire the same lock, the program deadlocks: The suspended thread waits to be resumed, and the suspending thread waits for the lock. 
  This situation occurs frequently in graphical user interfaces. Suppose we have a graphical simulation of our bank. A button labeled Pause suspends the transfer threads, and a button labeled Resume resumes them. 
  pauseButton.addActionListener(event -> { for (int i = 0; i < threads.length; i++) threads[i].suspend(); // don't do this }); 
  resumeButton.addActionListener(event -> { for (int i = 0; i < threads.length; i++) threads[i].resume(); 
  }); 
  Suppose a paintComponent method paints a chart of each account, calling a getBalances method to get an array of balances. 
  As you will see in Section 12.7.3, "Long-Running Tasks in User Interface Callbacks," on p. 823, both the button actions and the repainting occur in the same thread, the event dispatch thread. Consider the following scenario: 1. One of the transfer threads acquires the lock of the bank object. 
  2. The user clicks the Pause button. 
  3. All transfer threads are suspended; one of them still holds the lock on the bank object. 
  4. For some reason, the account chart needs to be repainted. 
  5. The paintComponent method calls the getBalances method. 
  6. That method tries to acquire the lock of the bank object. 
  Now the program is frozen. 
  The event dispatch thread can’t proceed because the lock is owned by one of the suspended threads. Thus, the user can’t click the Resume button, and the threads won’t ever resume. 
  If you want to safely suspend a thread, introduce a variable suspendRequested and test it in a safe place of your run method—in a place where your thread doesn’t lock objects that other threads need. When your thread finds that the suspendRequested variable has been set, it should keep waiting until it becomes available again. 
