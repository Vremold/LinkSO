  Java is a strongly typed language. This means that every variable must have a declared type. There are eight primitive types in Java. Four of them are integer types; two are floating-point number types; one is the character type char, used for code units in the Unicode encoding scheme (see Section 3.3.3, "The char Type," on p. 46); and one is a boolean type for truth values. 
  Note Java has an arbitrary-precision arithmetic package. However, "big numbers," as they are called, are Java objects and not a primitive Java type. You will see how to use them later in this chapter. 
3.3.1 Integer Types
     The integer types are for numbers without fractional parts. Negative values are allowed. Java provides the four integer types shown in Table 3.1. 
  Table 3.1 Java Integer Types Type Storage Requirement int   4 bytes   Range (Inclusive) –2,147,483,648 to 2,147,483,647 (just over 2 billion)   short 2 bytes   –32,768 to 32,767   long 8 bytes   –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807   byte 1 byte   –128 to 127   In most situations, the int type is the most practical. If you want to represent the number of inhabitants of our planet, you’ll need to resort to a long. The byte and short types are mainly intended for specialized applications, such as low-level file handling, or for large arrays when storage space is at a premium. 
  Under Java, the ranges of the integer types do not depend on the machine on which you will be running the Java code. This alleviates a major pain for the programmer who wants to move software from one platform to another, or even between operating systems on the same platform. In contrast, C and C++ programs use the most efficient integer type for each processor. As a result, a C program that runs well on a 32-bit processor may exhibit integer overflow on a 16-bit system. Since Java programs must run with the same results on all machines, the ranges for the various types are fixed. 
  Long integer numbers have a suffix L or l (for example, 4000000000L). 
  Hexadecimal numbers have a prefix 0x or 0X (for example, 0xCAFE). Octal numbers have a prefix 0 (for example, 010 is 8)—naturally, this can be confusing, so we recommend against the use of octal constants. 
  Starting with Java 7, you can write numbers in binary, with a prefix 0b or 0B. For example, 0b1001 is 9. Also starting with Java 7, you can add underscores to number literals, such as 1_000_000 (or   0b1111_0100_0010_0100_0000) to denote one million. The underscores are for human eyes only. The Java compiler simply removes them. 
  Note that Java does not have any unsigned versions of the int, long, short,or byte types. 
  Note If you work with integer values that can never be negative and you really need an additional bit, you can, with some care, interpret signed integer values as unsigned. For example, instead of having a byte value b represent the range from –128 to 127, you may want a range from 0 to 255. You can store it in a byte. Due to the nature of binary arithmetic, addition, subtraction, and multiplication will work provided they don’t overflow. For other operations, call Byte.toUnsignedInt(b) to get an int value between 0 and 255, then process the integer value and cast back to byte. The Integer and Long classes have methods for unsigned division and remainder. 
3.3.2 Floating-Point Types
  The floating-point types denote numbers with fractional parts. The two   floating-point types are shown in Table 3.2. 
  Table 3.2 Floating-Point Types Type   Storage Range Requirement   float 4 bytes   Approximately ±3.40282347E+38F (6–7 significant decimal digits)   double 8 bytes   Approximately ±1.79769313486231570E+308 (15 significant decimal digits)   The name double refers to the fact that these numbers have twice the precision of the float type. (Some people call these double-precision numbers.) The limited precision of float (6–7 significant digits) is simply not sufficient for many situations. Use float values only when you work with a library that requires them, or when you need to store a very large number of them. 
  Numbers of type float have a suffix F or f (for example, 3.14F). 
  Floating-point numbers without an F suffix (such as 3.14) are always considered to be of type double. You can optionally supply the D or d suffix (for example, 3.14D). 
  Note You can specify floating-point literals in hexadecimal. For example, 0.125 = 2–3 can be written as 0x1.0p-3. In hexadecimal notation, you use a p, not an e, to denote the exponent. (An e is a hexadecimal digit.) Note that the mantissa is written in hexadecimal and the exponent in decimal. The base of the exponent is 2, not 10. 
  All floating-point computations follow the IEEE 754 specification. In particular, there are three special floating-point values to denote overflows and errors: Positive infinity   Negative infinity NaN (not a number) For example, the result of dividing a positive number by 0 is positive infinity. 
  Computing 0/0 or the square root of a negative number yields NaN. 
  Note The constants Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, and Double.NaN (as well as corresponding Float constants) represent these special values, but they are rarely used in practice. In particular, you cannot test if (x == Double.NaN) // is never true   to check whether a particular result equals Double.NaN. All "not a number" values are considered distinct. However, you can use the Double.isNaN method: if (Double.isNaN(x)) // check whether x is "not a number" 
  Caution Floating-point numbers are not suitable for financial calculations in which roundoff errors cannot be tolerated. For example, the command System.out.println(2.0 - 1.1) prints 0.8999999999999999, not 0.9 as you would expect. Such roundoff errors are caused by the fact that floating-point numbers are represented in the binary number system. There is no precise binary representation of the fraction 1/10, just as there is no accurate representation of the fraction 1/3 in the decimal system. If you need precise numerical computations without roundoff errors, use the BigDecimal class, which is introduced later in this chapter. 
3.3.3 The char Type
  The char type was originally intended to describe individual characters. 
  However, this is no longer the case. Nowadays, some Unicode characters can be described with one char value, and other Unicode characters require two char values. Read the next section for the gory details. 
  Literal values of type char are enclosed in single quotes. For example, 'A' is a character constant with value 65. It is different from "A", a string containing a single character. Values of type char can be expressed as hexadecimal values that run from \u0000 to \uFFFF. For example, \u2122 is the trademark symbol (™) and \u03C0 is the Greek letter pi (π). 
  Besides the \u escape sequences, there are several escape sequences for special characters, as shown in Table 3.3. You can use these escape sequences inside quoted character literals and strings, such as '\u2122' or "Hello\n". The \u escape sequence (but none of the other escape sequences) can even be used outside quoted character constants and strings. 
  For example, Table 3.3 Escape Sequences for Special Characters Escape Sequence Name   Unicode Value   \b   Backspace   \u0008   \t   Tab   \u0009   \n   Linefeed   \u000a   \r   Carriage return \u000d   \" 
  Double quote \u0022   \'   Single quote   \u0027   \\   Backslash   \u005c   public static void main(String\u005B\u005D args)   is perfectly legal—\u005B and \u005D are the encodings for [ and ]. 
  Caution Unicode escape sequences are processed before the code is parsed. 
  For example, "\u0022+\u0022" is not a string consisting of a plus sign surrounded by quotation marks (U+0022). Instead, the \u0022 are converted into " before parsing, yielding ""+"", or an empty string. 
  Even more insidiously, you must beware of \u inside comments. 
  The comment // \u000A is a newline   yields a syntax error since \u000A is replaced with a newline when the program is read. Similarly, a comment // look inside c:\users   yields a syntax error because the \u is not followed by four hex digits. 
3.3.4 Unicode and the char Type
  To fully understand the char type, you have to know about the Unicode encoding scheme. Unicode was invented to overcome the limitations of traditional character encoding schemes. Before Unicode, there were many different standards: ASCII in the United States, ISO 8859-1 for Western European languages, KOI-8 for Russian, GB18030 and BIG-5 for Chinese, and so on. This caused two problems. First, a particular code value corresponds to different letters in the different encoding schemes. Second, the encodings for languages with large character sets have variable length: Some common characters are encoded as single bytes, others require two or more bytes. 
  Unicode was designed to solve these problems. When the unification effort started in the 1980s, a fixed 2-byte code was more than sufficient to encode all characters used in all languages in the world, with room to spare for future expansion—or so everyone thought at the time. In 1991, Unicode 1.0 was released, using slightly less than half of the available 65,536 code values. 
  Java was designed from the ground up to use 16-bit Unicode characters, which was a major advance over other programming languages that used 8bit characters. 
  Unfortunately, over time, the inevitable happened. Unicode grew beyond 65,536 characters, primarily due to the addition of a very large set of ideographs used for Chinese, Japanese, and Korean. Now, the 16-bit char type is insufficient to describe all Unicode characters. 
  We need a bit of terminology to explain how this problem is resolved in Java, beginning with Java 5. A code point is a code value that is associated with a character in an encoding scheme. In the Unicode standard, code points are written in hexadecimal and prefixed with U+, such as U+0041 for the code point of the Latin letter A. Unicode has code points that are grouped into 17 code planes. The first code plane, called the basic multilingual plane, consists of the "classic" Unicode characters with code points U+0000 to U+FFFF. Sixteen additional planes, with code points U+10000 to U+10FFFF, hold the supplementary characters. 
  The UTF-16 encoding represents all Unicode code points in a variable-length code. The characters in the basic multilingual plane are represented as 16-bit values, called code units. The supplementary characters are encoded as consecutive pairs of code units. Each of the values in such an encoding pair falls into a range of 2048 unused values of the basic multilingual plane, called the surrogates area (U+D800 to U+DBFF for the first code unit, U+DC00 to U+DFFF for the second code unit). This is rather clever, because you can immediately tell whether a code unit encodes a single character or it is the first or second part of a supplementary character. For example, (the mathematical symbol for the set of octonions, http://math.ucr.edu/home/baez/octonions) has code point U+1D546 and is encoded by the two code units U+D835 and U+DD46. (See https://tools.ietf.org/html/rfc2781 for a description of the encoding algorithm.) In Java, the char type describes a code unit in the UTF-16 encoding. 
  Our strong recommendation is not to use the char type in your programs unless you are actually manipulating UTF-16 code units. You are almost always better off treating strings (which we will discuss in Section 3.6,   "Strings," on p. 62) as abstract data types. 
3.3.5 The boolean Type
  The boolean type has two values, false and true. It is used for evaluating logical conditions. You cannot convert between integers and boolean values. 
  In C++, this test compiles and runs, always evaluating to false. In Java, the test does not compile because the integer expression x = 0 cannot be converted to a boolean value. 
