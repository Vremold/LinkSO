  The Java collections framework defines a number of interfaces for different types of collections, shown in Figure 9.4. 
  Figure 9.4 The interfaces of the collections framework There are two fundamental interfaces for collections: Collection and Map. As you already saw, you insert elements into a collection with a method boolean add(E element)   However, maps hold key/value pairs, and you use the put method to insert them: V put(K key, V value)   To read elements from a collection, visit them with an iterator. However, you can read values from a map with the get method: V get(K key)   A List is an ordered collection. Elements are added into a particular position in the container. An element can be accessed in two ways: by an iterator or by an integer index. The latter is called random access because elements can be visited in any order. In contrast, when using an iterator, one must visit them sequentially. 
  The List interface defines several methods for random access: void add(int index, E element) void remove(int index) E get(int index) E set(int index, E element)   The ListIterator interface is a subinterface of Iterator. It defines a method for adding an element before the iterator position: void add(E element)   Frankly, this aspect of the collections framework is poorly designed. In practice, there are two kinds of ordered collections, with very different performance tradeoffs. An ordered collection that is backed by an array has fast random access, and it makes sense to use the List methods with an integer index. In contrast, a linked list, while also ordered, has slow random access, and it is best traversed with an iterator. It would have been an easy matter to provide two interfaces. 
  Note To avoid carrying out random access operations for linked lists, Java 1.4 introduced a tagging interface, RandomAccess. That interface has no methods, but you can use it to test whether a particular collection supports efficient random access: if (c instanceof RandomAccess) { use random access algorithm } 
  else {   use sequential access algorithm } 
  The Set interface is identical to the Collection interface, but the behavior of the methods is more tightly defined. The add method of a set should reject duplicates. The equals method of a set should be defined so that two sets are identical if they have the same elements, but not necessarily in the same order. The hashCode method should be defined so that two sets with the same elements yield the same hash code. 
  Why make a separate interface if the method signatures are the same? 
  Conceptually, not all collections are sets. Making a Set interface enables programmers to write methods that accept only sets. 
  The SortedSet and SortedMap interfaces expose the comparator object used for sorting, and they define methods to obtain views of subsets of the collections. We discuss these in Section 9.5, "Views and Wrappers," on p. 
  532. 
  Finally, Java 6 introduced interfaces NavigableSet and NavigableMap that contain additional methods for searching and traversal in sorted sets and maps. (Ideally, these methods should have simply been included in the SortedSet and SortedMap interface.) The TreeSet and TreeMap classes implement these interfaces. 
