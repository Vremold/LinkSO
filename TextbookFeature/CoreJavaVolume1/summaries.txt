Objects and Classes	Defining Your Own Classes	  In Chapter 3, you started writing simple classes. However, all those classes had just a single main method. Now the time has come to show you how to write the kind of "workhorse classes" that are needed for more sophisticated applications. These classes typically do not have a main method. Instead, they have their own instance fields and methods. To build a complete program, you combine several classes, one of which has a main method. 
Objects and Classes	Static Fields and Methods	  In all sample programs that you have seen, the main method is tagged with the static modifier. We are now ready to discuss the meaning of this modifier. 
Objects and Classes	Objects and Classes	  In this chapter, we Introduce you to object-oriented programming; Show you how you can create objects that belong to classes from the standard Java library; and Show you how to write your own classes.
Objects and Classes	JAR Files	  When you package your application, you want to give your users a single file, not a directory structure filled with class files. Java Archive (JAR) files were designed for this purpose. A JAR file can contain both class files and other file types such as image and sound files. Moreover, JAR files are compressed, using the familiar ZIP compression format. 
Objects and Classes	Documentation Comments	  The JDK contains a very useful tool, called javadoc, that generates HTML documentation from your source files. In fact, the online API documentation   that we described in Chapter 3 is simply the result of running javadoc on the source code of the standard Java library. 
Objects and Classes	Object Construction	  You have seen how to write simple constructors that define the initial state of your objects. However, since object construction is so important, Java offers quite a variety of mechanisms for writing constructors. We go over these mechanisms in the sections that follow. 
Objects and Classes	Introduction to Object-Oriented Programming	  Object-oriented programming, or OOP for short, is the dominant programming paradigm these days, having replaced the "structured" or   procedural programming techniques that were developed in the 1970s. Since Java is object-oriented, you have to be familiar with OOP to become productive with Java. 
Objects and Classes	Method Parameters	  Let us review the computer science terms that describe how parameters can be passed to a method (or a function) in a programming language. The term call by value means that the method gets just the value that the caller provides. In contrast, call by reference means that the method gets the location of the variable that the caller provides. Thus, a method can modify the value stored in a variable passed by reference but not in one passed by value. These "call by . . ." terms are standard computer science terminology describing the behavior of method parameters in various programming languages, not just Java. (There is also a call by name that is mainly of historical interest, being employed in the Algol programming language, one of the oldest high-level languages.) The Java programming language always uses call by value. That means that the method gets a copy of all parameter values. In particular, the method cannot modify the contents of any parameter variables passed to it. 
Objects and Classes	Class Design Hints	  Without trying to be comprehensive or tedious, we want to end this chapter with some hints that will make your classes more acceptable in well-   mannered OOP circles. 
Objects and Classes	Packages	  Java allows you to group classes in a collection called a package. Packages are convenient for organizing your work and for separating your work from code libraries provided by others. In the following sections, you will learn how to use and create packages. 
Objects and Classes	Using Predefined Classes	  You can’t do anything in Java without classes, and you have already seen several classes at work. However, not all of these show off the typical features of object orientation. Take, for example, the Math class. You have seen that you can use methods of the Math class, such as Math.random, without needing to know how they are implemented—all you need to know is the name and parameters (if any). That’s the point of encapsulation, and it will certainly be true of all classes. But the Math class only encapsulates functionality; it neither needs nor hides data. Since there is no data, you do not need to worry about making objects and initializing their instance fields —there aren’t any! 
Interfaces, Lambda Expressions, and Inner Classes	Service Loaders	  Sometimes, you develop an application with a service architecture. There are platforms that encourage this approach, such as OSGi (http://osgi.org), which are used in development environments, application servers, and other complex applications. Such platforms go well beyond the scope of this book, but the JDK also offers a simple mechanism for loading services, which we describe here. This mechanism is well   supported by the Java Platform Module System—see Chapter 9 of Volume II. 
Interfaces, Lambda Expressions, and Inner Classes	Proxies	  In the final section of this chapter, we discuss proxies. You can use a proxy to create, at runtime, new classes that implement a given set of interfaces. 
Interfaces, Lambda Expressions, and Inner Classes	Interfaces, Lambda Expressions, and Inner Classes	  You have now learned about classes and inheritance, the key concepts of object-oriented programming in Java. This chapter shows you several advanced techniques that are commonly used. Despite their less obvious nature, you will need to master them to complete your Java tool chest.
Interfaces, Lambda Expressions, and Inner Classes	Interfaces	  In the following sections, you will learn what Java interfaces are and how to use them. You will also find out how interfaces have been made more powerful in recent versions of Java. 
Interfaces, Lambda Expressions, and Inner Classes	Inner Classes	  An inner class is a class that is defined inside another class. Why would you want to do that? There are two reasons: Inner classes can be hidden from other classes in the same package. 
Interfaces, Lambda Expressions, and Inner Classes	Lambda Expressions	  In the following sections, you will learn how to use lambda expressions for defining blocks of code with a concise syntax, and how to write code that consumes lambda expressions. 
Inheritance	Classes, Superclasses, and Subclasses	  Let’s return to the Employee class that we discussed in the previous chapter. Suppose (alas) you work for a company where managers are treated differently from other employees. Managers are, of course, just like employees in many respects. Both employees and managers are paid a salary. 
Inheritance	Object: The Cosmic Superclass	  The Object class is the ultimate ancestor—every class in Java extends Object. However, you never have to write public class Employee extends Object   The ultimate superclass Object is taken for granted if no superclass is explicitly mentioned. Since every class in Java extends Object, it is important to be familiar with the services provided by the Object class. We go over the basic ones in this chapter; consult the later chapters or view the online documentation for what is not covered here. (Several methods of Object come up only when dealing with concurrency—see Chapter 12.) 5.2.1 Variables of Type Object
Inheritance	Design Hints for Inheritance	  We want to end this chapter with some hints that we have found useful when using inheritance. 
Inheritance	Enumeration Classes	  You saw in Chapter 3 how to define enumerated types. Here is a typical example: public enum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE } 
Inheritance	Object Wrappers and Autoboxing	  Occasionally, you need to convert a primitive type like int to an object. All primitive types have class counterparts. For example, a class Integer corresponds to the primitive type int. These kinds of classes are usually called wrappers. The wrapper classes have obvious names: Integer, Long, Float, Double, Short, Byte, Character, and Boolean. (The first six inherit from the common superclass Number.) The wrapper classes are immutable—you cannot change a wrapped value after the wrapper has been constructed. They are also final, so you cannot subclass them. 
Inheritance	Inheritance	  Chapter 4 introduced you to classes and objects. In this chapter, you will learn about inheritance, another fundamental concept of object-oriented programming. The idea behind inheritance is that you can create new classes that are built on existing classes. When you inherit from an existing class, you reuse (or inherit) its methods, and you can add new methods and fields to adapt your new class to new situations. This technique is essential in Java programming.
Inheritance	Generic Array Lists	  In some programming languages—in particular, in C and C++—you have to fix the sizes of all arrays at compile time. Programmers hate this because it forces them into uncomfortable tradeoffs. How many employees will be in a department? Surely no more than 100. What if there is a humongous department with 150 employees? Do we want to waste 90 entries for every department with just 10 employees? 
Inheritance	Reflection	  The reflection library gives you a very rich and elaborate toolset to write programs that manipulate Java code dynamically. Using reflection, Java can support user interface builders, object-relational mappers, and many other development tools that dynamically inquire about the capabilities of classes. 
Inheritance	Methods with a Variable Number of Parameters	  It is possible to provide methods that can be called with a variable number of parameters. (These are sometimes called "varargs" methods.) You have already seen such a method: printf. For example, the calls System.out.printf("%d", n); 
Exceptions, Assertions, and Logging	Using Assertions	  Assertions are a commonly used idiom of defensive programming. In the following sections, you will learn how to use them effectively. 
Exceptions, Assertions, and Logging	Exceptions, Assertions, and Logging	  In a perfect world, users would never enter data in the wrong form, files they choose to open would always exist, and code would never have bugs. So far, we have mostly presented code as if we lived in this kind of perfect world. It is now time to turn to the mechanisms the Java programming language has for dealing with the real world of bad data and buggy code.
Exceptions, Assertions, and Logging	Dealing with Errors	  Suppose an error occurs while a Java program is running. The error might be caused by a file containing wrong information, a flaky network connection, or (we hate to mention it) use of an invalid array index or an object reference that hasn’t yet been assigned to an object. Users expect that programs will act sensibly when errors happen. If an operation cannot be completed because of an error, the program ought to either Return to a safe state and enable the user to execute other commands; or Allow the user to save all work and terminate the program gracefully. 
Exceptions, Assertions, and Logging	Tips for Using Exceptions	  There is a certain amount of controversy about the proper use of exceptions. 
Exceptions, Assertions, and Logging	Debugging Tips	  Suppose you wrote your program and made it bulletproof by catching and properly handling all exceptions. Then you run it, and it does not work right. 
Exceptions, Assertions, and Logging	Logging	  Every Java programmer is familiar with the process of inserting calls to System.out.println into troublesome code to gain insight into program behavior. Of course, once you have figured out the cause of trouble,   you remove the print statements, only to put them back in when the next problem surfaces. The logging API is designed to overcome this problem. 
Exceptions, Assertions, and Logging	Catching Exceptions	  You now know how to throw an exception. It is pretty easy: You throw it and you forget it. Of course, some code has to catch the exception. Catching exceptions requires more planning. That’s what the next sections will cover. 
Graphical User Interface Programming	Displaying Frames	  A top-level window (that is, a window that is not contained inside another window) is called a frame in Java. The AWT library has a class, called Frame, for this top level. The Swing version of this class is called JFrame and extends the Frame class. The JFrame is one of the few Swing components that is not painted on a canvas. Thus, the decorations (buttons, title bar, icons, and so on) are drawn by the user’s windowing system, not by Swing. 
Graphical User Interface Programming	Displaying Information in a Component	  In this section, we will show you how to display information inside a frame (Figure 10.3). 
Graphical User Interface Programming	The Preferences API	  We end this chapter with a discussion of the java.util.preferences API. In a desktop program, you will often want to store user preferences, such as the last file that the user worked on, the last window location, and so on. 
Graphical User Interface Programming	Graphical User Interface Programming	  Java was born at a time when most computer users interacted with graphical desktop applications. Nowadays, browser-based and mobile applications are far more common, but there are still times when it is useful to provide a desktop application. In this and the following chapter, we discuss the basics of user interface programming with the Swing toolkit. If, on the other hand, you intend to use Java for server-side programming only and are not interested in writing GUI programs, you can safely skip these two chapters.
Graphical User Interface Programming	A History of Java User Interface Toolkits	  When Java 1.0 was introduced, it contained a class library, called the Abstract Window Toolkit (AWT), for basic GUI programming. The basic AWT library deals with user interface elements by delegating their creation and behavior to the native GUI toolkit on each target platform (Windows, Linux, Macintosh, and so on). For example, if you used the original AWT to put a text box on a Java window, an underlying "peer" text box actually handled the text input. The resulting program could then, in theory, run on any of these platforms, with the "look-and-feel" of the target platform. 
Graphical User Interface Programming	Event Handling	  Any operating environment that supports GUIs constantly monitors events such as keystrokes or mouse clicks. These events are then reported to the programs that are running. Each program then decides what, if anything, to do in response to these events. 
Fundamental Programming Structures in Java	Big Numbers	  If the precision of the basic integer and floating-point types is not sufficient, you can turn to a couple of handy classes in the java.math package: BigInteger and BigDecimal. These are classes for manipulating numbers with an arbitrarily long sequence of digits. The BigInteger class implements arbitrary-precision integer arithmetic, and BigDecimal does the same for floating-point numbers. 
Fundamental Programming Structures in Java	Comments	  Comments in Java, as in most programming languages, do not show up in the executable program. Thus, you can add as many comments as needed without fear of bloating the code. Java has three ways of marking comments. The most common form is a //. Use this for a comment that runs from the // to the end of the line. 
Fundamental Programming Structures in Java	Strings	  Conceptually, Java strings are sequences of Unicode characters. For example, the string "Java\u2122" consists of the five Unicode characters J, a, v, a, and ™. Java does not have a built-in string type. Instead, the standard Java library contains a predefined class called, naturally enough, String. Each quoted string is an instance of the String class: String e = ""; // an empty string String greeting = "Hello"; 
Fundamental Programming Structures in Java	Input and Output	  To make our example programs more interesting, we want to accept input and properly format the program output. Of course, modern programs use a GUI for collecting user input. However, programming such an interface requires more tools and techniques than we have at our disposal at this time. 
Fundamental Programming Structures in Java	Fundamental Programming Structures in Java	  At this point, we are assuming that you successfully installed the JDK and were able to run the sample programs that we showed you in Chapter 2. It’s time to start programming. This chapter shows you how the basic programming concepts such as data types, branches, and loops are implemented in Java.
Fundamental Programming Structures in Java	Data Types	  Java is a strongly typed language. This means that every variable must have a declared type. There are eight primitive types in Java. Four of them are integer types; two are floating-point number types; one is the character type char, used for code units in the Unicode encoding scheme (see Section 3.3.3, "The char Type," on p. 46); and one is a boolean type for truth values. 
Fundamental Programming Structures in Java	Operators	  Operators are used to combine values. As you will see in the following sections, Java has a rich set of arithmetic and logical operators and mathematical functions. 
Fundamental Programming Structures in Java	Control Flow	  Java, like any programming language, supports both conditional statements and loops to determine control flow. We will start with the conditional statements, then move on to loops, to end with the somewhat cumbersome switch statement that you can use to test for many values of a single expression. 
Fundamental Programming Structures in Java	Variables and Constants	  As in every programming language, variables are used to store values. 
Fundamental Programming Structures in Java	A Simple Java Program	  Let’s look more closely at one of the simplest Java programs you can have— one that merely prints a message to console: public class FirstSample { public static void main(String[] args) { System.out.println("We will not use 'Hello, World!'"); 
Fundamental Programming Structures in Java	Arrays	  Arrays hold sequences of values of the same type. In the following sections, you will see how to work with arrays in Java. 
Collections	The Java Collections Framework	  The initial release of Java supplied only a small set of classes for the most useful data structures: Vector, Stack, Hashtable, BitSet, and the Enumeration interface that provides an abstract mechanism for visiting elements in an arbitrary container. That was certainly a wise choice—it takes time and skill to come up with a comprehensive collection class library. 
Collections	Maps	  A set is a collection that lets you quickly find an existing element. However, to look up an element, you need to have an exact copy of the element to find. 
Collections	Views and Wrappers	  If you look at Figures 9.4 and 9.5, you might think it is overkill to have lots of interfaces and abstract classes to implement a modest number of concrete collection classes. However, these figures don’t tell the whole story. By using views, you can obtain other objects that implement the Collection or Map inter-faces. You saw one example of this with the keySet method of the map classes. At first glance, it appears as if the method creates a new set, fills it with all the keys of the map, and returns it. However, that is not the case. 
Collections	Algorithms	  In addition to implementing collection classes, the Java collections framework also provides a number of useful algorithms. In the following sections, you will see how to use these algorithms and how to write your own algorithms that work well with the collections framework. 
Collections	Legacy Collections	  A number of "legacy" container classes have been present since the first release of Java, before there was a collections framework. 
Collections	Interfaces in the Collections Framework	  The Java collections framework defines a number of interfaces for different types of collections, shown in Figure 9.4. 
Collections	Concrete Collections	  Table 9.1 shows the collections in the Java library and briefly describes the purpose of each collection class. (For simplicity, we omit the thread-safe collections that will be discussed in Chapter 12.) All classes in Table 9.1 implement the Collection interface, with the exception of the classes with names ending in Map. Those classes implement the Map interface instead. We will discuss maps in Section 9.4, "Maps," on p. 519. 
Collections	Collections	  The data structures that you choose can make a big difference when you try to implement methods in a natural style or are concerned with performance. Do you need to search quickly through thousands (or even millions) of sorted items? Do you need to rapidly insert and remove elements in the middle of an ordered sequence? Do you need to establish associations between keys and values?
The Java Programming Environment	Using the Command-Line Tools	  If your programming experience comes from a development environment such as Microsoft Visual Studio, you are accustomed to a system with a builtin text editor, menus to compile and launch a program, and a debugger. The JDK contains nothing even remotely similar. You do everything by typing in commands in a terminal window. This sounds cumbersome, but it is nevertheless an essential skill. When you first install Java, you will want to troubleshoot your installation before you install a development environment. 
The Java Programming Environment	Installing the Java Development Kit	  The most complete and up-to-date versions of the Java Development Kit (JDK) are available from Oracle for Linux, Mac OS, Solaris, and Windows. 
The Java Programming Environment	The Java Programming Environment	  In this chapter, you will learn how to install the Java Development Kit (JDK) and how to compile and run various types of programs: console programs, graphical applications, and applets. You can run the JDK tools by typing commands in a terminal window. However, many programmers prefer the comfort of an integrated development environment. You will learn how to use a freely available development environment to compile and run Java programs. Once you have mastered the techniques in this chapter and picked your development tools, you are ready to move on to Chapter 3, where you will begin exploring the Java programming language.
The Java Programming Environment	Using an Integrated Development Environment	  In the preceding section, you saw how to compile and run a Java program from the command line. That is a useful skill for troubleshooting, but for most day-to-day work, you should use an integrated development environment. These environments are so powerful and convenient that it simply doesn’t make much sense to labor on without them. Excellent choices are the freely available Eclipse, IntelliJ IDEA, and NetBeans. In this chapter, you will learn how to get started with Eclipse. Of course, if you prefer a different development environment, you can certainly use it with this book. 
The Java Programming Environment	JShell	  In the preceding section, you saw how to compile and run a Java program. 
Concurrency	Synchronization	  In most practical multithreaded applications, two or more threads need to share access to the same data. What happens if two threads have access to the same object and each calls a method that modifies the state of the object? As you might imagine, the threads can step on each other’s toes. Depending on the order in which the data were accessed, corrupted objects can result. Such a situation is often called a race condition. 
Concurrency	What Are Threads?	  Let us start by looking at a simple program that uses two threads. This program moves money between bank accounts. We make use of a Bank class that stores the balances of a given number of accounts. The transfer method transfers an amount from one account to another. See Listing 12.2 for the implementation. 
Concurrency	Thread Properties	  In the following sections, we discuss miscellaneous properties of threads: the interrupted status, daemon threads, handlers for uncaught exceptions, as well as some legacy features that you should not use. 
Concurrency	Processes	  Up to now, you have seen how to execute Java code in separate threads within the same program. Sometimes, you need to execute another program. 
Concurrency	Thread-Safe Collections	  If multiple threads concurrently modify a data structure, such as a hash table, it is easy to damage that data structure. (See Chapter 9 for more information on hash tables.) For example, one thread may begin to insert a new element. 
Concurrency	Tasks and Thread Pools	  Constructing a new thread is somewhat expensive because it involves interaction with the operating system. If your program creates a large number of short-lived threads, you should not map each task to a separate thread, but use a thread pool instead. A thread pool contains a number of threads that are ready to run. You give a Runnable to the pool, and one of the threads calls the run method. When the run method exits, the thread doesn’t die but stays around to serve the next request. 
Concurrency	Asynchronous Computations	  So far, our approach to concurrent computation has been to break up a task, and then wait until all pieces have completed. But waiting is not always a good idea. In the following sections, you will see how to implement waitfree, or asynchronous, computations. 
Concurrency	Thread States	  Threads can be in one of six states: New Runnable Blocked Waiting Timed waiting Terminated Each of these states is explained in the sections that follow. 
Concurrency	Concurrency	  12.2 Thread States 12.3 Thread Properties 12.4 Synchronization 12.5 Thread-Safe Collections 12.6 Tasks and Thread Pools 12.7 Asynchronous Computations 12.8 Processes You are probably familiar with multitasking—your operating system’s ability to have more than one program working at what seems like the same time. For example, you can print while editing or downloading your email. Nowadays, you are likely to have a computer with more than one CPU, but the number of concurrently executing processes is not limited by the number of CPUs. The operating system assigns CPU time slices to each process, giving the impression of parallel activity.
User Interface Components with Swing	Menus	  We started this chapter by introducing the most common components that you might want to place into a window, such as various kinds of buttons, text fields, and combo boxes. Swing also supports another type of user interface element—pull-down menus that are familiar from GUI applications. 
User Interface Components with Swing	Dialog Boxes	  So far, all our user interface components have appeared inside a frame window that was created in the application. This is the most common situation if you write applets that run inside a web browser. But if you write applications, you usually want separate dialog boxes to pop up to give   information to, or get information from, the user. 
User Interface Components with Swing	Introduction to Layout Management	  Before we go on to discussing individual Swing components, such as text fields and radio buttons, we briefly cover how to arrange these components inside a frame. 
User Interface Components with Swing	Sophisticated Layout Management	  So far we’ve been using only the border layout, flow layout, and grid layout for the user interface of our sample applications. For more complex tasks, this is not going to be enough. 
User Interface Components with Swing	Choice Components	  You now know how to collect text input from users, but there are many occasions where you would rather give users a finite set of choices than have them enter the data in a text component. Using a set of buttons or a list of items tells your users what choices they have. (It also saves you the trouble of error checking.) In this section, you will learn how to program checkboxes, radio buttons, lists of choices, and sliders. 
User Interface Components with Swing	Swing and the Model-View-Controller Design Pattern	  Let’s step back for a minute and think about the pieces that make up a user interface component such as a button, a checkbox, a text field, or a sophisticated tree control. Every component has three characteristics: Its content, such as the state of a button (pushed in or not), or the text in   a text field Its visual appearance (color, size, and so on) Its behavior (reaction to events) Even a seemingly simple component such as a button exhibits some moderately complex interaction among these characteristics. Obviously, the visual appearance of a button depends on the look-and-feel. A Metal button looks different from a Windows button or a Motif button. In addition, the appearance depends on the button state; when a button is pushed in, it needs to be redrawn to look different. The state depends on the events that the button receives. When the user depresses the mouse inside the button, the button is pushed in. 
User Interface Components with Swing	Text Input	  We are finally ready to start introducing the Swing user interface components. We begin with the components that let a user input and edit text. 
User Interface Components with Swing	User Interface Components with Swing	  The previous chapter was written primarily to show you how to use the event model in Java.
Generic Programming	Reflection and Generics	  Reflection lets you analyze arbitrary objects at runtime. If the objects are instances of generic classes, you don’t get much information about the generic type parameters because they have been erased. In the following sections, you will learn what you can nevertheless find out about generic classes with reflection. 
Generic Programming	Generic Methods	  In the preceding section, you have seen how to define a generic class. You can also define a single method with type parameters. 
Generic Programming	Why Generic Programming?	  Generic programming means writing code that can be reused for objects of many different types. For example, you don’t want to program separate   classes to collect String and File objects. And you don’t have to—the single class ArrayList collects objects of any class. This is one example of generic programming. 
Generic Programming	Generic Code and the Virtual Machine	  The virtual machine does not have objects of generic types—all objects belong to ordinary classes. An earlier version of the generics implementation   was even able to compile a program that used generics into class files that executed on 1.0 virtual machines! In the following sections, you will see how the compiler "erases" type parameters, and what implication that process has for Java programmers. 
Generic Programming	Bounds for Type Variables	  Sometimes, a class or a method needs to place restrictions on type variables. 
Generic Programming	Defining a Simple Generic Class	  A generic class is a class with one or more type variables. In this chapter, we will use a simple Pair class as an example. This class allows us to focus on generics without being distracted by data storage details. Here is the code for the generic Pair class:   public class Pair<T> { private T first; 
Generic Programming	Wildcard Types	  It was known for some time among researchers of type systems that a rigid system of generic types is quite unpleasant to use. The Java designers invented an ingenious (but nevertheless safe) "escape hatch": the wildcard type. The following sections show you how to work with wildcards. 
Generic Programming	Restrictions and Limitations	  In the following sections, we discuss a number of restrictions that you need to consider when working with Java generics. Most of these restrictions are a consequence of type erasure. 
Generic Programming	Generic Programming	  8.2 Defining a Simple Generic Class 8.3 Generic Methods 8.4 Bounds for Type Variables 8.5 Generic Code and the Virtual Machine 8.6 Restrictions and Limitations 8.7 Inheritance Rules for Generic Types 8.8 Wildcard Types 8.9 Reflection and Generics Generic classes and methods have type parameters. This allows them to describe precisely what should happen when they are instantiated with specific types. Prior to generic classes, programmers had to use the Object for writing code that works with multiple types. This was both cumbersome and unsafe.
Generic Programming	Inheritance Rules for Generic Types	  When you work with generic classes, you need to learn a few rules about inheritance and subtypes. Let’s start with a situation which many programmers find unintuitive. Consider a class and a subclass, such as Employee and Manager. Is Pair<Manager> a subclass of Pair<Employee>? Perhaps surprisingly, the answer is "no." For example, the following code will not compile: Manager[] topHonchos = . . .; 
An Introduction to Java	Java Applets and the Internet	  The idea here is simple: Users will download Java bytecodes from the Internet and run them on their own machines. Java programs that work on web pages are called applets. To use an applet, you only need a Java-enabled   web browser, which will execute the bytecodes for you. You need not install any software. You get the latest version of the program whenever you visit the web page containing the applet. Most importantly, thanks to the security of the virtual machine, you never need to worry about attacks from hostile code. 
An Introduction to Java	Common Misconceptions about Java	  This chapter closes with a commented list of some common misconceptions about Java. 
An Introduction to Java	Java as a Programming Platform	  In the first edition of this book, my coauthor Gary Cornell and I had this to write about Java: "As a computer language, Java’s hype is overdone: Java is certainly a good programming language. There is no doubt that it is one of the better languages available to serious programmers. We think it could potentially have been a great programming language, but it is probably too late for that. 
An Introduction to Java	A Short History of Java	  This section gives a short history of Java’s evolution. It is based on various published sources (most importantly an interview with Java’s creators in the July 1995 issue of SunWorld’s online magazine). 
An Introduction to Java	The Java "White Paper" Buzzwords	  The authors of Java wrote an influential white paper that explains their design goals and accomplishments. They also published a shorter overview that is organized along the following 11 buzzwords: 1. Simple 2. Object-Oriented 3. Distributed 4. Robust 5. Secure 6. Architecture-Neutral 7. Portable 8. Interpreted 9. High-Performance 10. Multithreaded 11. Dynamic In the following subsections, you will find a summary, with excerpts from the white paper, of what the Java designers say about each buzzword, together with a commentary based on my experiences with the current version of Java. 
An Introduction to Java	An Introduction to Java	  The first release of Java in 1996 generated an incredible amount of excitement, not just in the computer press, but in mainstream media such as the New York Times, the Washington Post, and BusinessWeek. Java has the distinction of being the first and only programming language that had a ten-minute story on National Public Radio. A $100,000,000 venture capital fund was set up solely for products using a specific computer language. I hope you will enjoy a brief history of Java that you will find in this chapter.
