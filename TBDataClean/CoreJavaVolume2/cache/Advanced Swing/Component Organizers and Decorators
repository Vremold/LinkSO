
731

javax.swing.ProgressMonitor 1.2

• ProgressMonitor(Component parent, Object message, String note, int min, int max)
constructs a progress monitor dialog box.
Parameters:

parent

The parent component over which this dialog box
pops up

message

The message object to display in the dialog box

note

The optional string to display under the message.
If this value is null, no space is set aside for the note,
and a later call to setNote has no effect.

min, max

The minimum and maximum values of the progress
bar

• void setNote(String note)
changes the note text.
• void setProgress(int value)
sets the progress bar value to the given value.
• void close()
closes this dialog box.
• boolean isCanceled()
returns true if the user canceled this dialog box.

javax.swing.ProgressMonitorInputStream 1.2

• ProgressMonitorInputStream(Component parent, Object message, InputStream in)
constructs an input stream filter with an associated progress monitor dialog box.
Parameters:

parent

The parent component over which this dialog box
pops up

message

The message object to display in the dialog box

in

The input stream that is being monitored

10.6 Component Organizers and Decorators
We conclude the discussion of advanced Swing features with a presentation of
components that help organize other components. These include the split pane, a
mechanism for splitting an area into multiple parts with boundaries that can be
adjusted; the tabbed pane which uses tab dividers to allow a user to flip through

From the Library of Hristo Dimov Hristov

732

Chapter 10

Advanced Swing

multiple panels; and the desktop pane that can be used to implement applications
displaying multiple internal frames. We will close with a discussion of
layers—decorators that can be superimposed over other components.

10.6.1 Split Panes
A split pane splits a component into two parts, with an adjustable boundary in
between. Figure 10.44 shows a frame with two split panes. The components
in the outer split pane are arranged vertically, with a text area on the bottom
and another split pane on the top. That split pane’s components are arranged
horizontally, with a list on the left and a label containing an image on the right.

Figure 10.44 A frame with two nested split panes
Construct a split pane by specifying the orientation—one of JSplitPane.HORIZONTAL_SPLIT
or JSplitPane.VERTICAL_SPLIT, followed by the two components. For example,
JSplitPane innerPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, planetList, planetImage);

That’s all you have to do. If you like, you can add “one-touch expand” icons to
the splitter bar. You can see those icons in the top pane in Figure 10.44. In the
Metal look-and-feel, they are small triangles. If you click one of them, the splitter
moves all the way in the direction to which the triangle is pointing, expanding
one of the panes completely.
To add this capability, call

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

733

innerPane.setOneTouchExpandable(true);

The “continuous layout” feature continuously repaints the contents of both
components as the user adjusts the splitter. That looks classier, but it can be slow.
Turn on that feature with the call
innerPane.setContinuousLayout(true);

In the example program, we left the bottom splitter at the default (no continuous
layout). When you drag it, you only move a black outline. When you release the
mouse, the components are repainted.
The straightforward program in Listing 10.29 populates a list box with planets.
When the user makes a selection, the planet image is displayed to the right and
a description is placed in the text area on the bottom. Run the program, adjust
the splitters, and try out the one-touch expansion and continuous layout features.

Listing 10.29
1

splitPane/SplitPaneFrame.java

package splitPane;

2
3

import java.awt.*;

4
5

import javax.swing.*;

6
7
8
9
10
11
12
13

/**
* This frame consists of two nested split panes to demonstrate planet images and data.
*/
class SplitPaneFrame extends JFrame
{
private static final int DEFAULT_WIDTH = 300;
private static final int DEFAULT_HEIGHT = 300;

14
15
16
17
18
19

private Planet[] planets = { new Planet("Mercury", 2440, 0), new Planet("Venus", 6052, 0),
new Planet("Earth", 6378, 1), new Planet("Mars", 3397, 2),
new Planet("Jupiter", 71492, 16), new Planet("Saturn", 60268, 18),
new Planet("Uranus", 25559, 17), new Planet("Neptune", 24766, 8),
new Planet("Pluto", 1137, 1), };

20
21
22
23

public SplitPaneFrame()
{
setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);

24
25

// set up components for planet names, images, descriptions

26
27
28
29

final JList<Planet> planetList = new JList<>(planets);
final JLabel planetImage = new JLabel();
final JTextArea planetDescription = new JTextArea();
(Continues)

From the Library of Hristo Dimov Hristov

734

Chapter 10

Advanced Swing

Listing 10.29 (Continued)
30

planetList.addListSelectionListener(event ->
{
Planet value = (Planet) planetList.getSelectedValue();

31
32
33
34

// update image and description

35
36

planetImage.setIcon(value.getImage());
planetDescription.setText(value.getDescription());
});

37
38
39
40

// set up split panes

41
42

JSplitPane innerPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, planetList, planetImage);

43
44

innerPane.setContinuousLayout(true);
innerPane.setOneTouchExpandable(true);

45
46
47

JSplitPane outerPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT, innerPane,
planetDescription);

48
49
50

add(outerPane, BorderLayout.CENTER);

51

}

52
53

}

javax.swing.JSplitPane 1.2

•
•
•
•
•

JSplitPane()
JSplitPane(int direction)
JSplitPane(int direction, boolean continuousLayout)
JSplitPane(int direction, Component first, Component second)
JSplitPane(int direction, boolean continuousLayout, Component first, Component second)

constructs a new split pane.
Parameters:

direction

One of HORIZONTAL_SPLIT or VERTICAL_SPLIT

continousLayout

true if the components are continuously updated

when the splitter is moved
first, second

The components to add

• boolean isOneTouchExpandable()
• void setOneTouchExpandable(boolean b)
gets or sets the “one-touch expandable” property. When this property is set, the
splitter has two icons to completely expand one or the other component.
(Continues)

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

735

javax.swing.JSplitPane 1.2 (Continued)

• boolean isContinuousLayout()
• void setContinuousLayout(boolean b)
gets or sets the “continuous layout” property. When this property is set, the
components are continuously updated when the splitter is moved.
• void setLeftComponent(Component c)
• void setTopComponent(Component c)
These operations have the same effect, setting c as the first component in the
split pane.
• void setRightComponent(Component c)
• void setBottomComponent(Component c)
These operations have the same effect, setting c as the second component in the
split pane.

10.6.2 Tabbed Panes
Tabbed panes are a familiar user interface device to break up a complex dialog
box into subsets of related options. You can also use tabs to let a user flip through
a set of documents or images (see Figure 10.45). That is what we do in our sample
program.

Figure 10.45 A tabbed pane

From the Library of Hristo Dimov Hristov

736

Chapter 10

Advanced Swing

To create a tabbed pane, first construct a JTabbedPane object, then add tabs to it.
JTabbedPane tabbedPane = new JTabbedPane();
tabbedPane.addTab(title, icon, component);

The last parameter of the addTab method has type Component. To add multiple
components into the same tab, first pack them up in a container, such as a JPanel.
The icon is optional; for example, the addTab method does not require an icon:
tabbedPane.addTab(title, component);

You can also add a tab in the middle of the tab collection with the insertTab method:
tabbedPane.insertTab(title, icon, component, tooltip, index);

To remove a tab from the tab collection, use
tabPane.removeTabAt(index);

When you add a new tab to the tab collection, it is not automatically displayed.
You must select it with the setSelectedIndex method. For example, here is how you
show a tab that you just added to the end:
tabbedPane.setSelectedIndex(tabbedPane.getTabCount() - 1);

If you have a lot of tabs, they can take up quite a bit of space. Starting with Java
SE 1.4, you can display the tabs in scrolling mode, in which only one row of tabs
is displayed, together with a set of arrow buttons that allow the user to scroll
through the tab set (see Figure 10.46).

Figure 10.46 A tabbed pane with scrolling tabs

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

737

Set the tab layout to wrapped or scrolling mode by calling
tabbedPane.setTabLayoutPolicy(JTabbedPane.WRAP_TAB_LAYOUT);

or
tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);

The tab labels can have mnemonics, just like menu items. For example,
int marsIndex = tabbedPane.indexOfTab("Mars");
tabbedPane.setMnemonicAt(marsIndex, KeyEvent.VK_M);

Now the M is underlined, and users can select the tab by pressing Alt+M.
You can add arbitrary components into the tab titles. First, add the tab, then call
tabbedPane.setTabComponentAt(index, component);

In our sample program, we add a “close box” to the Pluto tab (because, after all,
astronomers do not consider Pluto a planet). This is achieved by setting the tab
component to a panel containing two components: a label with the icon and
tab text, and a checkbox with an action listener that removes the tab.
The example program shows a useful technique with tabbed panes. Sometimes,
you may want to update a component just before it is displayed. Here, we load
the planet image only when the user actually clicks a tab.
To be notified whenever the user clicks on a tab, install a ChangeListener with the
tabbed pane. Note that you must install the listener with the tabbed pane itself,
not with any of the components.
tabbedPane.addChangeListener(listener);

When the user selects a tab, the stateChanged method of the change listener is called.
You can retrieve the tabbed pane as the source of the event. Call the getSelectedIndex
method to find out which pane is about to be displayed.
public void stateChanged(ChangeEvent event)
{
int n = tabbedPane.getSelectedIndex();
loadTab(n);
}

In Listing 10.30, we first set all tab components to null. When a new tab is selected,
we test whether its component is still null. If so, we replace it with the image. (This
happens instantaneously when you click on the tab. You will not see an empty
pane.) Just for fun, we also change the icon from a yellow ball to a red ball to
indicate which panes have been visited.

From the Library of Hristo Dimov Hristov

738

Chapter 10

Advanced Swing

Listing 10.30
1

tabbedPane/TabbedPaneFrame.java

package tabbedPane;

2
3

import java.awt.*;

4
5

import javax.swing.*;

6
7
8
9
10
11
12
13
14

/**
* This frame shows a tabbed pane and radio buttons to switch between wrapped and scrolling tab
* layout.
*/
public class TabbedPaneFrame extends JFrame
{
private static final int DEFAULT_WIDTH = 400;
private static final int DEFAULT_HEIGHT = 300;

15
16

private JTabbedPane tabbedPane;

17
18
19
20

public TabbedPaneFrame()
{
setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);

21
22
23
24

tabbedPane = new JTabbedPane();
// we set the components to null and delay their loading until the tab is shown
// for the first time

25
26

ImageIcon icon = new ImageIcon(getClass().getResource("yellow-ball.gif"));

27
28
29
30
31
32
33
34
35
36

tabbedPane.addTab("Mercury", icon, null);
tabbedPane.addTab("Venus", icon, null);
tabbedPane.addTab("Earth", icon, null);
tabbedPane.addTab("Mars", icon, null);
tabbedPane.addTab("Jupiter", icon, null);
tabbedPane.addTab("Saturn", icon, null);
tabbedPane.addTab("Uranus", icon, null);
tabbedPane.addTab("Neptune", icon, null);
tabbedPane.addTab("Pluto", null, null);

37
38
39
40
41
42
43
44

final int plutoIndex = tabbedPane.indexOfTab("Pluto");
JPanel plutoPanel = new JPanel();
plutoPanel.add(new JLabel("Pluto", icon, SwingConstants.LEADING));
JToggleButton plutoCheckBox = new JCheckBox();
plutoCheckBox.addActionListener(event -> tabbedPane.remove(plutoIndex));
plutoPanel.add(plutoCheckBox);
tabbedPane.setTabComponentAt(plutoIndex, plutoPanel);

45
46

add(tabbedPane, "Center");

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

739

47

tabbedPane.addChangeListener(event ->
{
// check if this tab still has a null component

48
49
50
51

if (tabbedPane.getSelectedComponent() == null)
{
// set the component to the image icon

52
53
54
55

int n = tabbedPane.getSelectedIndex();
loadTab(n);

56
57

}
});

58
59
60

loadTab(0);

61
62

JPanel buttonPanel = new JPanel();
ButtonGroup buttonGroup = new ButtonGroup();
JRadioButton wrapButton = new JRadioButton("Wrap tabs");
wrapButton.addActionListener(event ->
tabbedPane.setTabLayoutPolicy(JTabbedPane.WRAP_TAB_LAYOUT));
buttonPanel.add(wrapButton);
buttonGroup.add(wrapButton);
wrapButton.setSelected(true);
JRadioButton scrollButton = new JRadioButton("Scroll tabs");
scrollButton.addActionListener(event ->
tabbedPane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT));
buttonPanel.add(scrollButton);
buttonGroup.add(scrollButton);
add(buttonPanel, BorderLayout.SOUTH);

63
64
65
66
67
68
69
70
71
72
73
74
75
76

}

77
78

/**
* Loads the tab with the given index.
* @param n the index of the tab to load
*/
private void loadTab(int n)
{
String title = tabbedPane.getTitleAt(n);
ImageIcon planetIcon = new ImageIcon(getClass().getResource(title + ".gif"));
tabbedPane.setComponentAt(n, new JLabel(planetIcon));

79
80
81
82
83
84
85
86
87
88

// indicate that this tab has been visited--just for fun

89
90

tabbedPane.setIconAt(n, new ImageIcon(getClass().getResource("red-ball.gif")));

91

}

92
93

}

From the Library of Hristo Dimov Hristov

740

Chapter 10

Advanced Swing

javax.swing.JTabbedPane 1.2

• JTabbedPane()
• JTabbedPane(int placement)
constructs a tabbed pane.
Parameters:

placement

One of SwingConstants.TOP, SwingConstants.LEFT,
SwingConstants.RIGHT, or SwingConstants.BOTTOM

• void addTab(String title, Component c)
• void addTab(String title, Icon icon, Component c)
• void addTab(String title, Icon icon, Component c, String tooltip)
adds a tab to the end of the tabbed pane.
• void insertTab(String title, Icon icon, Component c, String tooltip, int index)
inserts a tab to the tabbed pane at the given index.
• void removeTabAt(int index)
removes the tab at the given index.
• void setSelectedIndex(int index)
selects the tab at the given index.
• int getSelectedIndex()
returns the index of the selected tab.
• Component getSelectedComponent()
returns the component of the selected tab.
•
•
•
•
•
•

String getTitleAt(int index)
void setTitleAt(int index, String title)
Icon getIconAt(int index)
void setIconAt(int index, Icon icon)
Component getComponentAt(int index)
void setComponentAt(int index, Component c)

gets or sets the title, icon, or component at the given index.
• int indexOfTab(String title)
• int indexOfTab(Icon icon)
• int indexOfComponent(Component c)
returns the index of the tab with the given title, icon, or component.
• int getTabCount()
returns the total number of tabs in this tabbed pane.
(Continues)

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

741

javax.swing.JTabbedPane 1.2 (Continued)

• int getTabLayoutPolicy()
• void setTabLayoutPolicy(int policy) 1.4
gets or sets the tab layout policy. policy is one of JTabbedPane.WRAP_TAB_LAYOUT or
JTabbedPane.SCROLL_TAB_LAYOUT.
• int getMnemonicAt(int index) 1.4
• void setMnemonicAt(int index, int mnemonic)
gets or sets the mnemonic character at a given tab index. The character is specified
as a VK_X constant from the KeyEvent class. -1 means that there is no mnemonic.
• Component getTabComponentAt(int index) 6
• void setTabComponentAt(int index, Component c) 6
gets or sets the component that renders the title of the tab with the given index. If
this component is null, the tab icon and title are rendered. Otherwise, only the given
component is rendered in the tab.
• int indexOfTabComponent(Component c) 6
returns the index of the tab with the given title component.
• void addChangeListener(ChangeListener listener)
adds a change listener that is notified when the user selects a different tab.

10.6.3 Desktop Panes and Internal Frames
Many applications present information in multiple windows that are all contained
inside a large frame. If you minimize the application frame, all of its windows
are hidden at the same time. In the Windows environment, this user interface
is sometimes called the multiple document interface (MDI). Figure 10.47 shows a
typical application using this interface.
For a time, this user interface style was popular, but it has become less prevalent
in recent years. Nowadays, many applications simply display a separate toplevel frame for each document. Which is better? MDI reduces window clutter,
but having separate top-level windows means that you can use the buttons and
hotkeys of the host windowing system to flip through your windows.

10.6.3.1 Displaying Internal Frames
In the world of Java, where you can’t rely on a rich host windowing system, it
makes a lot of sense to have your application manage its frames.

From the Library of Hristo Dimov Hristov

742

Chapter 10

Advanced Swing

Figure 10.47 A multiple document interface application
Figure 10.48 shows a Java application with three internal frames. Two of them
have decorations on the borders to maximize and iconify them. The third is in its
iconified state.
In the Metal look-and-feel, the internal frames have distinctive “grabber” areas
that you can use to move the frames around. You can resize the windows by
dragging the resize corners.
To achieve this capability, follow these steps:
1.
2.

Use a regular JFrame window for the application.
Add the JDesktopPane to the JFrame.
desktop = new JDesktopPane();
add(desktop, BorderLayout.CENTER);

3.

Construct JInternalFrame windows. You can specify whether you want the icons
for resizing or closing the frame. Normally, you want all icons.

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

743

Figure 10.48 A Java application with three internal frames
JInternalFrame iframe = new JInternalFrame(title,
true, // resizable
true, // closable
true, // maximizable
true); // iconifiable

4.

Add components to the frame.
iframe.add(c, BorderLayout.CENTER);

5.

Set a frame icon. The icon is shown in the top left corner of the frame.
iframe.setFrameIcon(icon);

NOTE: In the current version of the Metal look-and-feel, the frame icon is not
displayed in iconified frames.

6.

Set the size of the internal frame. As with regular frames, internal frames
initially have a size of 0 by 0 pixels. You don’t want internal frames to be
displayed on top of each other, so use a variable position for the next frame.
Use the reshape method to set both the position and size of the frame.
iframe.reshape(nextFrameX, nextFrameY, width, height);

From the Library of Hristo Dimov Hristov

744

Chapter 10

7.

Advanced Swing

As with JFrame instances, you need to make the frame visible.
iframe.setVisible(true);

NOTE: In earlier versions of Swing, internal frames were automatically visible
and this call was not necessary.

8.

Add the frame to the JDesktopPane.
desktop.add(iframe);

9.

You will probably want to make the new frame the selected frame. Of the internal frames on the desktop, only the selected frame receives keyboard focus.
In the Metal look-and-feel, the selected frame has a blue title bar, whereas
the other frames have gray title bars. Use the setSelected method to select a
frame. However, the “selected” property can be vetoed—the currently selected
frame can refuse to give up focus. In that case, the setSelected method throws
a PropertyVetoException that you need to handle.
try
{
iframe.setSelected(true);
}
catch (PropertyVetoException ex)
{
// attempt was vetoed
}

10. You will probably want to move the position of the next internal frame down
so that it won’t overlay the existing frame. A good distance between frames
is the height of the title bar, which you can obtain as
int frameDistance = iframe.getHeight() - iframe.getContentPane().getHeight();

11. Use that distance to determine the next internal frame’s position.
nextFrameX += frameDistance;
nextFrameY += frameDistance;
if (nextFrameX + width > desktop.getWidth())
nextFrameX = 0;
if (nextFrameY + height > desktop.getHeight())
nextFrameY = 0;

10.6.3.2 Cascading and Tiling
In Windows, there are standard commands for cascading and tiling windows (see
Figures 10.49 and 10.50). The Java JDesktopPane and JInternalFrame classes have no

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

745

built-in support for these operations. In Listing 10.31, we show how you can
implement these operations yourself.

Figure 10.49 Cascaded internal frames
To cascade all windows, reshape windows to the same size and stagger their
positions. The getAllFrames method of the JDesktopPane class returns an array of all
internal frames.
JInternalFrame[] frames = desktop.getAllFrames();

However, you need to pay attention to the frame state. An internal frame can be
in one of three states:
• Icon
• Resizable
• Maximum
Use the isIcon method to find out which internal frames are currently icons and
should be skipped. However, if a frame is in the maximum state, you first need
to set it to be resizable by calling setMaximum(false). This is another property that can
be vetoed, so you must catch the PropertyVetoException.
The following loop cascades all internal frames on the desktop:

From the Library of Hristo Dimov Hristov

746

Chapter 10

Advanced Swing

Figure 10.50 Tiled internal frames
for (JInternalFrame frame : desktop.getAllFrames())
{
if (!frame.isIcon())
{
try
{
// try to make maximized frames resizable; this might be vetoed
frame.setMaximum(false);
frame.reshape(x, y, width, height);
x += frameDistance;
y += frameDistance;
// wrap around at the desktop edge
if (x + width > desktop.getWidth()) x = 0;
if (y + height > desktop.getHeight()) y = 0;
}
catch (PropertyVetoException ex)
{}
}
}

Tiling frames is trickier, particularly if the number of frames is not a perfect
square. First, count the number of frames that are not icons. Compute the number
of rows in the first column as

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

747

int rows = (int) Math.sqrt(frameCount);

Then the number of columns is
int cols = frameCount / rows;

The last
int extra = frameCount % rows;

columns have rows + 1 rows.
Here is the loop for tiling all frames on the desktop:
int width = desktop.getWidth() / cols;
int height = desktop.getHeight() / rows;
int r = 0;
int c = 0;
for (JInternalFrame frame : desktop.getAllFrames())
{
if (!frame.isIcon())
{
try
{
frame.setMaximum(false);
frame.reshape(c * width, r * height, width, height);
r++;
if (r == rows)
{
r = 0;
c++;
if (c == cols - extra)
{
// start adding an extra row
rows++;
height = desktop.getHeight() / rows;
}
}
}
catch (PropertyVetoException ex)
{}
}
}

The example program shows another common frame operation: moving the selection from the current frame to the next frame that isn’t an icon. Traverse all
frames and call isSelected until you find the currently selected frame. Then, look
for the next frame in the sequence that isn’t an icon, and try to select it by calling
frames[next].setSelected(true);

From the Library of Hristo Dimov Hristov

748

Chapter 10

Advanced Swing

As before, that method can throw a PropertyVetoException, in which case you have to
keep looking. If you come back to the original frame, then no other frame was
selectable, and you give up. Here is the complete loop:
JInternalFrame[] frames = desktop.getAllFrames();
for (int i = 0; i < frames.length; i++)
{
if (frames[i].isSelected())
{
// find next frame that isn't an icon and can be selected
int next = (i + 1) % frames.length;
while (next != i)
{
if (!frames[next].isIcon())
{
try
{
// all other frames are icons or veto selection
frames[next].setSelected(true);
frames[next].toFront();
frames[i].toBack();
return;
}
catch (PropertyVetoException ex)
{}
}
next = (next + 1) % frames.length;
}
}
}

10.6.3.3 Vetoing Property Settings
Now that you have seen all these veto exceptions, you might wonder how your
frames can issue a veto. The JInternalFrame class uses a rarely used mechanism from
the JavaBeans specification for monitoring the setting of properties. We won’t
discuss this mechanism in full detail, but we will show you how your frames can
veto requests for property changes.
Frames don’t usually want to use a veto to protest iconization or loss of focus,
but it is very common for frames to check whether it is OK to close them. You can
close a frame with the setClosed method of the JInternalFrame class. Since the method
is vetoable, it calls all registered vetoable change listeners before proceeding to
make the change. That gives each of the listeners the opportunity to throw a
PropertyVetoException and thereby terminate the call to setClosed before it changed any
settings.

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

749

In our example program, we put up a dialog box to ask the user whether it is OK
to close the window (see Figure 10.51). If the user doesn’t agree, the window
stays open.

Figure 10.51 The user can veto the close property.
Here is how you achieve such a notification.
1.

Add a listener object to each frame. The object must belong to some class
that implements the VetoableChangeListener interface. It is best to add the listener
right after constructing the frame. In our example, we use the frame class
that constructs the internal frames. Another option would be to use an
anonymous inner class.
iframe.addVetoableChangeListener(listener);

2.

Implement the vetoableChange method, the only method required by the
VetoableChangeListener interface. The method receives a PropertyChangeEvent object.
Use the getName method to find the name of the property that is about to be
changed (such as "closed" if the method call to veto is setClosed(true). You obtain
the property name by removing the "set" prefix from the method name and
changing the next letter to lower case.

From the Library of Hristo Dimov Hristov

750

Chapter 10

3.

Advanced Swing

Use the getNewValue method to get the proposed new value.
String name = event.getPropertyName();
Object value = event.getNewValue();
if (name.equals("closed") && value.equals(true))
{
ask user for confirmation
}

4.

Simply throw a PropertyVetoException to block the property change. Return
normally if you don’t want to veto the change.
class DesktopFrame extends JFrame
implements VetoableChangeListener
{
...
public void vetoableChange(PropertyChangeEvent event)
throws PropertyVetoException
{
...
if (not ok)
throw new PropertyVetoException(reason, event);
// return normally if ok
}
}

10.6.3.4 Dialogs in Internal Frames
If you use internal frames, you should not use the JDialog class for dialog boxes.
Those dialog boxes have two disadvantages:
• They are heavyweight because they create a new frame in the windowing
system.
• The windowing system does not know how to position them relative to the
internal frame that spawned them.
Instead, for simple dialog boxes, use the showInternalXxxDialog methods of the JOptionPane
class. They work exactly like the showXxxDialog methods, except they position a
lightweight window over an internal frame.
As for more complex dialog boxes, construct them with a JInternalFrame.
Unfortunately, you then have no built-in support for modal dialog boxes.
In our sample program, we use an internal dialog box to ask the user whether it
is OK to close a frame.
int result = JOptionPane.showInternalConfirmDialog(
iframe, "OK to close?", "Select an Option", JOptionPane.YES_NO_OPTION);

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

751

NOTE: If you simply want to be notified when a frame is closed, you should not
use the veto mechanism. Instead, install an InternalFrameListener.An internal frame
listener works just like a WindowListener. When the internal frame is closing, the
internalFrameClosing method is called instead of the familiar windowClosing method.
The other six internal frame notifications (opened/closed, iconified/deiconified,
activated/deactivated) also correspond to the window listener methods.

10.6.3.5 Outline Dragging
One criticism that developers have leveled against internal frames is that performance has not been great. By far the slowest operation is dragging a frame with
complex content across the desktop. The desktop manager keeps asking the frame
to repaint itself as it is being dragged, which is quite slow.
Actually, if you use Windows or X Windows with a poorly written video driver,
you’ll experience the same problem. Window dragging appears to be fast on most
systems because the video hardware supports the dragging operation by
mapping the image inside the frame to a different screen location during the
dragging process.
To improve performance without greatly degrading the user experience, you can
turn “outline dragging” on. When the user drags the frame, only the outline
of the frame is continuously updated. The inside is repainted only when the frame
is dropped to its final resting place.
To turn on outline dragging, call
desktop.setDragMode(JDesktopPane.OUTLINE_DRAG_MODE);

This setting is the equivalent of “continuous layout” in the JSplitPane class.
NOTE: In early versions of Swing, you had to use the magic incantation
desktop.putClientProperty("JDesktopPane.dragMode", "outline");

to turn on outline dragging.

In the sample program, you can use the Window → Drag Outline checkbox menu
selection to toggle outline dragging on or off.
NOTE: The internal frames on the desktop are managed by a DesktopManager class.
You don’t need to know about this class for normal programming. It is possible
to implement a different desktop behavior by installing a new desktop manager,
but we don’t cover that.

From the Library of Hristo Dimov Hristov

752

Chapter 10

Advanced Swing

Listing 10.31 populates a desktop with internal frames that show HTML pages.
The File → Open menu option pops up a file dialog box for reading a local HTML
file into a new internal frame. If you click on any link, the linked document is
displayed in another internal frame. Try out the Window → Cascade and
Window → Tile commands.

Listing 10.31
1

internalFrame/DesktopFrame.java

package internalFrame;

2
3
4

import java.awt.*;
import java.beans.*;

5
6

import javax.swing.*;

7
8
9
10
11
12
13
14
15
16

/**
* This desktop frame contains editor panes that show HTML documents.
*/
public class DesktopFrame extends JFrame
{
private static final int DEFAULT_WIDTH = 600;
private static final int DEFAULT_HEIGHT = 400;
private static final String[] planets = { "Mercury", "Venus", "Earth", "Mars", "Jupiter",
"Saturn", "Uranus", "Neptune", "Pluto", };

17
18
19
20
21
22

private JDesktopPane desktop;
private int nextFrameX;
private int nextFrameY;
private int frameDistance;
private int counter;

23
24
25
26

public DesktopFrame()
{
setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);

27
28
29

desktop = new JDesktopPane();
add(desktop, BorderLayout.CENTER);

30
31

// set up menus

32
33
34
35
36
37

JMenuBar menuBar = new JMenuBar();
setJMenuBar(menuBar);
JMenu fileMenu = new JMenu("File");
menuBar.add(fileMenu);
JMenuItem openItem = new JMenuItem("New");

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

openItem.addActionListener(event ->
{
createInternalFrame(new JLabel(
new ImageIcon(getClass().getResource(planets[counter] + ".gif"))),
planets[counter]);
counter = (counter + 1) % planets.length;
});
fileMenu.add(openItem);
JMenuItem exitItem = new JMenuItem("Exit");
exitItem.addActionListener(event -> System.exit(0));
fileMenu.add(exitItem);
JMenu windowMenu = new JMenu("Window");
menuBar.add(windowMenu);
JMenuItem nextItem = new JMenuItem("Next");
nextItem.addActionListener(event -> selectNextWindow());
windowMenu.add(nextItem);
JMenuItem cascadeItem = new JMenuItem("Cascade");
cascadeItem.addActionListener(event -> cascadeWindows());
windowMenu.add(cascadeItem);
JMenuItem tileItem = new JMenuItem("Tile");
tileItem.addActionListener(event -> tileWindows());
windowMenu.add(tileItem);
final JCheckBoxMenuItem dragOutlineItem = new JCheckBoxMenuItem("Drag Outline");
dragOutlineItem.addActionListener(event ->
desktop.setDragMode(dragOutlineItem.isSelected() ? JDesktopPane.OUTLINE_DRAG_MODE
: JDesktopPane.LIVE_DRAG_MODE));
windowMenu.add(dragOutlineItem);

38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65

753

}

66
67
68
69
70
71
72
73
74
75
76
77

/**
* Creates an internal frame on the desktop.
* @param c the component to display in the internal frame
* @param t the title of the internal frame
*/
public void createInternalFrame(Component c, String t)
{
final JInternalFrame iframe = new JInternalFrame(t, true, // resizable
true, // closable
true, // maximizable
true); // iconifiable

78
79
80

iframe.add(c, BorderLayout.CENTER);
desktop.add(iframe);

81
82

iframe.setFrameIcon(new ImageIcon(getClass().getResource("document.gif")));

83
84

// add listener to confirm frame closing
(Continues)

From the Library of Hristo Dimov Hristov

754

Chapter 10

Advanced Swing

Listing 10.31 (Continued)
iframe.addVetoableChangeListener(event ->
{
String name = event.getPropertyName();
Object value = event.getNewValue();

85
86
87
88
89

// we only want to check attempts to close a frame
if (name.equals("closed") && value.equals(true))
{
// ask user if it is ok to close
int result = JOptionPane.showInternalConfirmDialog(iframe, "OK to close?",
"Select an Option", JOptionPane.YES_NO_OPTION);

90
91
92
93
94
95
96

// if the user doesn't agree, veto the close
if (result != JOptionPane.YES_OPTION)
throw new PropertyVetoException("User canceled close", event);

97
98
99

}
});

100
101
102

// position frame
int width = desktop.getWidth() / 2;
int height = desktop.getHeight() / 2;
iframe.reshape(nextFrameX, nextFrameY, width, height);

103
104
105
106
107

iframe.show();

108
109

// select the frame--might be vetoed
try
{
iframe.setSelected(true);
}
catch (PropertyVetoException ex)
{
}

110
111
112
113
114
115
116
117
118

frameDistance = iframe.getHeight() - iframe.getContentPane().getHeight();

119
120

// compute placement for next frame

121
122

nextFrameX += frameDistance;
nextFrameY += frameDistance;
if (nextFrameX + width > desktop.getWidth()) nextFrameX = 0;
if (nextFrameY + height > desktop.getHeight()) nextFrameY = 0;

123
124
125
126
127

}

128
129
130
131

/**
* Cascades the noniconified internal frames of the desktop.
*/

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

132
133
134
135
136
137

755

public void cascadeWindows()
{
int x = 0;
int y = 0;
int width = desktop.getWidth() / 2;
int height = desktop.getHeight() / 2;

138

for (JInternalFrame frame : desktop.getAllFrames())
{
if (!frame.isIcon())
{
try
{
// try to make maximized frames resizable; this might be vetoed
frame.setMaximum(false);
frame.reshape(x, y, width, height);

139
140
141
142
143
144
145
146
147
148

x += frameDistance;
y += frameDistance;
// wrap around at the desktop edge
if (x + width > desktop.getWidth()) x = 0;
if (y + height > desktop.getHeight()) y = 0;

149
150
151
152
153

}
catch (PropertyVetoException ex)
{
}

154
155
156
157

}

158

}

159
160

}

161
162
163
164
165
166
167
168
169
170
171

/**
* Tiles the noniconified internal frames of the desktop.
*/
public void tileWindows()
{
// count frames that aren't iconized
int frameCount = 0;
for (JInternalFrame frame : desktop.getAllFrames())
if (!frame.isIcon()) frameCount++;
if (frameCount == 0) return;

172
173
174
175
176

int rows = (int) Math.sqrt(frameCount);
int cols = frameCount / rows;
int extra = frameCount % rows;
// number of columns with an extra row

177
178
179
180

int width = desktop.getWidth() / cols;
int height = desktop.getHeight() / rows;
int r = 0;
(Continues)

From the Library of Hristo Dimov Hristov

756

Chapter 10

Advanced Swing

Listing 10.31 (Continued)
int c = 0;
for (JInternalFrame frame : desktop.getAllFrames())
{
if (!frame.isIcon())
{
try
{
frame.setMaximum(false);
frame.reshape(c * width, r * height, width, height);
r++;
if (r == rows)
{
r = 0;
c++;
if (c == cols - extra)
{
// start adding an extra row
rows++;
height = desktop.getHeight() / rows;
}
}
}
catch (PropertyVetoException ex)
{
}
}
}

181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208

}

209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228

/**
* Brings the next noniconified internal frame to the front.
*/
public void selectNextWindow()
{
JInternalFrame[] frames = desktop.getAllFrames();
for (int i = 0; i < frames.length; i++)
{
if (frames[i].isSelected())
{
// find next frame that isn't an icon and can be selected
int next = (i + 1) % frames.length;
while (next != i)
{
if (!frames[next].isIcon())
{
try
{
// all other frames are icons or veto selection

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

frames[next].setSelected(true);
frames[next].toFront();
frames[i].toBack();
return;

229
230
231
232

}
catch (PropertyVetoException ex)
{
}

233
234
235
236

}
next = (next + 1) % frames.length;

237
238

}

239

}

240

}

241

}

242
243

757

}

javax.swing.JDesktopPane 1.2

• JInternalFrame[] getAllFrames()
gets all internal frames in this desktop pane.
• void setDragMode(int mode)
sets the drag mode to live or outline drag mode.
Parameters:

mode

One of JDesktopPane.LIVE_DRAG_MODE or
JDesktopPane.OUTLINE_DRAG_MODE

javax.swing.JInternalFrame 1.2

•
•
•
•
•
•

JInternalFrame()
JInternalFrame(String title)
JInternalFrame(String title, boolean resizable)
JInternalFrame(String title, boolean resizable, boolean closable)
JInternalFrame(String title, boolean resizable, boolean closable, boolean maximizable)
JInternalFrame(String title, boolean resizable, boolean closable, boolean maximizable, boolean
iconifiable)

constructs a new internal frame.
Parameters:

title

The string to display in the title bar

resizable

true if the frame can be resized

closable

true if the frame can be closed

maximizable

true if the frame can be maximized

iconifiable

true if the frame can be iconified
(Continues)

From the Library of Hristo Dimov Hristov

758

Chapter 10

Advanced Swing

javax.swing.JInternalFrame 1.2 (Continued)

•
•
•
•
•
•
•
•

boolean isResizable()
void setResizable(boolean b)
boolean isClosable()
void setClosable(boolean b)
boolean isMaximizable()
void setMaximizable(boolean b)
boolean isIconifiable()
void setIconifiable(boolean b)

gets or sets the resizable, closable, maximizable, and iconifiable properties. When the
property is true, an icon appears in the frame title to resize, close, maximize, or
iconify the internal frame.
•
•
•
•
•
•

boolean isIcon()
void setIcon(boolean b)
boolean isMaximum()
void setMaximum(boolean b)
boolean isClosed()
void setClosed(boolean b)

gets or sets the icon, maximum, or closed property.When this property is true, the internal
frame is iconified, maximized, or closed.
• boolean isSelected()
• void setSelected(boolean b)
gets or sets the selected property. When this property is true, the current internal
frame becomes the selected frame on the desktop.
• void moveToFront()
• void moveToBack()
moves this internal frame to the front or the back of the desktop.
• void reshape(int x, int y, int width, int height)
moves and resizes this internal frame.
Parameters:

x, y

The top left corner of the frame

width, height

The width and height of the frame

• Container getContentPane()
• void setContentPane(Container c)
gets or sets the content pane of this internal frame.
(Continues)

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

759

javax.swing.JInternalFrame 1.2 (Continued)

• JDesktopPane getDesktopPane()
gets the desktop pane of this internal frame.
• Icon getFrameIcon()
• void setFrameIcon(Icon anIcon)
gets or sets the frame icon that is displayed in the title bar.
• boolean isVisible()
• void setVisible(boolean b)
gets or sets the “visible” property.
• void show()
makes this internal frame visible and brings it to the front.

javax.swing.JComponent 1.2

• void addVetoableChangeListener(VetoableChangeListener listener)
adds a vetoable change listener that is notified when an attempt is made to change
a constrained property.

java.beans.VetoableChangeListener 1.1

• void vetoableChange(PropertyChangeEvent event)
is called when the set method of a constrained property notifies the vetoable change
listeners.

java.beans.PropertyChangeEvent 1.1

• String getPropertyName()
returns the name of the property that is about to be changed.
• Object getNewValue()
returns the proposed new value for the property.

From the Library of Hristo Dimov Hristov

760

Chapter 10

Advanced Swing

java.beans.PropertyVetoException 1.1

• PropertyVetoException(String reason, PropertyChangeEvent event)
constructs a property veto exception.
Parameters:

reason

The reason for the veto

event

The vetoed event

10.6.4 Layers
Java SE 1.7 introduces a feature that lets you place a layer over another component.
You can paint on the layer and listen to events of the underlying component. You
can use layers to add visual clues to your user interface. For example, you can
decorate the current input, invalid inputs, or disabled components.
The JLayer class associates a component with a LayerUI object that is in charge of
painting and event handling. The LayerUI class has a type parameter that must
match the associated component. For example, here we add a layer to a JPanel:
JPanel panel = new JPanel();
LayerUI<JPanel> layerUI = new PanelLayer();
JLayer layer = new JLayer(panel, layerUI);
frame.add(layer);

Note that you add the layer, not the panel, to the parent. Here, PanelLayer is a
subclass:
class PanelLayer extends LayerUI<Panel>
{
public void paint(Graphics g, JComponent c)
{
...
}
...
}

In the paint method, you can paint anything you like. Be sure to call super.paint to
have the component painted. Here, we draw a transparent color over the entire
component:
public void paint(Graphics g, JComponent c)
{
super.paint(g, c);
Graphics2D g2 = (Graphics2D) g.create();
g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, .3f));
g2.setPaint(color));
g2.fillRect(0, 0, c.getWidth(), c.getHeight());

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

761

g2.dispose();
}

In order to listen to events from the associated component or any of its children,
the LayerUI class must set the layer’s event mask. This should be done in the installUI
method, like this:
class PanelLayer extends LayerUI<JPanel>
{
public void installUI(JComponent c)
{
super.installUI(c);
((JLayer<?>) c).setLayerEventMask(AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);
}
public void uninstallUI(JComponent c)
{
((JLayer<?>) c).setLayerEventMask(0);
super.uninstallUI(c);
}
...
}

Now you will receive events in the methods named processXxxEvent. For example,
in our sample application, we repaint the layer after every keystroke:
public class PanelLayer extends LayerUI<JPanel>
{
protected void processKeyEvent(KeyEvent e, JLayer<? extends JPanel> l)
{
l.repaint();
}
}

Our sample program in Listing 10.32 has three input fields for the RGB values of
a color. Whenever the user changes the values, the color is shown transparently
over the panel. We also trap focus events and show the text of the focused
component in a bold font.

Listing 10.32
1

layer/ColorFrame.java

package layer;

2
3
4
5
6

import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.plaf.*;

7

(Continues)

From the Library of Hristo Dimov Hristov

762

Chapter 10

Advanced Swing

Listing 10.32 (Continued)
8
9
10
11
12
13
14
15
16

/**
* A frame with three text fields to set the background color.
*/
public class ColorFrame extends JFrame
{
private JPanel panel;
private JTextField redField;
private JTextField greenField;
private JTextField blueField;

17
18
19
20

public ColorFrame()
{
panel = new JPanel();

21

panel.add(new JLabel("Red:"));
redField = new JTextField("255", 3);
panel.add(redField);

22
23
24
25

panel.add(new JLabel("Green:"));
greenField = new JTextField("255", 3);
panel.add(greenField);

26
27
28
29

panel.add(new JLabel("Blue:"));
blueField = new JTextField("255", 3);
panel.add(blueField);

30
31
32
33

LayerUI<JPanel> layerUI = new PanelLayer();
JLayer<JPanel> layer = new JLayer<JPanel>(panel, layerUI);

34
35
36

add(layer);
pack();

37
38
39

}

40
41
42
43
44
45
46
47

class PanelLayer extends LayerUI<JPanel>
{
public void installUI(JComponent c)
{
super.installUI(c);
((JLayer<?>) c).setLayerEventMask(AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);
}

48
49
50
51
52
53

public void uninstallUI(JComponent c)
{
((JLayer<?>) c).setLayerEventMask(0);
super.uninstallUI(c);
}

From the Library of Hristo Dimov Hristov

10.6 Component Organizers and Decorators

763

54

protected void processKeyEvent(KeyEvent e, JLayer<? extends JPanel> l)
{
l.repaint();
}

55
56
57
58
59

protected void processFocusEvent(FocusEvent e, JLayer<? extends JPanel> l)
{
if (e.getID() == FocusEvent.FOCUS_GAINED)
{
Component c = e.getComponent();
c.setFont(getFont().deriveFont(Font.BOLD));
}
if (e.getID() == FocusEvent.FOCUS_LOST)
{
Component c = e.getComponent();
c.setFont(getFont().deriveFont(Font.PLAIN));
}
}

60
61
62
63
64
65
66
67
68
69
70
71
72
73

public void paint(Graphics g, JComponent c)
{
super.paint(g, c);

74
75
76
77

Graphics2D g2 = (Graphics2D) g.create();
g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, .3f));
int red = Integer.parseInt(redField.getText().trim());
int green = Integer.parseInt(greenField.getText().trim());
int blue = Integer.parseInt(blueField.getText().trim());
g2.setPaint(new Color(red, green, blue));
g2.fillRect(0, 0, c.getWidth(), c.getHeight());
g2.dispose();

78
79
80
81
82
83
84
85

}

86

}

87
88

}

javax.swing.JLayer<V extends Component> 7

• JLayer(V view, LayerUI<V> ui)
constructs a layer over the given view, delegating painting and event handling to
the ui object.
(Continues)

From the Library of Hristo Dimov Hristov

764

Chapter 10

Advanced Swing

javax.swing.JLayer<V extends Component> 7 (Continued)

• void setLayerEventMask(long layerEventMask)
enables sending of all matching events, sent to the associated component or any of
it descendants, to the associated LayerUI. For the event mask, combine any of the
constants
COMPONENT_EVENT_MASK
FOCUS_EVENT_MASK
HIERARCHY_BOUNDS_EVENT_MASK
HIERARCHY_EVENT_MASK
INPUT_METHOD_EVENT_MASK

KEY_EVENT_MASK
MOUSE_EVENT_MASK
MOUSE_MOTION_EVENT_MASK
MOUSE_WHEEL_EVENT_MASK

from the AWTEvent class.

javax.swing.plaf.LayerUI<V extends Component> 7

• void installUI(JComponent c)
• void uninstallUI(JComponent c)
Called when the LayerUI for the component c is installed or uninstalled. Override to
set or clear the layer event mask.
• void paint(Graphics g, JComponent c)
Called when the decorated component is painted. Override to call super.paint and
paint decorations.
•
•
•
•
•
•
•
•
•

void processComponentEvent(ComponentEvent e, JLayer<? extends V> l)
void processFocusEvent(FocusEvent e, JLayer<? extends V> l)
void processHierarchyBoundsEvent(HierarchyEvent e, JLayer<? extends V> l)
void processHierarchyEvent(HierarchyEvent e, JLayer<? extends V> l)
void processInputMethodEvent(InputMethodEvent e, JLayer<? extends V> l)
void processKeyEvent(KeyEvent e, JLayer<? extends V> l)
void processMouseEvent(MouseEvent e, JLayer<? extends V> l)
void processMouseMotionEvent(MouseEvent e, JLayer<? extends V> l)
void processMouseWheelEvent(MouseWheelEvent e, JLayer<? extends V> l)

Called when the specified event is sent to this LayerUI.

You have now seen how to use the complex components that the Swing framework
offers. In the next chapter, we will turn to advanced AWT issues: complex
drawing operations, image manipulation, printing, and interfacing with the native
windowing system.

From the Library of Hristo Dimov Hristov

