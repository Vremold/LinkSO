Suppose you have a C function that does something you like and, for one reason
or another, you don’t want to bother reimplementing it in Java. For the sake of
illustration, we’ll start with a simple C function that prints a greeting.
The Java programming language uses the keyword native for a native method,
and you will obviously need to place a method in a class. The result is shown in
Listing 12.1.
The native keyword alerts the compiler that the method will be defined externally.
Of course, native methods will contain no code in the Java programming language,
and the method header is followed immediately by a terminating semicolon.
Therefore, native method declarations look similar to abstract method declarations.

From the Library of Hristo Dimov Hristov

12.1 Calling a C Function from a Java Program

Listing 12.1
1
2
3
4
5
6
7
8

941

helloNative/HelloNative.java

/**
* @version 1.11 2007-10-26
* @author Cay Horstmann
*/
class HelloNative
{
public static native void greeting();
}

NOTE: As in the previous chapter, we do not use packages here to keep
examples simple.

In this particular example, the native method is also declared as static. Native
methods can be both static and nonstatic. We’ll start with a static method because
we do not yet want to deal with parameter passing.
You can actually compile this class, but if you try to use it in a program, the virtual machine will tell you it doesn’t know how to find greeting—reporting an
UnsatisfiedLinkError. To implement the native code, write a corresponding C function.
You must name that function exactly the way the Java virtual machine expects.
Here are the rules:
1.
2.
3.

Use the full Java method name, such as HelloNative.greeting. If the class is in a
package, prepend the package name, such as com.horstmann.HelloNative.greeting.
Replace every period with an underscore, and append the prefix Java_. For
example, Java_HelloNative_greeting or Java_com_horstmann_HelloNative_greeting.
If the class name contains characters that are not ASCII letters or digits—that
is, '_', '$', or Unicode characters with codes greater than '\u007F'—replace
them with _0xxxx , where xxxx is the sequence of four hexadecimal digits of
the character’s Unicode value.

NOTE: If you overload native methods—that is, if you provide multiple native
methods with the same name—you must append a double underscore followed
by the encoded argument types. (We’ll describe the encoding of the argument
types later in this chapter.) For example, if you have a native method greeting
and another native method greeting(int repeat), then the first one is called
Java_HelloNative_greeting__, and the second, Java_HelloNative_greeting__I.

From the Library of Hristo Dimov Hristov

942

Chapter 12

Native Methods

Actually, nobody does this by hand; instead, run the javah utility which automatically generates the function names. To use javah, first compile the source file in
Listing 12.1:
javac HelloNative.java

Next, call the javah utility, which produces a C header file from the class file. The
javah executable can be found in the jdk/bin directory. Invoke it with the name of
the class, just as you would start a Java program:
javah HelloNative

This command creates a header file, HelloNative.h, shown in Listing 12.2.

Listing 12.2
1
2
3

helloNative/HelloNative.h

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class HelloNative */

4
5
6
7
8
9
10
11
12
13
14
15
16

#ifndef _Included_HelloNative
#define _Included_HelloNative
#ifdef __cplusplus
extern "C" {
#endif
/*
* Class:
HelloNative
* Method: greeting
* Signature: ()V
*/
JNIEXPORT void JNICALL Java_HelloNative_greeting
(JNIEnv *, jclass);

17
18
19
20
21

#ifdef __cplusplus
}
#endif
#endif

As you can see, this file contains the declaration of a function Java_HelloNative_greeting.
(The macros JNIEXPORT and JNICALL are defined in the header file jni.h. They
denote compiler-dependent specifiers for exported functions that come from
a dynamically loaded library.)

From the Library of Hristo Dimov Hristov

12.1 Calling a C Function from a Java Program

943

Now, simply copy the function prototype from the header file into a source file
and give the implementation code for the function, as shown in Listing 12.3.

Listing 12.3
1

/*
@version 1.10 1997-07-01
@author Cay Horstmann

2
3
4

helloNative/HelloNative.c

*/

5
6
7

#include "HelloNative.h"
#include <stdio.h>

8
9
10
11
12

JNIEXPORT void JNICALL Java_HelloNative_greeting(JNIEnv* env, jclass cl)
{
printf("Hello Native World!\n");
}

In this simple function, ignore the env and cl arguments. You’ll see their use later.
C++ NOTE: You can use C++ to implement native methods. However, you must
then declare the functions that implement the native methods as extern "C". (This
stops the C++ compiler from “mangling” the method name.) For example,
extern "C"
JNIEXPORT void JNICALL Java_HelloNative_greeting(JNIEnv* env, jclass cl)
{
cout << "Hello, Native World!" << endl;
}

Compile the native C code into a dynamically loaded library. The details depend
on your compiler.
For example, with the GNU C compiler on Linux, use these commands:
gcc -fPIC -I jdk/include -I jdk/include/linux -shared -o libHelloNative.so HelloNative.c

With the Sun compiler under the Solaris operating system, the command is
cc -G -I jdk/include -I jdk/include/solaris -o libHelloNative.so HelloNative.c

From the Library of Hristo Dimov Hristov

944

Chapter 12

Native Methods

With the Microsoft compiler under Windows, the command is
cl -I jdk\include -I jdk\include\win32 -LD HelloNative.c -FeHelloNative.dll

Here, jdk is the directory that contains the JDK.

TIP: If you use the Microsoft compiler from a command shell, first run a batch
file such as vsvars32.bat or vcvarsall.bat. That batch file sets up the path and the
environment variables needed by the compiler. You can find it in the directory
c:\Program Files\Microsoft Visual Studio 14.0\Common7\Tools, or a similar monstrosity.
Check the Visual Studio documentation for details.

You can also use the freely available Cygwin programming environment from
www.cygwin.com. It contains the GNU C compiler and libraries for UNIX-style
programming on Windows. With Cygwin, use the command
gcc -mno-cygwin -D __int64="long long" -I jdk/include/ -I jdk/include/win32
-shared -Wl,--add-stdcall-alias -o HelloNative.dll HelloNative.c

Type the entire command on a single line.
NOTE: The Windows version of the header file jni_md.h contains the type
declaration
typedef __int64 jlong;

which is specific to the Microsoft compiler. If you use the GNU compiler, you
might want to edit that file, for example,
#ifdef __GNUC__
typedef long long jlong;
#else
typedef __int64 jlong;
#endif

Alternatively, compile with -D __int64="long long", as shown in the sample compiler
invocation.

Finally, add a call to the System.loadLibrary method in your program. To ensure that
the virtual machine will load the library before the first use of the class, use a
static initialization block, as in Listing 12.4.
Figure 12.1 gives a summary of the native code processing.
After you compile and run this program, the message “Hello, Native World!” is
displayed in a terminal window.

From the Library of Hristo Dimov Hristov

12.1 Calling a C Function from a Java Program

945

Figure 12.1 Processing native code
Listing 12.4
1
2
3
4

helloNative/HelloNativeTest.java

/**
* @version 1.11 2007-10-26
* @author Cay Horstmann
*/
(Continues)

From the Library of Hristo Dimov Hristov

946

Chapter 12

Native Methods

Listing 12.4 (Continued)
5
6
7
8
9
10

class HelloNativeTest
{
public static void main(String[] args)
{
HelloNative.greeting();
}

11

static
{
System.loadLibrary("HelloNative");
}

12
13
14
15
16

}

NOTE: If you run Linux, you must add the current directory to the library path.
Either set the LD_LIBRARY_PATH environment variable:
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH

or set the java.library.path system property:
java -Djava.library.path=. HelloNativeTest

Of course, this is not particularly impressive by itself. However, keep in mind
that this message is generated by the C printf command and not by any Java programming language code. We have taken the first step toward bridging the gap
between the two languages!
In summary, follow these steps to link a native method to a Java program:
1.
2.
3.
4.
5.

Declare a native method in a Java class.
Run javah to get a header file with a C declaration for the method.
Implement the native method in C.
Place the code in a shared library.
Load that library in your Java program.
java.lang.System 1.0

• void loadLibrary(String libname)
loads the library with the given name. The library is located in the library search
path. The exact method for locating the library depends on the operating system.

From the Library of Hristo Dimov Hristov

